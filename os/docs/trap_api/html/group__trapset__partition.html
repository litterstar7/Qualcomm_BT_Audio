<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: PARTITION</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__partition.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PARTITION<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga790242efea62826fdc7e2a58b55da550"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga790242efea62826fdc7e2a58b55da550">PartitionGetInfo</a> (partition_filesystem_devices device, uint16 partition, partition_info_key key, uint32 *value)</td></tr>
<tr class="memdesc:ga790242efea62826fdc7e2a58b55da550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information about a partition.  <a href="#ga790242efea62826fdc7e2a58b55da550">More...</a><br /></td></tr>
<tr class="separator:ga790242efea62826fdc7e2a58b55da550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95a7007ecaff46f868d5280a09f509e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga95a7007ecaff46f868d5280a09f509e6">PartitionGetRawSerialSource</a> (uint16 device, uint16 partition)</td></tr>
<tr class="memdesc:ga95a7007ecaff46f868d5280a09f509e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will return the source with the contents of the specified raw serial partition.  <a href="#ga95a7007ecaff46f868d5280a09f509e6">More...</a><br /></td></tr>
<tr class="separator:ga95a7007ecaff46f868d5280a09f509e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga153745c39faf6f85f952c1acbc7baee8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga153745c39faf6f85f952c1acbc7baee8">PartitionMountFilesystem</a> (partition_filesystem_devices device, uint16 partition, partition_filesystem_priority priority)</td></tr>
<tr class="memdesc:ga153745c39faf6f85f952c1acbc7baee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a partition to the union file system.  <a href="#ga153745c39faf6f85f952c1acbc7baee8">More...</a><br /></td></tr>
<tr class="separator:ga153745c39faf6f85f952c1acbc7baee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28d22a4efbf1de66c824389af0bbbb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#gae28d22a4efbf1de66c824389af0bbbb8">PartitionSetMessageDigest</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, partition_message_digest_type md_type, uint16 *data, uint16 len)</td></tr>
<tr class="memdesc:gae28d22a4efbf1de66c824389af0bbbb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a message digest for a stream writing to flash partition. Message digest data will be copied and stored by the firmware. When a flash partition is written to, the first word is not immediately written. Instead it is saved in RAM until the stream is closed. At this point the flash partition is read back and verified against the stored message digest. If the verification is successful, the first word is written to flash. This protects against partly or incorrectly written partitions. If this trap is not called against a partition write sink, the verification will not be performed, but the first word will not be written until the stream is closed, protecting against partly written partitions.  <a href="#gae28d22a4efbf1de66c824389af0bbbb8">More...</a><br /></td></tr>
<tr class="separator:gae28d22a4efbf1de66c824389af0bbbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343057d847e5426b30733bfec20eb0e0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga343057d847e5426b30733bfec20eb0e0">PartitionSinkGetPosition</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga343057d847e5426b30733bfec20eb0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sink position of the partition sink stream.  <a href="#ga343057d847e5426b30733bfec20eb0e0">More...</a><br /></td></tr>
<tr class="separator:ga343057d847e5426b30733bfec20eb0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga803dbd145cc26e0f966117973e79cf03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga803dbd145cc26e0f966117973e79cf03">PsStoreFsTab</a> (const void *buff, uint16 words, bool commit)</td></tr>
<tr class="memdesc:ga803dbd145cc26e0f966117973e79cf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the specified memory buffer into PSKEY_FSTAB within the persistent store The function operates in a similar manner to.  <a href="#ga803dbd145cc26e0f966117973e79cf03">More...</a><br /></td></tr>
<tr class="separator:ga803dbd145cc26e0f966117973e79cf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70fe88d9648012b6db1f10fc90b4b17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga70fe88d9648012b6db1f10fc90b4b17e">StreamPartitionOverwriteSink</a> (partition_filesystem_devices device, uint16 partition)</td></tr>
<tr class="memdesc:ga70fe88d9648012b6db1f10fc90b4b17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a sink to erase and write to an external flash partition. This function will perform a flash erase on the entire partition specified and then provide a Sink to allow it to be written from the start.  <a href="#ga70fe88d9648012b6db1f10fc90b4b17e">More...</a><br /></td></tr>
<tr class="separator:ga70fe88d9648012b6db1f10fc90b4b17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bddf787e5983a016efa8253a3bb34ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__partition.html#ga2bddf787e5983a016efa8253a3bb34ca">StreamPartitionResumeSink</a> (partition_filesystem_devices device, uint16 partition_no, uint16 first_word)</td></tr>
<tr class="memdesc:ga2bddf787e5983a016efa8253a3bb34ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume external flash sink partition after a controlled power failure.  <a href="#ga2bddf787e5983a016efa8253a3bb34ca">More...</a><br /></td></tr>
<tr class="separator:ga2bddf787e5983a016efa8253a3bb34ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga790242efea62826fdc7e2a58b55da550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga790242efea62826fdc7e2a58b55da550">&#9670;&nbsp;</a></span>PartitionGetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PartitionGetInfo </td>
          <td>(</td>
          <td class="paramtype">partition_filesystem_devices&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">partition_info_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information about a partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to query, see #partition_filesystem_devices </td></tr>
    <tr><td class="paramname">partition</td><td>number of partition to query </td></tr>
    <tr><td class="paramname">key</td><td>specifies information requested, see #partition_info_key </td></tr>
    <tr><td class="paramname">value</td><td>returned value as specified by #key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if partition found and queried successfully, otherwise FALSE</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga95a7007ecaff46f868d5280a09f509e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95a7007ecaff46f868d5280a09f509e6">&#9670;&nbsp;</a></span>PartitionGetRawSerialSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> PartitionGetRawSerialSource </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will return the source with the contents of the specified raw serial partition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to query, see #partition_filesystem_devices </td></tr>
    <tr><td class="paramname">partition</td><td>number of partition to read raw data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The source associated with the raw partition stream.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga153745c39faf6f85f952c1acbc7baee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga153745c39faf6f85f952c1acbc7baee8">&#9670;&nbsp;</a></span>PartitionMountFilesystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PartitionMountFilesystem </td>
          <td>(</td>
          <td class="paramtype">partition_filesystem_devices&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">partition_filesystem_priority&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount a partition to the union file system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to which to mount, see #partition_filesystem_devices </td></tr>
    <tr><td class="paramname">partition</td><td>number of partition to mount </td></tr>
    <tr><td class="paramname">priority</td><td>mount at higher or lower priority to already mounted file systems, see #partition_filesystem_priority </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if partition found and mounted successfully, otherwise FALSE</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="gae28d22a4efbf1de66c824389af0bbbb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae28d22a4efbf1de66c824389af0bbbb8">&#9670;&nbsp;</a></span>PartitionSetMessageDigest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PartitionSetMessageDigest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">partition_message_digest_type&#160;</td>
          <td class="paramname"><em>md_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a message digest for a stream writing to flash partition. Message digest data will be copied and stored by the firmware. When a flash partition is written to, the first word is not immediately written. Instead it is saved in RAM until the stream is closed. At this point the flash partition is read back and verified against the stored message digest. If the verification is successful, the first word is written to flash. This protects against partly or incorrectly written partitions. If this trap is not called against a partition write sink, the verification will not be performed, but the first word will not be written until the stream is closed, protecting against partly written partitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>sink that is writing to the partition </td></tr>
    <tr><td class="paramname">md_type</td><td>the type of message digest, see #partition_message_digest_type </td></tr>
    <tr><td class="paramname">data</td><td>pointer to message digest </td></tr>
    <tr><td class="paramname">len</td><td>length of message digest </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if sink is valid, data is correct length and message digest set successfully, otherwise FALSE</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga343057d847e5426b30733bfec20eb0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343057d847e5426b30733bfec20eb0e0">&#9670;&nbsp;</a></span>PartitionSinkGetPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PartitionSinkGetPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sink position of the partition sink stream. </p>
<p>This VM trap is used to get the sink position of the specified sink partition in octets. Firmware returns a sink position from which, each word has a value of 0xFFFF till the end of the partition. Firmware assumes that the partition contents before the sink position (except first word) are successfully written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>sink stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sink position of the specified sink partition.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga803dbd145cc26e0f966117973e79cf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga803dbd145cc26e0f966117973e79cf03">&#9670;&nbsp;</a></span>PsStoreFsTab()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PsStoreFsTab </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the specified memory buffer into PSKEY_FSTAB within the persistent store The function operates in a similar manner to. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore</a> but only operates on the PSKEY_FSTAB persistent store key. The parameter commit is used to set which store the value will be written to. The data to write must always be passed to the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data from. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy. </td></tr>
    <tr><td class="paramname">commit</td><td>Write the new FSTAB to non-volatile memory or not. If FALSE then the new FSTAB will only be stable across warm reboots; this feature can be used to enable the newly upgrade application to perform system checks before setting the FSTAB in the non-volatile store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation succeeded or FALSE if it failed</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga70fe88d9648012b6db1f10fc90b4b17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70fe88d9648012b6db1f10fc90b4b17e">&#9670;&nbsp;</a></span>StreamPartitionOverwriteSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamPartitionOverwriteSink </td>
          <td>(</td>
          <td class="paramtype">partition_filesystem_devices&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a sink to erase and write to an external flash partition. This function will perform a flash erase on the entire partition specified and then provide a Sink to allow it to be written from the start. </p>
<dl class="section note"><dt>Note</dt><dd>If the VM application uses the VM software watchdog functionality, BlueCore firmware automatically extends the VM software watchdog before the erase of an external serial flash memory. Erasing of the external serial flash memory is time consuming. This ensures that the VM application is given enough time to kick the VM software watchdog when the operation has completed. </dd>
<dd>
This trap expects all the partitions in the #PARTITION_SERIAL_FLASH device to be sector aligned. If partition is not sector aligned then firmware will erase shared sectors (i.e., end of previous partition's sector or start of next partition's sector). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to which to write, cannot be internal flash, see #partition_filesystem_devices </td></tr>
    <tr><td class="paramname">partition</td><td>partition number to overwrite </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sink if partition found and erased successfully, otherwise zero</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga2bddf787e5983a016efa8253a3bb34ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bddf787e5983a016efa8253a3bb34ca">&#9670;&nbsp;</a></span>StreamPartitionResumeSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamPartitionResumeSink </td>
          <td>(</td>
          <td class="paramtype">partition_filesystem_devices&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>first_word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume external flash sink partition after a controlled power failure. </p>
<p>This VM trap is used to resume sink stream to write into external flash partition which got interrupted while writing previously. This trap returns the sink stream by reopening the stream for the interrupted external flash partition. This trap will not erase the contents of the partition. See #PartitionSinkGetPosition trap description to know how to retrieve the sink position from which the data can be written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>device to which to write, cannot be internal flash, see #partition_filesystem_devices. </td></tr>
    <tr><td class="paramname">partition_no</td><td>partition number of the sink partition to be resumed. </td></tr>
    <tr><td class="paramname">first_word</td><td>first word of the sink partition to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sink if partition found or sink already exists, else return NULL</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
