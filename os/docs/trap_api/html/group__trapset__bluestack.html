<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: BLUESTACK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__bluestack.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLUESTACK<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga10725ea9d3d838056f05bdb533b3986d"><td class="memItemLeft" align="right" valign="top">InquiryPriority&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga10725ea9d3d838056f05bdb533b3986d">InquiryGetPriority</a> (void)</td></tr>
<tr class="memdesc:ga10725ea9d3d838056f05bdb533b3986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return 0.  <a href="#ga10725ea9d3d838056f05bdb533b3986d">More...</a><br /></td></tr>
<tr class="separator:ga10725ea9d3d838056f05bdb533b3986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga65db1eff3aadbff0b93ea396cc0e81b0">InquirySetPriority</a> (InquiryPriority priority)</td></tr>
<tr class="memdesc:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Bluetooth inquiry procedure.  <a href="#ga65db1eff3aadbff0b93ea396cc0e81b0">More...</a><br /></td></tr>
<tr class="separator:ga65db1eff3aadbff0b93ea396cc0e81b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga95b9d502d69a5d4e42cc3b9334c94b32">MessageBlueStackTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a task to handle BlueStack primitives.  <a href="#ga95b9d502d69a5d4e42cc3b9334c94b32">More...</a><br /></td></tr>
<tr class="separator:ga95b9d502d69a5d4e42cc3b9334c94b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5789ebdfd7814f743c051b45289b58b6"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5789ebdfd7814f743c051b45289b58b6">SinkGetL2capCid</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga5789ebdfd7814f743c051b45289b58b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the L2CAP channel id corresponding to a sink.  <a href="#ga5789ebdfd7814f743c051b45289b58b6">More...</a><br /></td></tr>
<tr class="separator:ga5789ebdfd7814f743c051b45289b58b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8993b3833971180e7154a9d8e100832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gad8993b3833971180e7154a9d8e100832">SinkPollAwayTime</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 *msec)</td></tr>
<tr class="memdesc:gad8993b3833971180e7154a9d8e100832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the away time on the underlying ACL.  <a href="#gad8993b3833971180e7154a9d8e100832">More...</a><br /></td></tr>
<tr class="separator:gad8993b3833971180e7154a9d8e100832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382089ef9cc353b61de31b31c47ceae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga382089ef9cc353b61de31b31c47ceae3">StreamL2capSink</a> (uint16 cid)</td></tr>
<tr class="memdesc:ga382089ef9cc353b61de31b31c47ceae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Sink corresponding to an L2CAP connection.  <a href="#ga382089ef9cc353b61de31b31c47ceae3">More...</a><br /></td></tr>
<tr class="separator:ga382089ef9cc353b61de31b31c47ceae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1fcd189669b92707329c3cfadb37d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gaae1fcd189669b92707329c3cfadb37d5">VmBdAddrGetRssi</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr, int16 *rssi)</td></tr>
<tr class="memdesc:gaae1fcd189669b92707329c3cfadb37d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RSSI for the ACL with given remote device.  <a href="#gaae1fcd189669b92707329c3cfadb37d5">More...</a><br /></td></tr>
<tr class="separator:gaae1fcd189669b92707329c3cfadb37d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cf7f61ce5b649757798909457ab52a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gaf1cf7f61ce5b649757798909457ab52a">VmGetAclLinkQuality</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address, uint16 *link_quality)</td></tr>
<tr class="memdesc:gaf1cf7f61ce5b649757798909457ab52a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the ACL rx link quality. This trap is intended to support 'wireless' debugging of link issues for example as a 'quantitative' metric to compare the quality of the primary's and secondary's receptions from the remote Bluetooth device. Only EDR ACL links are supported and not LE links. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices as their radios don't implement this feature.  <a href="#gaf1cf7f61ce5b649757798909457ab52a">More...</a><br /></td></tr>
<tr class="separator:gaf1cf7f61ce5b649757798909457ab52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga4eb51076a93f160ca1ae2ba1db45681a">VmGetAclMode</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address)</td></tr>
<tr class="memdesc:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the mode of the defined ACL connection.  <a href="#ga4eb51076a93f160ca1ae2ba1db45681a">More...</a><br /></td></tr>
<tr class="separator:ga4eb51076a93f160ca1ae2ba1db45681a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga9576d235fcdbdfed5df63c8e79e490b3">VmGetAclRole</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *acl_address)</td></tr>
<tr class="memdesc:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the role of the defined ACL connection.  <a href="#ga9576d235fcdbdfed5df63c8e79e490b3">More...</a><br /></td></tr>
<tr class="separator:ga9576d235fcdbdfed5df63c8e79e490b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e104a1dc884af12dbccd18a608018fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga6e104a1dc884af12dbccd18a608018fa">VmGetBdAddrtFromCid</a> (uint16 cid, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:ga6e104a1dc884af12dbccd18a608018fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value.  <a href="#ga6e104a1dc884af12dbccd18a608018fa">More...</a><br /></td></tr>
<tr class="separator:ga6e104a1dc884af12dbccd18a608018fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac29e1496922249cd04d17dd64558faab"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab">VmGetHandleFromPointer</a> (void *pointer)</td></tr>
<tr class="memdesc:gac29e1496922249cd04d17dd64558faab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must:  <a href="#gac29e1496922249cd04d17dd64558faab">More...</a><br /></td></tr>
<tr class="separator:gac29e1496922249cd04d17dd64558faab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga64c8a83677acdc389f0b3454c4ea7b7f">VmGetLocalIrk</a> (<a class="el" href="structpacked__irk.html">packed_irk</a> *irk)</td></tr>
<tr class="memdesc:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves local IRK (Identity Resolving Key) of the device.  <a href="#ga64c8a83677acdc389f0b3454c4ea7b7f">More...</a><br /></td></tr>
<tr class="separator:ga64c8a83677acdc389f0b3454c4ea7b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7">VmGetPointerFromHandle</a> (void *handle)</td></tr>
<tr class="memdesc:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS.  <a href="#ga5caccd8ae3cfa1246373caffe1d218b7">More...</a><br /></td></tr>
<tr class="separator:ga5caccd8ae3cfa1246373caffe1d218b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1258d4e01d5cec00dd9a21ae73ed9966">VmGetPublicAddress</a> (const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *random_addr, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *public_addr)</td></tr>
<tr class="memdesc:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves public address for a given random address. Note: To be used only on an established link.  <a href="#ga1258d4e01d5cec00dd9a21ae73ed9966">More...</a><br /></td></tr>
<tr class="separator:ga1258d4e01d5cec00dd9a21ae73ed9966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga5d78960f4bdd7bc5a00f305650964ba4">VmGetScoStatistics</a> (uint16 handle, sco_statistics_t *sco_stats)</td></tr>
<tr class="memdesc:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read SCO statistics for the given SCO connection. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices.  <a href="#ga5d78960f4bdd7bc5a00f305650964ba4">More...</a><br /></td></tr>
<tr class="separator:ga5d78960f4bdd7bc5a00f305650964ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga2f6a871c7336b62f171fa4302c24e00e">VmOverrideL2capConnContext</a> (uint16 cid, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga2f6a871c7336b62f171fa4302c24e00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override L2CAP connecton context.  <a href="#ga2f6a871c7336b62f171fa4302c24e00e">More...</a><br /></td></tr>
<tr class="separator:ga2f6a871c7336b62f171fa4302c24e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga717489e28b88057dde0c6e96c1137dce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga717489e28b88057dde0c6e96c1137dce">VmOverrideRfcommConnContext</a> (uint16 conn_id, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga717489e28b88057dde0c6e96c1137dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override RFCOMM connecton context.  <a href="#ga717489e28b88057dde0c6e96c1137dce">More...</a><br /></td></tr>
<tr class="separator:ga717489e28b88057dde0c6e96c1137dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga25d4e01659e990ebc0b77ceb832869c8">VmOverrideSyncConnContext</a> (uint16 handle, <a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a> context)</td></tr>
<tr class="memdesc:ga25d4e01659e990ebc0b77ceb832869c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override DM Sync connecton context.  <a href="#ga25d4e01659e990ebc0b77ceb832869c8">More...</a><br /></td></tr>
<tr class="separator:ga25d4e01659e990ebc0b77ceb832869c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c7349b61ec91e3078739b24c9832f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga0c7349b61ec91e3078739b24c9832f64">VmSendDmPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga0c7349b61ec91e3078739b24c9832f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a DM Bluestack primitive.  <a href="#ga0c7349b61ec91e3078739b24c9832f64">More...</a><br /></td></tr>
<tr class="separator:ga0c7349b61ec91e3078739b24c9832f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga623628caf10541c84058d562a909b329"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga623628caf10541c84058d562a909b329">VmSendL2capPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga623628caf10541c84058d562a909b329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an L2CAP Bluestack primitive.  <a href="#ga623628caf10541c84058d562a909b329">More...</a><br /></td></tr>
<tr class="separator:ga623628caf10541c84058d562a909b329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2a62ea647b44972a997650ffb74938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#ga1b2a62ea647b44972a997650ffb74938">VmSendSdpPrim</a> (void *prim)</td></tr>
<tr class="memdesc:ga1b2a62ea647b44972a997650ffb74938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an SDP Bluestack primitive.  <a href="#ga1b2a62ea647b44972a997650ffb74938">More...</a><br /></td></tr>
<tr class="separator:ga1b2a62ea647b44972a997650ffb74938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaffd14325353278ea2e684f06b14c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__bluestack.html#gacbaffd14325353278ea2e684f06b14c1">VmUpdateRootKeys</a> (<a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *root_keys)</td></tr>
<tr class="memdesc:gacbaffd14325353278ea2e684f06b14c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap.  <a href="#gacbaffd14325353278ea2e684f06b14c1">More...</a><br /></td></tr>
<tr class="separator:gacbaffd14325353278ea2e684f06b14c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga10725ea9d3d838056f05bdb533b3986d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10725ea9d3d838056f05bdb533b3986d">&#9670;&nbsp;</a></span>InquiryGetPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InquiryPriority InquiryGetPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return 0. </p>
<dl class="section return"><dt>Returns</dt><dd>The current priority level. </dd></dl>

</div>
</div>
<a id="ga65db1eff3aadbff0b93ea396cc0e81b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65db1eff3aadbff0b93ea396cc0e81b0">&#9670;&nbsp;</a></span>InquirySetPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool InquirySetPriority </td>
          <td>(</td>
          <td class="paramtype">InquiryPriority&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Bluetooth inquiry procedure. </p>
<p>fileThese functions can be used to change the details of how BlueCore schedules Bluetooth inquiry relative to other Bluetooth activity. They are equivalent to the Inquiry_Priority BCCMD. Sets the priority level of Bluetooth inquiry. Trap unsupported on QCC514x and QCC304x and newer devices, if called it will return FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The desired priority level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the level was successfully set, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga95b9d502d69a5d4e42cc3b9334c94b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95b9d502d69a5d4e42cc3b9334c94b32">&#9670;&nbsp;</a></span>MessageBlueStackTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageBlueStackTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a task to handle BlueStack primitives. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This task will receive MESSAGE_BLUESTACK_*_PRIM, except #MESSAGE_BLUESTACK_ATT_PRIM that are handled by the <a class="el" href="group__trapset__att.html#gabcdbacb41dd8edf00d78888bbc8469c8" title="Register a task to handle BlueStack ATT primitives. ">MessageAttTask()</a> and #MESSAGE_BLUESTACK_MDM_PRIM that are handled by the <a class="el" href="group__trapset__mirroring.html#gab215a7e45af8240428971e5c3e55c988" title="Register a task to handle BlueStack Mirroring Manager(MDM) primitives. ">MessageMdmTask()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero). </dd></dl>

</div>
</div>
<a id="ga5789ebdfd7814f743c051b45289b58b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5789ebdfd7814f743c051b45289b58b6">&#9670;&nbsp;</a></span>SinkGetL2capCid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SinkGetL2capCid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the L2CAP channel id corresponding to a sink. </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get L2CAP channel id from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to get the connection identifier for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8993b3833971180e7154a9d8e100832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8993b3833971180e7154a9d8e100832">&#9670;&nbsp;</a></span>SinkPollAwayTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkPollAwayTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>msec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the away time on the underlying ACL. </p>
<p>The away time is the time since any packet was received on that ACL and is reported in milliseconds. If the time exceeds 0xFFFF, 0xFFFF will be returned (this is unlikely with sensible link supervision timeouts.) </p><dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns Zero because BlueCore firmware can not get ACL connections from operator sink stream. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>identifies the underlying ACL </td></tr>
    <tr><td class="paramname">msec</td><td>receives the away time if the call succeeds (unmodified otherwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sink identifies an ACL and the away time on that link could be read, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga382089ef9cc353b61de31b31c47ceae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382089ef9cc353b61de31b31c47ceae3">&#9670;&nbsp;</a></span>StreamL2capSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamL2capSink </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Sink corresponding to an L2CAP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection ID to fetch the Sink for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae1fcd189669b92707329c3cfadb37d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae1fcd189669b92707329c3cfadb37d5">&#9670;&nbsp;</a></span>VmBdAddrGetRssi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmBdAddrGetRssi </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RSSI for the ACL with given remote device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tpaddr</td><td>The remote Bluetooth device address. </td></tr>
    <tr><td class="paramname">rssi</td><td>If a valid ACL is found, the RSSI in dBm will be written to this location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the RSSI has been obtained successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="gaf1cf7f61ce5b649757798909457ab52a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1cf7f61ce5b649757798909457ab52a">&#9670;&nbsp;</a></span>VmGetAclLinkQuality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetAclLinkQuality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>link_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the ACL rx link quality. This trap is intended to support 'wireless' debugging of link issues for example as a 'quantitative' metric to compare the quality of the primary's and secondary's receptions from the remote Bluetooth device. Only EDR ACL links are supported and not LE links. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices as their radios don't implement this feature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
    <tr><td class="paramname">link_quality</td><td>Pointer to the memory to write the link quality if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a id="ga4eb51076a93f160ca1ae2ba1db45681a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eb51076a93f160ca1ae2ba1db45681a">&#9670;&nbsp;</a></span>VmGetAclMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 VmGetAclMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the mode of the defined ACL connection. </p>
<p>This trap allows the application to read the mode of a ACL connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HCI_BT_MODE_ACTIVE, HCI_BT_MODE_HOLD or HCI_BT_MODE_SNIFF will be returned if the ACL exists. HCI_BT_MODE_MAX will be returned if the ACL does not exist. These values are defined in the file hci.h. </dd></dl>

</div>
</div>
<a id="ga9576d235fcdbdfed5df63c8e79e490b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9576d235fcdbdfed5df63c8e79e490b3">&#9670;&nbsp;</a></span>VmGetAclRole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 VmGetAclRole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>acl_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the role of the defined ACL connection. </p>
<p>This trap allows the application to read the local role of a ACL connection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acl_address</td><td>The remote Bluetooth device address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HCI_MASTER or HCI_SLAVE will be returned if the ACL exists. HCI_MASTER_SLAVE_UNKNOWN will be returned if the ACL does not exist. These values are defined in the file hci.h. </dd></dl>

</div>
</div>
<a id="ga6e104a1dc884af12dbccd18a608018fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e104a1dc884af12dbccd18a608018fa">&#9670;&nbsp;</a></span>VmGetBdAddrtFromCid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetBdAddrtFromCid </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrives the <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> value from the given CID value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The connection identifier to fetch the Bluetooth address from. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>If the address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if an address was found for a given CID, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="gac29e1496922249cd04d17dd64558faab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac29e1496922249cd04d17dd64558faab">&#9670;&nbsp;</a></span>VmGetHandleFromPointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetHandleFromPointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a VM address space pointer to a handle When assembling a primitive which includes indirect blocks, the application must: </p>
<ul>
<li>Allocate a block</li>
<li>Convert it to a handle</li>
<li>Store the handle in the primitive rather than storing the pointer itself <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The pointer to convert. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ga64c8a83677acdc389f0b3454c4ea7b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c8a83677acdc389f0b3454c4ea7b7f">&#9670;&nbsp;</a></span>VmGetLocalIrk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetLocalIrk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__irk.html">packed_irk</a> *&#160;</td>
          <td class="paramname"><em>irk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves local IRK (Identity Resolving Key) of the device. </p>
<p>The IR (Identity Root) is a root key of the device for the LE Transport and is used to generate the local IRK. The local IRK can be requested only after the initialization of the IR value using "DM_SM_INIT_REQ_T" primitive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irk</td><td>If IRK information could be read, it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if local IRK was retrieved, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga5caccd8ae3cfa1246373caffe1d218b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5caccd8ae3cfa1246373caffe1d218b7">&#9670;&nbsp;</a></span>VmGetPointerFromHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* VmGetPointerFromHandle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks of memory, those are presented in the primitive as handles rather than real pointers. To access the data an application must pass the handle to <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> which will make the indirect block visible to the application. The application must call this exactly once for each such indirect block, and the resulting pointers must all be passed to free. Failure to perform this procedure will result in a resource leak. Note - while <a class="el" href="group__trapset__bluestack.html#gac29e1496922249cd04d17dd64558faab" title="Converts a VM address space pointer to a handle When assembling a primitive which includes indirect b...">VmGetHandleFromPointer()</a> will successfully produce a handle from a pointer to a constant, <a class="el" href="group__trapset__bluestack.html#ga5caccd8ae3cfa1246373caffe1d218b7" title="Converts a handle to a VM address space pointer. If a Bluestack primitive refers to indirect blocks o...">VmGetPointerFromHandle()</a> will not produce a pointer from such a handle. It will instead panic with VM_PANIC_READ_FROM_ILLEGAL_ADDRESS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle to convert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1258d4e01d5cec00dd9a21ae73ed9966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1258d4e01d5cec00dd9a21ae73ed9966">&#9670;&nbsp;</a></span>VmGetPublicAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetPublicAddress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>random_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>public_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves public address for a given random address. Note: To be used only on an established link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">random_addr</td><td>Random address. </td></tr>
    <tr><td class="paramname">public_addr</td><td>If the public address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if public address was found for a given resolvable random address, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga5d78960f4bdd7bc5a00f305650964ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d78960f4bdd7bc5a00f305650964ba4">&#9670;&nbsp;</a></span>VmGetScoStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmGetScoStatistics </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sco_statistics_t *&#160;</td>
          <td class="paramname"><em>sco_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read SCO statistics for the given SCO connection. This trap will return FALSE on CSRA68105, QCC302x and QCC512x devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The handle of SCO connection. </td></tr>
    <tr><td class="paramname">sco_stats</td><td>Pointer to the memory to write statistics if successful. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a id="ga2f6a871c7336b62f171fa4302c24e00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6a871c7336b62f171fa4302c24e00e">&#9670;&nbsp;</a></span>VmOverrideL2capConnContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideL2capConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>cid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override L2CAP connecton context. </p>
<p>This trap allows application to override the L2CAP connection context for a given cid. In general, this trap will be used where the L2CAP connection structures in Bluestack is populated as a result of unmarshalling and not because of a L2CAP connection initiation from the application. In such a case connection context in the L2CAP connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant L2CAP connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cid</td><td>The L2CAP connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga717489e28b88057dde0c6e96c1137dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga717489e28b88057dde0c6e96c1137dce">&#9670;&nbsp;</a></span>VmOverrideRfcommConnContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideRfcommConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>conn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override RFCOMM connecton context. </p>
<p>This trap allows application to override the RFCOMM connection context for a given RFCOMM connection id. In general, this trap will be used where the RFCOMM connection structures in Bluestack is populated as a result of unmarshalling and not because of a RFCOMM client connection initiation from the application. In such a case connection context in the RFCOMM connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant RFCOMM connection ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conn_id</td><td>The RFCOMM connection id </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga25d4e01659e990ebc0b77ceb832869c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25d4e01659e990ebc0b77ceb832869c8">&#9670;&nbsp;</a></span>VmOverrideSyncConnContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmOverrideSyncConnContext </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="vm___8h.html#af7048ed13446de52e9012e19b10aebd0">conn_context_t</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override DM Sync connecton context. </p>
<p>This trap allows application to override the DM Sync connection context for a given eSCO connection handle. In general, this trap will be used where the DM Sync connection structures in Bluestack is populated as a result of unmarshalling and not because of a DM Sync connection initiation from the application. In such a case connection context in the DM Sync connection structures won't be initialized. So, after unmarshalling, the application needs to explicitly call this trap to initialize the connection context for all the relevant eSCO connection handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The eSCO connection handle </td></tr>
    <tr><td class="paramname">context</td><td>Connection context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if connection context value is set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga0c7349b61ec91e3078739b24c9832f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7349b61ec91e3078739b24c9832f64">&#9670;&nbsp;</a></span>VmSendDmPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendDmPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a DM Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga623628caf10541c84058d562a909b329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga623628caf10541c84058d562a909b329">&#9670;&nbsp;</a></span>VmSendL2capPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendL2capPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an L2CAP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b2a62ea647b44972a997650ffb74938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b2a62ea647b44972a997650ffb74938">&#9670;&nbsp;</a></span>VmSendSdpPrim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmSendSdpPrim </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>prim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends an SDP Bluestack primitive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prim</td><td>A pointer to the primitive to send. The memory must have been dynamically allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbaffd14325353278ea2e684f06b14c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbaffd14325353278ea2e684f06b14c1">&#9670;&nbsp;</a></span>VmUpdateRootKeys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmUpdateRootKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpacked__root__keys.html">packed_root_keys</a> *&#160;</td>
          <td class="paramname"><em>root_keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates ER (Encryption Root) and IR (Identity Root) root key values of the device. The local IRK/CSRK/LTK are regenerated as a result of calling this trap. </p>
<p>The root keys comprise IR and ER keys. These are used to generate IRK, CSRK and Legacy LTK. This trap is normally used if a device wants to synchronize its root keys with a device with which it would share a common Bluetooth address. This trap doesn't update the root keys in the persistent store, so the change is not persistent. Note: The application needs to make sure that it should not call this trap when the device is advertising or scanning using a resolvable private address. Moreover, if the device has a pre-existing LE SC (secure connections) pairing with other remote devices and this trap is called then the new ER value will not affect the bonding state for those devices. If the device has a legacy pairing with remote devices, then overwriting the ER value will invalidate the bonding state for those remote devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_keys</td><td>New ER and IR values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if IR and ER values were set successfully, FALSE otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
