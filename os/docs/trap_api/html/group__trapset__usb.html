<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: USB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__usb.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6e9637386569074dcc24321dccc4c284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga6e9637386569074dcc24321dccc4c284">StreamUsbClassSink</a> (UsbInterface interface)</td></tr>
<tr class="memdesc:ga6e9637386569074dcc24321dccc4c284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the USB Class Request Sink.  <a href="#ga6e9637386569074dcc24321dccc4c284">More...</a><br /></td></tr>
<tr class="separator:ga6e9637386569074dcc24321dccc4c284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a5e45d203ce7dbd74c47f4468e696d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga5a5e45d203ce7dbd74c47f4468e696d5">StreamUsbEndPointSink</a> (uint16 end_point)</td></tr>
<tr class="memdesc:ga5a5e45d203ce7dbd74c47f4468e696d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the USB Request Sink associated with the USB transport.  <a href="#ga5a5e45d203ce7dbd74c47f4468e696d5">More...</a><br /></td></tr>
<tr class="separator:ga5a5e45d203ce7dbd74c47f4468e696d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35932b4fcbccef5564c49146827746d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga35932b4fcbccef5564c49146827746d8">StreamUsbVendorSink</a> (void)</td></tr>
<tr class="memdesc:ga35932b4fcbccef5564c49146827746d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the USB Vendor Sink associated with the USB transport.  <a href="#ga35932b4fcbccef5564c49146827746d8">More...</a><br /></td></tr>
<tr class="separator:ga35932b4fcbccef5564c49146827746d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92bfe6572517af08341e7c2b72c236a4"><td class="memItemLeft" align="right" valign="top">UsbAltInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga92bfe6572517af08341e7c2b72c236a4">UsbAddAltInterface</a> (UsbInterface interface, const uint8 *if_descriptor, uint16 descriptor_length)</td></tr>
<tr class="memdesc:ga92bfe6572517af08341e7c2b72c236a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional alternate USB interface. See the USB2.0 spec section 9.6.5 After adding interface with UsbAddInterface, this trap can be used to add additional alternate interfaces.  <a href="#ga92bfe6572517af08341e7c2b72c236a4">More...</a><br /></td></tr>
<tr class="separator:ga92bfe6572517af08341e7c2b72c236a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3638736a761b4611d985645acd119cca"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga3638736a761b4611d985645acd119cca">UsbAddConfiguration</a> (const ConfigDescriptorInfo *desc_info)</td></tr>
<tr class="memdesc:ga3638736a761b4611d985645acd119cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an additional USB configuration. All devices initially have one configuration (with iConfiguration, bmAttributes and bMaxPower in the configuration descriptor being provided by pskeys), and for most devices one configuration is all you want. However, if desired, this function can be used to create additional configurations. It will add a new configuration each time it is called, it can be called repeatedly, but must be called before any interfaces have been added. The support for multiple configurations is limited in that the interfaces/endpoints have to be the same for all configurations, the only values that can be different are the iConfiguration, bmAttributes and bMaxPower fields in the configuration descriptor. For the new configuration, these values are provided by the members of 'desc_info'. Each member of 'desc_info' can be set to the special value SAME_AS_FIRST_CONFIG in which case the corresponding entry in the configuration descriptor for the new configuration will just be copied over from the first configuration.  <a href="#ga3638736a761b4611d985645acd119cca">More...</a><br /></td></tr>
<tr class="separator:ga3638736a761b4611d985645acd119cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2345617bcbc067bcea4e9c1af97e58d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga2345617bcbc067bcea4e9c1af97e58d2">UsbAddDescriptor</a> (UsbInterface interface, uint16 type, const uint8 *descriptor, uint16 descriptor_length)</td></tr>
<tr class="memdesc:ga2345617bcbc067bcea4e9c1af97e58d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a USB descriptor to an interface or endpoint.  <a href="#ga2345617bcbc067bcea4e9c1af97e58d2">More...</a><br /></td></tr>
<tr class="separator:ga2345617bcbc067bcea4e9c1af97e58d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf27dec9d7043ae8af0967d69fbeff7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#gaf27dec9d7043ae8af0967d69fbeff7e8">UsbAddDfuInterface</a> (void)</td></tr>
<tr class="memdesc:gaf27dec9d7043ae8af0967d69fbeff7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a DFU interface to the USB port.  <a href="#gaf27dec9d7043ae8af0967d69fbeff7e8">More...</a><br /></td></tr>
<tr class="separator:gaf27dec9d7043ae8af0967d69fbeff7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad37ce89088882266d0143e82a64b2aec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#gad37ce89088882266d0143e82a64b2aec">UsbAddEndPoints</a> (UsbInterface interface, uint16 num_end_points, const EndPointInfo *end_point_info)</td></tr>
<tr class="memdesc:gad37ce89088882266d0143e82a64b2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds USB endpoints to the interface passed. See the USB2.0 spec section 9.6.6.  <a href="#gad37ce89088882266d0143e82a64b2aec">More...</a><br /></td></tr>
<tr class="separator:gad37ce89088882266d0143e82a64b2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7584677a21af75117d4110f1fbf348e1"><td class="memItemLeft" align="right" valign="top">UsbInterface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga7584677a21af75117d4110f1fbf348e1">UsbAddInterface</a> (const UsbCodes *codes, uint16 type, const uint8 *if_descriptor, uint16 descriptor_length)</td></tr>
<tr class="memdesc:ga7584677a21af75117d4110f1fbf348e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a USB interface. See the USB2.0 spec section 9.6.5 This API is used to register both the USB interface descriptor details and any class specific descriptors to be returned to the host.  <a href="#ga7584677a21af75117d4110f1fbf348e1">More...</a><br /></td></tr>
<tr class="separator:ga7584677a21af75117d4110f1fbf348e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4830212525db574ad5a789e4c72460b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga4830212525db574ad5a789e4c72460b5">UsbAddInterfaceAssociationDescriptor</a> (uint16 if_num, const uint8 *ia_descriptor, uint16 descriptor_length)</td></tr>
<tr class="memdesc:ga4830212525db574ad5a789e4c72460b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an Interface Association Descriptor to a USB interface.  <a href="#ga4830212525db574ad5a789e4c72460b5">More...</a><br /></td></tr>
<tr class="separator:ga4830212525db574ad5a789e4c72460b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9209a0a8146c2354dcd71b66e65057f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga9209a0a8146c2354dcd71b66e65057f9">UsbAddStringDescriptor</a> (uint8 string_index, const uint16 *string_descriptor)</td></tr>
<tr class="memdesc:ga9209a0a8146c2354dcd71b66e65057f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a USB String Descriptor. See the USB2.0 spec section 9.6.7 The string_descriptor passed is in UTF16 format and MUST be NUL terminated. The NUL terminator will not be passed to USB host as part of the string descriptor when a string descriptor request is received, it is simply to denote the end of the string. Example: In order to register string descriptor 11 as "Test". UsbAddStringDescriptor(11, myStringDescriptor);.  <a href="#ga9209a0a8146c2354dcd71b66e65057f9">More...</a><br /></td></tr>
<tr class="separator:ga9209a0a8146c2354dcd71b66e65057f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac39dbcb0154b54652135a787ce8f41"><td class="memItemLeft" align="right" valign="top">usb_attached_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#gafac39dbcb0154b54652135a787ce8f41">UsbAttachedStatus</a> (void)</td></tr>
<tr class="memdesc:gafac39dbcb0154b54652135a787ce8f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control of USB EndPoints, and other USB related traps.  <a href="#gafac39dbcb0154b54652135a787ce8f41">More...</a><br /></td></tr>
<tr class="separator:gafac39dbcb0154b54652135a787ce8f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa166a47be621b208d806252f69f10066"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#gaa166a47be621b208d806252f69f10066">UsbDebugAllow</a> (bool flag)</td></tr>
<tr class="memdesc:gaa166a47be621b208d806252f69f10066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow or Disallow USB debugging This trap can be used to allow or disallow USB debug (still needing challenge-response), but only under the following conditions:  <a href="#gaa166a47be621b208d806252f69f10066">More...</a><br /></td></tr>
<tr class="separator:gaa166a47be621b208d806252f69f10066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8544c1cf28ee309fd220980f483a75"><td class="memItemLeft" align="right" valign="top">usb_device_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__usb.html#ga0e8544c1cf28ee309fd220980f483a75">UsbDeviceState</a> (void)</td></tr>
<tr class="memdesc:ga0e8544c1cf28ee309fd220980f483a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the state of the USB device Returns state of USB device implemented by the application.  <a href="#ga0e8544c1cf28ee309fd220980f483a75">More...</a><br /></td></tr>
<tr class="separator:ga0e8544c1cf28ee309fd220980f483a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6e9637386569074dcc24321dccc4c284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9637386569074dcc24321dccc4c284">&#9670;&nbsp;</a></span>StreamUsbClassSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamUsbClassSink </td>
          <td>(</td>
          <td class="paramtype">UsbInterface&#160;</td>
          <td class="paramname"><em>interface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the USB Class Request Sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The USB interface (returned by UsbAddInterface) to fetch the Sink for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a5e45d203ce7dbd74c47f4468e696d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a5e45d203ce7dbd74c47f4468e696d5">&#9670;&nbsp;</a></span>StreamUsbEndPointSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamUsbEndPointSink </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>end_point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the USB Request Sink associated with the USB transport. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_point</td><td>The USB endpoint (bEndPointAddress field in EndPointInfo structure) to fetch the Sink for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35932b4fcbccef5564c49146827746d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35932b4fcbccef5564c49146827746d8">&#9670;&nbsp;</a></span>StreamUsbVendorSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamUsbVendorSink </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the USB Vendor Sink associated with the USB transport. </p>

</div>
</div>
<a id="ga92bfe6572517af08341e7c2b72c236a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92bfe6572517af08341e7c2b72c236a4">&#9670;&nbsp;</a></span>UsbAddAltInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UsbAltInterface UsbAddAltInterface </td>
          <td>(</td>
          <td class="paramtype">UsbInterface&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>if_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>descriptor_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds additional alternate USB interface. See the USB2.0 spec section 9.6.5 After adding interface with UsbAddInterface, this trap can be used to add additional alternate interfaces. </p>
<p>The original UsbAddInterface call creates bAlternateSetting=0 without endpoints. If any isochronous endpoints have been then added with <a class="el" href="group__trapset__usb.html#gad37ce89088882266d0143e82a64b2aec" title="Adds USB endpoints to the interface passed. See the USB2.0 spec section 9.6.6. ">UsbAddEndPoints()</a> this creates another alternate interface bAlternateSetting=1 which contains all the endpoints and class interface descriptors.</p>
<p>Any additional alternate interfaces can be added with UsbAddAltInterface and get consecutive bAlternateSetting indices. UsbAddEndPoints and UsbAddDescriptor can be then used to fill it with endpoints and class endpoint descriptors.</p>
<p>Endpoints and endpoint class descriptors are always associate with the last alternate interface, therefore alternate interfaces are configured one by one with UsbAddEndPoints and UsbAddDescriptor calls following corresponding UsbAddAltInterface calls.</p>
<p>Additional alternate interfaces can have different class descriptors and endpoint parameters except the following limitation: all alternate interfaces with non-zero number of endpoints have the same number of endpoints and corresponding endpoints have the same bEndpointAddress and bmAttributes. This effectively forbids creating alternate interfaces with different sets of endpoints, while still allowing zero-bandwidth alternate interfaces without endpoints. </p><pre class="fragment">   GET_DESCRIPTOR request directed to USB interface to request class
   descriptor will be matched against all descriptors added with
   UsbAddDescriptor() and also against the "type" specified in the 
   UsbAddInterface() call. If the latter matches, then class descriptors of
   the currently active alternate interface will be returned.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The interface to add alternate interface to (returned by a call to <a class="el" href="group__trapset__usb.html#ga7584677a21af75117d4110f1fbf348e1" title="Adds a USB interface. See the USB2.0 spec section 9.6.5 This API is used to register both the USB int...">UsbAddInterface()</a>). </td></tr>
    <tr><td class="paramname">if_descriptor</td><td>Points to the class specific descriptor. </td></tr>
    <tr><td class="paramname">descriptor_length</td><td>The length in bytes of if_descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Assigned bAlternateSetting on success, else returns usb_alt_interface_error. Possible reasons for the error include insufficient pmalloc space for new firmware data structures or USB device is already attached to the hub. </dd></dl>

</div>
</div>
<a id="ga3638736a761b4611d985645acd119cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3638736a761b4611d985645acd119cca">&#9670;&nbsp;</a></span>UsbAddConfiguration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 UsbAddConfiguration </td>
          <td>(</td>
          <td class="paramtype">const ConfigDescriptorInfo *&#160;</td>
          <td class="paramname"><em>desc_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an additional USB configuration. All devices initially have one configuration (with iConfiguration, bmAttributes and bMaxPower in the configuration descriptor being provided by pskeys), and for most devices one configuration is all you want. However, if desired, this function can be used to create additional configurations. It will add a new configuration each time it is called, it can be called repeatedly, but must be called before any interfaces have been added. The support for multiple configurations is limited in that the interfaces/endpoints have to be the same for all configurations, the only values that can be different are the iConfiguration, bmAttributes and bMaxPower fields in the configuration descriptor. For the new configuration, these values are provided by the members of 'desc_info'. Each member of 'desc_info' can be set to the special value SAME_AS_FIRST_CONFIG in which case the corresponding entry in the configuration descriptor for the new configuration will just be copied over from the first configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desc_info</td><td>Points to info for the new configuration descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, returns a value corresponding to the bConfigurationValue of the new configuration. This will start at 2 for the first extra configuration created. On error, returns zero. Possible reasons for an error include calling the function after interfaces have been added, insufficient pmalloc space for new firmware data structures, device is already attached with UsbHubAttach. </dd></dl>

</div>
</div>
<a id="ga2345617bcbc067bcea4e9c1af97e58d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2345617bcbc067bcea4e9c1af97e58d2">&#9670;&nbsp;</a></span>UsbAddDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UsbAddDescriptor </td>
          <td>(</td>
          <td class="paramtype">UsbInterface&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>descriptor_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a USB descriptor to an interface or endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The interface to add the descriptor to. </td></tr>
    <tr><td class="paramname">type</td><td>Descriptor type (lower 8 bits). </td></tr>
    <tr><td class="paramname">descriptor</td><td>Pointer to the descriptor to add. </td></tr>
    <tr><td class="paramname">descriptor_length</td><td>The length of the descriptor in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the descriptor was successfully added, else FALSE. Descriptor type for a class specific endpoint descriptor will contain the address of the endpoint in the upper 8 bits. The upper 8 bits should be 0 otherwise. This API is normally used to add HID report or class specific endpoint descriptors. </dd></dl>

</div>
</div>
<a id="gaf27dec9d7043ae8af0967d69fbeff7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf27dec9d7043ae8af0967d69fbeff7e8">&#9670;&nbsp;</a></span>UsbAddDfuInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsbAddDfuInterface </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a DFU interface to the USB port. </p>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="gad37ce89088882266d0143e82a64b2aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad37ce89088882266d0143e82a64b2aec">&#9670;&nbsp;</a></span>UsbAddEndPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UsbAddEndPoints </td>
          <td>(</td>
          <td class="paramtype">UsbInterface&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>num_end_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndPointInfo *&#160;</td>
          <td class="paramname"><em>end_point_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds USB endpoints to the interface passed. See the USB2.0 spec section 9.6.6. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface</td><td>The interface to add endpoints to (returned by a call to <a class="el" href="group__trapset__usb.html#ga7584677a21af75117d4110f1fbf348e1" title="Adds a USB interface. See the USB2.0 spec section 9.6.5 This API is used to register both the USB int...">UsbAddInterface()</a>). </td></tr>
    <tr><td class="paramname">num_end_points</td><td>The number of endpoints to be added. </td></tr>
    <tr><td class="paramname">end_point_info</td><td>Points to an array of endpoint definitions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the endpoints were successfully added, else FALSE. Possible reasons for a FALSE return value include an invalid "interface" parameter, insufficient pmalloc space for new firmware data structures, BlueCore is already enumerated on the bus, PSKEY_HOST_INTERFACE is not set to USB or PSKEY_USB_VM_CONTROL is FALSE. </dd></dl>

</div>
</div>
<a id="ga7584677a21af75117d4110f1fbf348e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7584677a21af75117d4110f1fbf348e1">&#9670;&nbsp;</a></span>UsbAddInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UsbInterface UsbAddInterface </td>
          <td>(</td>
          <td class="paramtype">const UsbCodes *&#160;</td>
          <td class="paramname"><em>codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>if_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>descriptor_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a USB interface. See the USB2.0 spec section 9.6.5 This API is used to register both the USB interface descriptor details and any class specific descriptors to be returned to the host. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codes</td><td>Defines the USB class, sub-class and protocol. </td></tr>
    <tr><td class="paramname">type</td><td>Defines the class specific descriptor type. </td></tr>
    <tr><td class="paramname">if_descriptor</td><td>Points to the class specific descriptor. </td></tr>
    <tr><td class="paramname">descriptor_length</td><td>The length in bytes of if_descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An interface number on success, else returns usb_interface_error. Possible reasons for usb_interface_error include insufficient pmalloc space for new firmware data structures or device already attached to internal hub with <a class="el" href="group__trapset__usb__hub.html#ga1a96f2f0b88006874449e7cc94036bc0" title="Control of internal USB hub. ">UsbHubAttach()</a>. </dd></dl>

</div>
</div>
<a id="ga4830212525db574ad5a789e4c72460b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4830212525db574ad5a789e4c72460b5">&#9670;&nbsp;</a></span>UsbAddInterfaceAssociationDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UsbAddInterfaceAssociationDescriptor </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>if_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>ia_descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>descriptor_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an Interface Association Descriptor to a USB interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">if_num</td><td>The interface number returned by a call to <a class="el" href="group__trapset__usb.html#ga7584677a21af75117d4110f1fbf348e1" title="Adds a USB interface. See the USB2.0 spec section 9.6.5 This API is used to register both the USB int...">UsbAddInterface()</a> </td></tr>
    <tr><td class="paramname">ia_descriptor</td><td>A pointer to the Interface Association descriptor in VM address space </td></tr>
    <tr><td class="paramname">descriptor_length</td><td>The length of the Interface Association descriptor pointed to by ia_descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the Interface Association descriptor was added correctly, else FALSE. A FALSE value will be returned if an invalid if_num is given. </dd></dl>

</div>
</div>
<a id="ga9209a0a8146c2354dcd71b66e65057f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9209a0a8146c2354dcd71b66e65057f9">&#9670;&nbsp;</a></span>UsbAddStringDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UsbAddStringDescriptor </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>string_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>string_descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a USB String Descriptor. See the USB2.0 spec section 9.6.7 The string_descriptor passed is in UTF16 format and MUST be NUL terminated. The NUL terminator will not be passed to USB host as part of the string descriptor when a string descriptor request is received, it is simply to denote the end of the string. Example: In order to register string descriptor 11 as "Test". UsbAddStringDescriptor(11, myStringDescriptor);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string_index</td><td>The USB String Descriptor number. Only index in the range 5 to 255 can be used as 1 to 4 are reserved. </td></tr>
    <tr><td class="paramname">string_descriptor</td><td>A pointer to the string descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the descriptor was added, else FALSE. A FALSE value will be returned if an invalid string_index parameter is given. </dd></dl>

</div>
</div>
<a id="gafac39dbcb0154b54652135a787ce8f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafac39dbcb0154b54652135a787ce8f41">&#9670;&nbsp;</a></span>UsbAttachedStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_attached_status UsbAttachedStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control of USB EndPoints, and other USB related traps. </p>
<p>fileBluelab applications have access to the on-chip USB interface. USB devices communications occur through channels known as endpoints. The USB specification defines a number of USB device classes through Class Specifications. Each of the Class Specifications define the type and direction of endpoints required to comply with that particular device class. Examples include the Human Interface Device (HID) class, and the Communication Device Class (CDC).</p>
<p>In addition to the documentation provided here, the USB2.0 specification and the "Bluetooth and USB Design Considerations" document available from www.csrsupport.com are useful sources of information. Determine if USB connection is attached or detached Consult the USB battery charging specification available at www.usb.org for more details on the difference between a dedicated charger and a standard host. Note that BlueCore will only report a correct AttachedStatus if PSKEY_USB_PIO_VBUS is set correctly and either a PIO or the internal battery charger (if available) is connected to the USB VBUS pin. </p><dl class="section return"><dt>Returns</dt><dd>A value to indicate whether the USB connection is currently attached or detached. If USB charger detection is enabled then, if attached, the value returned will give information as to the type of device you are attached to (for example, a standard host/hub or a dedicated charger). </dd></dl>

</div>
</div>
<a id="gaa166a47be621b208d806252f69f10066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa166a47be621b208d806252f69f10066">&#9670;&nbsp;</a></span>UsbDebugAllow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UsbDebugAllow </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow or Disallow USB debugging This trap can be used to allow or disallow USB debug (still needing challenge-response), but only under the following conditions: </p>
<ol type="1">
<li>Efuse 'USB Debug Master Disable' is not set</li>
<li>Efuse 'USB Debug Allow' is not set</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Set TRUE to allow USB debugging, FALSE to disallow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0e8544c1cf28ee309fd220980f483a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e8544c1cf28ee309fd220980f483a75">&#9670;&nbsp;</a></span>UsbDeviceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">usb_device_state UsbDeviceState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the state of the USB device Returns state of USB device implemented by the application. </p>
<p>This is different from the state of internal USB hub and does not represent state of connection to USB host.</p>
<p>For example application can receive MESSAGE_USB_ATTACHED when attached to USB host but USB device state returned by this trap can still report "detached" if USB device is not attached to internal hub with #UsbHubAttach or is not configured at all.</p>
<dl class="section return"><dt>Returns</dt><dd>The current state of the USB device from #usb_device_state </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
