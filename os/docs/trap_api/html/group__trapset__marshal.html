<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: MARSHAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__marshal.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MARSHAL<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeb988955110ea6dcefc823786bbc1f50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gaeb988955110ea6dcefc823786bbc1f50">Marshal</a> (marshaller_t m, void *addr, marshal_type_t type)</td></tr>
<tr class="memdesc:gaeb988955110ea6dcefc823786bbc1f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marshal a object hierarchy. Hierarchies are marshalled piecemeal. The function <code>MarshalProduced</code> may be used to determine how many bytes were written before the marshaller ran out of space. When more space is available in the buffer, the function <code>MarshalSetBuffer</code> should be called to inform the marshaller. <code>Marshal</code> and <code>MarshalSetBuffer</code> should be called repeatedly until the full object hierarchy is marshalled. <code>Marshal</code> should not be called with a new object until marshalling is complete for the current object.  <a href="#gaeb988955110ea6dcefc823786bbc1f50">More...</a><br /></td></tr>
<tr class="separator:gaeb988955110ea6dcefc823786bbc1f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449bf7d803f82cb622ac1a36b5356823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#ga449bf7d803f82cb622ac1a36b5356823">MarshalClearStore</a> (marshaller_t m)</td></tr>
<tr class="memdesc:ga449bf7d803f82cb622ac1a36b5356823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal store of marshalled object references. When marshalling objects, the marshaller stores the address and type of each object it marshals. The index of objects in the store is used by the marshalling protocol as a common reference for objects pointed to by other objects. Clearing the store is useful for reusing marshallers without having to destroy/initialise.  <a href="#ga449bf7d803f82cb622ac1a36b5356823">More...</a><br /></td></tr>
<tr class="separator:ga449bf7d803f82cb622ac1a36b5356823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac363caedfa6ff126c9e9bd003b915a22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gac363caedfa6ff126c9e9bd003b915a22">MarshalDestroy</a> (marshaller_t m, bool free_all_objects)</td></tr>
<tr class="memdesc:gac363caedfa6ff126c9e9bd003b915a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the marshaller.  <a href="#gac363caedfa6ff126c9e9bd003b915a22">More...</a><br /></td></tr>
<tr class="separator:gac363caedfa6ff126c9e9bd003b915a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15770abcc47b425ea71165e78e693eb1"><td class="memItemLeft" align="right" valign="top">marshaller_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#ga15770abcc47b425ea71165e78e693eb1">MarshalInit</a> (const marshal_type_descriptor_t *const *type_desc_list, size_t type_desc_list_elements)</td></tr>
<tr class="memdesc:ga15770abcc47b425ea71165e78e693eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marshal object hierarchies.  <a href="#ga15770abcc47b425ea71165e78e693eb1">More...</a><br /></td></tr>
<tr class="separator:ga15770abcc47b425ea71165e78e693eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace56b71c2344f7308164607ac068bba3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gace56b71c2344f7308164607ac068bba3">MarshalProduced</a> (marshaller_t m)</td></tr>
<tr class="memdesc:gace56b71c2344f7308164607ac068bba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of bytes written since the last re-initialisation.  <a href="#gace56b71c2344f7308164607ac068bba3">More...</a><br /></td></tr>
<tr class="separator:gace56b71c2344f7308164607ac068bba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea60f3f63844a083062cc2bd4349d155"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gaea60f3f63844a083062cc2bd4349d155">MarshalRemaining</a> (marshaller_t m)</td></tr>
<tr class="memdesc:gaea60f3f63844a083062cc2bd4349d155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of bytes that remain to be written to complete marshalling of the current object. This function will return a non-zero value when <code>Marshal</code> returns FALSE (which indicates failure to marshal due to insufficient space in the buffer). This function will return zero when <code>Marshal</code> returns TRUE (there are no remaining bytes to be marshalled).  <a href="#gaea60f3f63844a083062cc2bd4349d155">More...</a><br /></td></tr>
<tr class="separator:gaea60f3f63844a083062cc2bd4349d155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc71fb1490a1e64ad8b5557ea1d0889b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gafc71fb1490a1e64ad8b5557ea1d0889b">MarshalSetBuffer</a> (marshaller_t m, void *buf, size_t space)</td></tr>
<tr class="memdesc:gafc71fb1490a1e64ad8b5557ea1d0889b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the marshaling byte stream buffer and space. Setting the buffer does not clear the store of references to marshalled objects, use <code>MarshalClearStore</code>. This function may be called with a NULL buf and/or zero space. In either case, <code>Marshal</code> will return FALSE (but it will perform the steps necessary to determine the size of the byte stream that will be produced by marshalling the object, allowing <code>MarshalRemaining</code> to be called). For <code>Marshal</code> to return TRUE, this function must be called after <code>MarshalInit</code> before calling <code>Marshal</code> with a valid address and space.  <a href="#gafc71fb1490a1e64ad8b5557ea1d0889b">More...</a><br /></td></tr>
<tr class="separator:gafc71fb1490a1e64ad8b5557ea1d0889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7848547be0db7082aa6f4a567eb6c54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gaf7848547be0db7082aa6f4a567eb6c54">Unmarshal</a> (unmarshaller_t u, void **addr, marshal_type_t *type)</td></tr>
<tr class="memdesc:gaf7848547be0db7082aa6f4a567eb6c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmarshal a object hierarchy. Hierarchies are unmarshalled piecemeal. The function <code>UnmarshalConsumed</code> may be used to determine how many bytes were read before the unmarshaller ran out of data. When more data is available in the buffer, the function <code>UnmarshalSetBuffer</code> should be called to inform the unmarshaller. <code>Unmarshal</code> and <code>UnmarshalSetBuffer</code> should be called repeatedly until the full object hierarchy is unmarshalled.  <a href="#gaf7848547be0db7082aa6f4a567eb6c54">More...</a><br /></td></tr>
<tr class="separator:gaf7848547be0db7082aa6f4a567eb6c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabc5ab70b1c8825d33b3742c349540d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gaabc5ab70b1c8825d33b3742c349540d3">UnmarshalClearStore</a> (unmarshaller_t u)</td></tr>
<tr class="memdesc:gaabc5ab70b1c8825d33b3742c349540d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the internal store of marshalled object references. When unmarshalling objects, the unmarshaller stores the address and type of each object it unmarshals. The index of objects in the store is used by the marshalling protocol as a common reference for objects pointed to by other objects. Clearing the store is useful for reusing unmarshallers without having to destroy/initialise.  <a href="#gaabc5ab70b1c8825d33b3742c349540d3">More...</a><br /></td></tr>
<tr class="separator:gaabc5ab70b1c8825d33b3742c349540d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda79677e33869c21043c075bb062f52"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#gafda79677e33869c21043c075bb062f52">UnmarshalConsumed</a> (unmarshaller_t u)</td></tr>
<tr class="memdesc:gafda79677e33869c21043c075bb062f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the number of bytes read since the last re-initialisation.  <a href="#gafda79677e33869c21043c075bb062f52">More...</a><br /></td></tr>
<tr class="separator:gafda79677e33869c21043c075bb062f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677e276c3f377df37e08c31c68d97332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#ga677e276c3f377df37e08c31c68d97332">UnmarshalDestroy</a> (unmarshaller_t u, bool free_all_objects)</td></tr>
<tr class="memdesc:ga677e276c3f377df37e08c31c68d97332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the unmarshaller.  <a href="#ga677e276c3f377df37e08c31c68d97332">More...</a><br /></td></tr>
<tr class="separator:ga677e276c3f377df37e08c31c68d97332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a1cc1c88cbf70613f93a6c6b51a8c5d"><td class="memItemLeft" align="right" valign="top">unmarshaller_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#ga3a1cc1c88cbf70613f93a6c6b51a8c5d">UnmarshalInit</a> (const marshal_type_descriptor_t *const *type_desc_list, size_t type_desc_list_elements)</td></tr>
<tr class="memdesc:ga3a1cc1c88cbf70613f93a6c6b51a8c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and initialise a unmarshaller. The elements in the type_descriptor_list should not exceed MARSHAL_TYPES_MAX. The type_descriptor_list used on marshaller and unmarshaller <em>must</em> match for marshalling / unmarshalling to complete successfully.  <a href="#ga3a1cc1c88cbf70613f93a6c6b51a8c5d">More...</a><br /></td></tr>
<tr class="separator:ga3a1cc1c88cbf70613f93a6c6b51a8c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cd1543695b6387920eae9da089ce9a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__marshal.html#ga8cd1543695b6387920eae9da089ce9a9">UnmarshalSetBuffer</a> (unmarshaller_t u, const void *buf, size_t data_bytes)</td></tr>
<tr class="memdesc:ga8cd1543695b6387920eae9da089ce9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the unmarshaling byte stream buffer and data size. Setting the buffer does not clear the store of references to unmarshalled objects, use <code>UnmarshalClearStore</code>. This function must be called after <code>UnmarshalInit</code> before calling <code>Unmarshal</code>.  <a href="#ga8cd1543695b6387920eae9da089ce9a9">More...</a><br /></td></tr>
<tr class="separator:ga8cd1543695b6387920eae9da089ce9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaeb988955110ea6dcefc823786bbc1f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb988955110ea6dcefc823786bbc1f50">&#9670;&nbsp;</a></span>Marshal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Marshal </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marshal_type_t&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marshal a object hierarchy. Hierarchies are marshalled piecemeal. The function <code>MarshalProduced</code> may be used to determine how many bytes were written before the marshaller ran out of space. When more space is available in the buffer, the function <code>MarshalSetBuffer</code> should be called to inform the marshaller. <code>Marshal</code> and <code>MarshalSetBuffer</code> should be called repeatedly until the full object hierarchy is marshalled. <code>Marshal</code> should not be called with a new object until marshalling is complete for the current object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
    <tr><td class="paramname">addr</td><td>The address of the head object in the hierarchy. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the head object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the full object hierarchy was marshalled. FALSE if there was not enough space in the buffer to fully marshal the object hierarchy. </dd></dl>

</div>
</div>
<a id="ga449bf7d803f82cb622ac1a36b5356823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449bf7d803f82cb622ac1a36b5356823">&#9670;&nbsp;</a></span>MarshalClearStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MarshalClearStore </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the internal store of marshalled object references. When marshalling objects, the marshaller stores the address and type of each object it marshals. The index of objects in the store is used by the marshalling protocol as a common reference for objects pointed to by other objects. Clearing the store is useful for reusing marshallers without having to destroy/initialise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac363caedfa6ff126c9e9bd003b915a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac363caedfa6ff126c9e9bd003b915a22">&#9670;&nbsp;</a></span>MarshalDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MarshalDestroy </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_all_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the marshaller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
    <tr><td class="paramname">free_all_objects</td><td>If TRUE, all objects that have been marshaled will also be freed. If FALSE, only the internal state will be freed and the caller is responsible for freeing the marshalled objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15770abcc47b425ea71165e78e693eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15770abcc47b425ea71165e78e693eb1">&#9670;&nbsp;</a></span>MarshalInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">marshaller_t MarshalInit </td>
          <td>(</td>
          <td class="paramtype">const marshal_type_descriptor_t *const *&#160;</td>
          <td class="paramname"><em>type_desc_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>type_desc_list_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marshal object hierarchies. </p>
<p>file </p><h1>Introduction </h1>
<p>Marshalling is the process converting a C object hierarchy (comprising structs, unions, arrays, primitive types, pointers) to a formatted stream of bytes.</p>
<p>Unmarshalling is the process of converting the formatted stream of bytes back to a C object hierarchy.</p>
<p>This process may also known by the terms pickle, serialise, flatten etc.</p>
<h1>Terminology </h1>
<p>In the marshalling module the following terminology is used:</p>
<h2>Object </h2>
<ul>
<li>An object is a C variable instance.</li>
<li>An object is not a member of another object (see shared member).</li>
<li>An object is not a pointer.</li>
<li>An object has an address and a type.</li>
</ul>
<h2>Member </h2>
<ul>
<li>A member is a member of a C struct or union type.</li>
<li>A member has a type.</li>
<li>A member has an offset in the parent struct/union (obtained using the offsetof macro).</li>
<li>Only one member of a union type instance may be active.</li>
</ul>
<p>For example, a, b, c, d are members of the struct alpha with type uint32. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>alpha</div><div class="line">{</div><div class="line">    uint32 a;</div><div class="line">    uint32 b;</div><div class="line">    uint32 c;</div><div class="line">    uint32 d;</div><div class="line">};</div></div><!-- fragment --><h2>Shared Member </h2>
<ul>
<li>A shared member is a member.</li>
<li>A shared member's address is exposed/shared by the shared member's parent such that another object's member may point to the shared member.</li>
</ul>
<p>For example if the address of struct alpha.a was exposed, struct pointers.p's value could be the address of struct alpha.a (or any other uint32). </p><div class="fragment"><div class="line"><span class="keyword">struct </span>pointers</div><div class="line">{</div><div class="line">    uint32 *p;</div><div class="line">};</div></div><!-- fragment --><p> Shared members are marshaled once by the parent object, not the object with a pointer member that refers to the shared member.</p>
<h2>Hierarchy </h2>
<p>The struct hierarchy has members that themselves have members, which forms a hierarchy. When marshalling hierarchy, all members of the hierarchy must be marshaled. </p><div class="fragment"><div class="line"><span class="keyword">struct </span>hierarchy</div><div class="line">{</div><div class="line">    <span class="keyword">struct </span>alpha alp;</div><div class="line">    <span class="keyword">struct </span>pointers ptr;</div><div class="line">};</div></div><!-- fragment --><h1>Supported </h1>
<ul>
<li>Primitive types</li>
<li>Struct types</li>
<li>Union types (including dynamic length structs containing a tagged union)</li>
<li>Pointer members (including share objects and recursive objects)</li>
<li>Arrays (including structs containing dynamic length arrays)</li>
</ul>
<h1>Not Supported </h1>
<ul>
<li>Bitfields The module uses the offsetof macro to determine the byte offset of object members. Since it is not possible to determine the offset of a bitfield in a structure (since bitfields may start at non-byte boundaries), it is not possible to marshal structs containing bitfields. A work-around is to wrap the bitfield in a sub-struct - the offsetof the sub-struct is determinable.</li>
<li>Pointers to pointers Not supported in this version.</li>
<li>Constants</li>
<li>Globals A object with global scope may be marshalled, but the marshalling module does not support unmarshalling that object to the equivalent global object on the unmarshaller. Instead, the unmarshaller will dynamically allocate memory for the object.</li>
</ul>
<h1>Type Descriptors </h1>
<p>The marshal module has no way of knowing the format/properties of types the user of the module wishes to marshal. Therefore the format/properties of all types must be described in a generic way the marshal module can use at runtime.</p>
<p>The marshalling module is initialised with an array of <code>marshal_type_descriptor_t</code>. The type descriptors describe the type's size, its members and provides a number of callbacks where dynamic information about an instance of a type is obtained. If a type has members (i.e. a struct) these are described in an array of <code>marshal_member_descriptor_t</code>. Each member has an byte offset in the structure, a type, and various other properties (pointer, array etc). Since a type's members may also have members, a hierarchy may be formed. The marshal module uses the type descriptors to traverse the hierarchy of objects and marshal all objects. To correctly reconstruct the object hierarchy from the marshalled byte stream, the unmarshaller must have an identical description of the types.</p>
<h1>Example Usage </h1>
<div class="fragment"><div class="line"><span class="comment">// Type descriptor for basic uint8 type</span></div><div class="line"><span class="keyword">const</span> marshal_type_descriptor_t marshal_type_descriptor_uint8 =</div><div class="line">    MAKE_MARSHAL_TYPE_DEFINITION_BASIC(uint8);</div><div class="line"></div><div class="line"><span class="comment">// Enumerate ids for each type that will be marshalled.</span></div><div class="line"><span class="keyword">enum</span> MARSHAL_TYPES</div><div class="line">{</div><div class="line">    MARSHAL_TYPE(uint8),</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    NUMBER_OF_MARSHAL_OBJECT_TYPES</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Array of pointers to type descriptors - must be in the same order as the enum</span></div><div class="line"><span class="keyword">const</span> marshal_type_descriptor_t * <span class="keyword">const</span> marshal_type_descriptors[NUMBER_OF_MARSHAL_OBJECT_TYPES] =</div><div class="line">{</div><div class="line">    &amp;marshal_type_descriptor_uint8,</div><div class="line">    <span class="comment">// ...</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Function illustrating marshalling a uint8 to a buffer, returning number of bytes written.</span></div><div class="line"><span class="keywordtype">size_t</span> marshal_uint8(uint8 *u8p, uint8 *buf, <span class="keywordtype">size_t</span> buf_len)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span> produced;</div><div class="line">    marshaller_t m;</div><div class="line"></div><div class="line">    m = <a class="code" href="group__trapset__marshal.html#ga15770abcc47b425ea71165e78e693eb1">MarshalInit</a>(marshal_type_descriptors, ARRAY_DIM(marshal_type_descriptors));</div><div class="line">    <a class="code" href="group__trapset__marshal.html#gafc71fb1490a1e64ad8b5557ea1d0889b">MarshalSetBuffer</a>(m, buf, buf_len);</div><div class="line">    <a class="code" href="group__trapset__marshal.html#gaeb988955110ea6dcefc823786bbc1f50">Marshal</a>(m, (<span class="keywordtype">void</span>*)u8p, MARSHAL_TYPE(uint8));</div><div class="line">    produced = <a class="code" href="group__trapset__marshal.html#gace56b71c2344f7308164607ac068bba3">MarshalProduced</a>(m);</div><div class="line">    <a class="code" href="group__trapset__marshal.html#gac363caedfa6ff126c9e9bd003b915a22">MarshalDestroy</a>(m, FALSE);</div><div class="line">    <span class="keywordflow">return</span> produced;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Function illustrating unmarshalling</span></div><div class="line"><span class="keywordtype">size_t</span> do_unmarshal(<span class="keyword">const</span> uint8 *buf, <span class="keywordtype">size_t</span> buf_len)</div><div class="line">{</div><div class="line">    <span class="keywordtype">size_t</span> consumed;</div><div class="line">    <span class="keywordtype">void</span> *object;</div><div class="line">    marshal_type_t type;</div><div class="line">    unmarshaller_t u;</div><div class="line"></div><div class="line">    u = UnmarshaInit(marshal_type_descriptors, ARRAY_DIM(marshal_type_descriptors));</div><div class="line">    <a class="code" href="group__trapset__marshal.html#ga8cd1543695b6387920eae9da089ce9a9">UnmarshalSetBuffer</a>(u, buf, buf_len);</div><div class="line">    <a class="code" href="group__trapset__marshal.html#gaf7848547be0db7082aa6f4a567eb6c54">Unmarshal</a>(u, &amp;<span class="keywordtype">object</span>, &amp;type);</div><div class="line">    <span class="comment">// do something with the unmarshalled object (given its type)</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">    free(<span class="keywordtype">object</span>);</div><div class="line">    consumed = <a class="code" href="group__trapset__marshal.html#gafda79677e33869c21043c075bb062f52">UnmarshalConsumed</a>(u);</div><div class="line">    <a class="code" href="group__trapset__marshal.html#ga677e276c3f377df37e08c31c68d97332">UnmarshalDestroy</a>(u, FALSE);</div><div class="line">    <span class="keywordflow">return</span> consumed;</div><div class="line">}</div></div><!-- fragment --><p> Create and initialise a marshaller. The elements in the type_descriptor_list should not exceed MARSHAL_TYPES_MAX. The type_descriptor_list used on marshaller and unmarshaller <em>must</em> match for marshalling / unmarshalling to complete successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_desc_list</td><td>A list of marshal type descriptors. </td></tr>
    <tr><td class="paramname">type_desc_list_elements</td><td>The number of types in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to an initialised marshaller, or NULL if initialisation failed. </dd></dl>

</div>
</div>
<a id="gace56b71c2344f7308164607ac068bba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace56b71c2344f7308164607ac068bba3">&#9670;&nbsp;</a></span>MarshalProduced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MarshalProduced </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of bytes written since the last re-initialisation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of marshal bytes written to the buffer. </dd></dl>

</div>
</div>
<a id="gaea60f3f63844a083062cc2bd4349d155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea60f3f63844a083062cc2bd4349d155">&#9670;&nbsp;</a></span>MarshalRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t MarshalRemaining </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of bytes that remain to be written to complete marshalling of the current object. This function will return a non-zero value when <code>Marshal</code> returns FALSE (which indicates failure to marshal due to insufficient space in the buffer). This function will return zero when <code>Marshal</code> returns TRUE (there are no remaining bytes to be marshalled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes remaining to be written to the buffer. </dd></dl>

</div>
</div>
<a id="gafc71fb1490a1e64ad8b5557ea1d0889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc71fb1490a1e64ad8b5557ea1d0889b">&#9670;&nbsp;</a></span>MarshalSetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MarshalSetBuffer </td>
          <td>(</td>
          <td class="paramtype">marshaller_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>space</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the marshaling byte stream buffer and space. Setting the buffer does not clear the store of references to marshalled objects, use <code>MarshalClearStore</code>. This function may be called with a NULL buf and/or zero space. In either case, <code>Marshal</code> will return FALSE (but it will perform the steps necessary to determine the size of the byte stream that will be produced by marshalling the object, allowing <code>MarshalRemaining</code> to be called). For <code>Marshal</code> to return TRUE, this function must be called after <code>MarshalInit</code> before calling <code>Marshal</code> with a valid address and space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Handle for the marshaller. </td></tr>
    <tr><td class="paramname">buf</td><td>Address to which the marshaller will write the marshalled byte stream. </td></tr>
    <tr><td class="paramname">space</td><td>The number of bytes space in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf7848547be0db7082aa6f4a567eb6c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7848547be0db7082aa6f4a567eb6c54">&#9670;&nbsp;</a></span>Unmarshal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Unmarshal </td>
          <td>(</td>
          <td class="paramtype">unmarshaller_t&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">marshal_type_t *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmarshal a object hierarchy. Hierarchies are unmarshalled piecemeal. The function <code>UnmarshalConsumed</code> may be used to determine how many bytes were read before the unmarshaller ran out of data. When more data is available in the buffer, the function <code>UnmarshalSetBuffer</code> should be called to inform the unmarshaller. <code>Unmarshal</code> and <code>UnmarshalSetBuffer</code> should be called repeatedly until the full object hierarchy is unmarshalled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Handle for the unmarshaller. </td></tr>
    <tr><td class="paramname">addr</td><td>The function will set addr to the address of the allocated object at the head of the unmarshalled object hierarchy.</td></tr>
    <tr><td class="paramname">type</td><td>The function will set type to the type of the object at the head of the unmarshalled object hierarchy. The type is an index into the type_descriptor_list provided in <code>UnmarshalInit</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the full object hierarchy was unmarshalled. FALSE if there was not enough data in the buffer to fully unmarshal the object hierarchy. </dd></dl>

</div>
</div>
<a id="gaabc5ab70b1c8825d33b3742c349540d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabc5ab70b1c8825d33b3742c349540d3">&#9670;&nbsp;</a></span>UnmarshalClearStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnmarshalClearStore </td>
          <td>(</td>
          <td class="paramtype">unmarshaller_t&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the internal store of marshalled object references. When unmarshalling objects, the unmarshaller stores the address and type of each object it unmarshals. The index of objects in the store is used by the marshalling protocol as a common reference for objects pointed to by other objects. Clearing the store is useful for reusing unmarshallers without having to destroy/initialise. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Handle for the unmarshaller. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafda79677e33869c21043c075bb062f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda79677e33869c21043c075bb062f52">&#9670;&nbsp;</a></span>UnmarshalConsumed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UnmarshalConsumed </td>
          <td>(</td>
          <td class="paramtype">unmarshaller_t&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the number of bytes read since the last re-initialisation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Handle for the marshaller. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of marshal bytes read from the buffer. </dd></dl>

</div>
</div>
<a id="ga677e276c3f377df37e08c31c68d97332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga677e276c3f377df37e08c31c68d97332">&#9670;&nbsp;</a></span>UnmarshalDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnmarshalDestroy </td>
          <td>(</td>
          <td class="paramtype">unmarshaller_t&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_all_objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the unmarshaller. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Handle for the marshaller. </td></tr>
    <tr><td class="paramname">free_all_objects</td><td>If TRUE, all objects that have been unmarshaled will also be freed. If FALSE, only the internal state will be freed and the caller is responsible for freeing the unmarshalled objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a1cc1c88cbf70613f93a6c6b51a8c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a1cc1c88cbf70613f93a6c6b51a8c5d">&#9670;&nbsp;</a></span>UnmarshalInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unmarshaller_t UnmarshalInit </td>
          <td>(</td>
          <td class="paramtype">const marshal_type_descriptor_t *const *&#160;</td>
          <td class="paramname"><em>type_desc_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>type_desc_list_elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create and initialise a unmarshaller. The elements in the type_descriptor_list should not exceed MARSHAL_TYPES_MAX. The type_descriptor_list used on marshaller and unmarshaller <em>must</em> match for marshalling / unmarshalling to complete successfully. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_desc_list</td><td>A list of unmarshal type descriptors. </td></tr>
    <tr><td class="paramname">type_desc_list_elements</td><td>The number of types in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Handle to an initialised unmarshaller, or NULL if initialisation failed. </dd></dl>

</div>
</div>
<a id="ga8cd1543695b6387920eae9da089ce9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd1543695b6387920eae9da089ce9a9">&#9670;&nbsp;</a></span>UnmarshalSetBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UnmarshalSetBuffer </td>
          <td>(</td>
          <td class="paramtype">unmarshaller_t&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the unmarshaling byte stream buffer and data size. Setting the buffer does not clear the store of references to unmarshalled objects, use <code>UnmarshalClearStore</code>. This function must be called after <code>UnmarshalInit</code> before calling <code>Unmarshal</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u</td><td>Handle for the marshaller. </td></tr>
    <tr><td class="paramname">buf</td><td>Address from which the unmarshaller will read the marshalled byte stream. </td></tr>
    <tr><td class="paramname">data_bytes</td><td>The number of data bytes in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
