<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: STREAM</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__stream.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">STREAM<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga715fb92bae5a9c213967a6aca1fbdc07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga715fb92bae5a9c213967a6aca1fbdc07">MessageStreamGetTaskFromSink</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga715fb92bae5a9c213967a6aca1fbdc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Task currently associated with a sink.  <a href="#ga715fb92bae5a9c213967a6aca1fbdc07">More...</a><br /></td></tr>
<tr class="separator:ga715fb92bae5a9c213967a6aca1fbdc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3e6b29387d4d131579530d16965a6ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gad3e6b29387d4d131579530d16965a6ea">MessageStreamGetTaskFromSource</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:gad3e6b29387d4d131579530d16965a6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the task currently associated with a source.  <a href="#gad3e6b29387d4d131579530d16965a6ea">More...</a><br /></td></tr>
<tr class="separator:gad3e6b29387d4d131579530d16965a6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad848ada501da6f2c204729a7fb07ef33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gad848ada501da6f2c204729a7fb07ef33">MessageStreamTaskFromSink</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, <a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:gad848ada501da6f2c204729a7fb07ef33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a Task with a Sink.  <a href="#gad848ada501da6f2c204729a7fb07ef33">More...</a><br /></td></tr>
<tr class="separator:gad848ada501da6f2c204729a7fb07ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad58fed69bc9ad44da333d2d1a37d1aac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gad58fed69bc9ad44da333d2d1a37d1aac">MessageStreamTaskFromSource</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:gad58fed69bc9ad44da333d2d1a37d1aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a task with a source.  <a href="#gad58fed69bc9ad44da333d2d1a37d1aac">More...</a><br /></td></tr>
<tr class="separator:gad58fed69bc9ad44da333d2d1a37d1aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0b400738008b680f601f253403a4a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaca0b400738008b680f601f253403a4a7">SinkAlias</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink1, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink2)</td></tr>
<tr class="memdesc:gaca0b400738008b680f601f253403a4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to alias two Sinks.  <a href="#gaca0b400738008b680f601f253403a4a7">More...</a><br /></td></tr>
<tr class="separator:gaca0b400738008b680f601f253403a4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad33984eda4f93d6b4b3402ddf9ada719"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gad33984eda4f93d6b4b3402ddf9ada719">SinkClaim</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 extra)</td></tr>
<tr class="memdesc:gad33984eda4f93d6b4b3402ddf9ada719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to claim the indicated number of extra bytes in a sink. Claims will certainly fail if the sink is invalid, or if SinkSlack indicates that the space is unavailable. SinkClaim(sink, 0) will return the number of octets that are currently claimed in the sink.  <a href="#gad33984eda4f93d6b4b3402ddf9ada719">More...</a><br /></td></tr>
<tr class="separator:gad33984eda4f93d6b4b3402ddf9ada719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad628d260c93237d0cbba09851743cf8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gad628d260c93237d0cbba09851743cf8a">SinkClose</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:gad628d260c93237d0cbba09851743cf8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call.  <a href="#gad628d260c93237d0cbba09851743cf8a">More...</a><br /></td></tr>
<tr class="separator:gad628d260c93237d0cbba09851743cf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a7b135a6f46872186ae95eba1cc9be3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga5a7b135a6f46872186ae95eba1cc9be3">SinkConfigure</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, stream_config_key key, uint32 value)</td></tr>
<tr class="memdesc:ga5a7b135a6f46872186ae95eba1cc9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a particular sink.  <a href="#ga5a7b135a6f46872186ae95eba1cc9be3">More...</a><br /></td></tr>
<tr class="separator:ga5a7b135a6f46872186ae95eba1cc9be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fcdc75c8a60b0d2edb1e0bf92994a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga4fcdc75c8a60b0d2edb1e0bf92994a03">SinkFlush</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 amount)</td></tr>
<tr class="memdesc:ga4fcdc75c8a60b0d2edb1e0bf92994a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the indicated number of bytes out of the sink. The specified bytes of data are passed to the corresponding byte stream, for example out to the UART, or into BlueStack as if sent by a RFC_DATA_IND for UART/RFCOMM sinks respectively. Pointers previously obtained from SinkMap or SinkMapHeader become invalid after a call to SinkFlush.  <a href="#ga4fcdc75c8a60b0d2edb1e0bf92994a03">More...</a><br /></td></tr>
<tr class="separator:ga4fcdc75c8a60b0d2edb1e0bf92994a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae97fe5b2078952ba408bb27d352c027"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaae97fe5b2078952ba408bb27d352c027">SinkFlushBlocking</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 amount)</td></tr>
<tr class="memdesc:gaae97fe5b2078952ba408bb27d352c027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a blocking flush operation to flush the indicated number of bytes out of the sink and only return once they've left. The specified bytes of data are passed to the corresponding byte stream and the function waits for confirmation that the bytes have been processed before returning. For example an image upgrade sink would pass bytes to the QSPI device to write and wait until the write is complete before returning. Not all stream types support SinkFlushBlocking. If the given stream doesn't support SinkFlushBlocking this function will return FALSE. Pointers previously obtained from SinkMap or SinkMapHeader become invalid after a call to SinkFlushBlocking. This is a blocking version of the SinkFlush function.  <a href="#gaae97fe5b2078952ba408bb27d352c027">More...</a><br /></td></tr>
<tr class="separator:gaae97fe5b2078952ba408bb27d352c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf18e29bb788b113a9de60361479f146"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaaf18e29bb788b113a9de60361479f146">SinkFlushHeader</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, uint16 amount, const void *header, uint16 length)</td></tr>
<tr class="memdesc:gaaf18e29bb788b113a9de60361479f146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the indicated number of bytes out of the sink, with a header. Associates the header with the message. The specified bytes of data are then passed to the corresponding byte stream, for example out to the UART, or into BlueStack as if sent by a RFC_DATA_IND for UART/RFCOMM sinks respectively.  <a href="#gaaf18e29bb788b113a9de60361479f146">More...</a><br /></td></tr>
<tr class="separator:gaaf18e29bb788b113a9de60361479f146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga919f283d937498f8c72427260b04b298"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga919f283d937498f8c72427260b04b298">SinkGetBdAddr</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:ga919f283d937498f8c72427260b04b298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the Bluetooth address from a sink.  <a href="#ga919f283d937498f8c72427260b04b298">More...</a><br /></td></tr>
<tr class="separator:ga919f283d937498f8c72427260b04b298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b57d4faf6a2b73616db3813184567b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga4b57d4faf6a2b73616db3813184567b6">SinkGetRssi</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, int16 *rssi)</td></tr>
<tr class="memdesc:ga4b57d4faf6a2b73616db3813184567b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RSSI for the ACL for a sink.  <a href="#ga4b57d4faf6a2b73616db3813184567b6">More...</a><br /></td></tr>
<tr class="separator:ga4b57d4faf6a2b73616db3813184567b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9058e625d9dc68ac6d073eb974cfb32a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga9058e625d9dc68ac6d073eb974cfb32a">SinkGetWallclock</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, bt_wallclock_info *wallclock)</td></tr>
<tr class="memdesc:ga9058e625d9dc68ac6d073eb974cfb32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Bluetooth wallclock information of ACL link for sink. The wallclock information contains the bluetooth piconet clock counter value <br />
 and system timestamp at which the piconet clock value was updated. BT clock counter ticks in units of 312.5 microseconds (i.e. half a Bluetooth slot) and system timestamp is reported in microseconds. The wallclock information also contains change counter which is incremented on each change in wallclock information due to ACL role switch.  <a href="#ga9058e625d9dc68ac6d073eb974cfb32a">More...</a><br /></td></tr>
<tr class="separator:ga9058e625d9dc68ac6d073eb974cfb32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e87bd2f21892e0df6e00672687b2940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga5e87bd2f21892e0df6e00672687b2940">SinkIsValid</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga5e87bd2f21892e0df6e00672687b2940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a sink is valid, FALSE otherwise.  <a href="#ga5e87bd2f21892e0df6e00672687b2940">More...</a><br /></td></tr>
<tr class="separator:ga5e87bd2f21892e0df6e00672687b2940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90fa999d02ab67d94ff39f657b979a64"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga90fa999d02ab67d94ff39f657b979a64">SinkMap</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga90fa999d02ab67d94ff39f657b979a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the sink into the address map, returning a pointer to the first claimed byte in the sink. Only the total number of claimed bytes (as returned by SinkClaim(sink,0)) are accessible. At most one sink can be mapped in at any time; pointers previously obtained from SinkMap become invalid when another call to SinkMap is made.  <a href="#ga90fa999d02ab67d94ff39f657b979a64">More...</a><br /></td></tr>
<tr class="separator:ga90fa999d02ab67d94ff39f657b979a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c429bd554ae7eb872b8330c75333a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga34c429bd554ae7eb872b8330c75333a3">SinkMapInit</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, stream_device device, uint16 header_len)</td></tr>
<tr class="memdesc:ga34c429bd554ae7eb872b8330c75333a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures operator sink mapping parameters before calling SinkMap. Sink mapping parameters must be configured for an operator sink stream before calling SinkMap. The configuration parameters are #stream_device and header length.  <a href="#ga34c429bd554ae7eb872b8330c75333a3">More...</a><br /></td></tr>
<tr class="separator:ga34c429bd554ae7eb872b8330c75333a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa1e5dbd177b2b6c27b5dfb316ffbe5e"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gafa1e5dbd177b2b6c27b5dfb316ffbe5e">SinkSlack</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:gafa1e5dbd177b2b6c27b5dfb316ffbe5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report how many bytes can successfully be claimed in the corresponding sink.  <a href="#gafa1e5dbd177b2b6c27b5dfb316ffbe5e">More...</a><br /></td></tr>
<tr class="separator:gafa1e5dbd177b2b6c27b5dfb316ffbe5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42bcbadf3d88b1f463f25dfc653c3270"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga42bcbadf3d88b1f463f25dfc653c3270">SinkSynchronise</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink1, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink2)</td></tr>
<tr class="memdesc:ga42bcbadf3d88b1f463f25dfc653c3270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to synchronise two Sinks Call this function to synchronise timing drifts between two sink streams before calling a StreamConnect.  <a href="#ga42bcbadf3d88b1f463f25dfc653c3270">More...</a><br /></td></tr>
<tr class="separator:ga42bcbadf3d88b1f463f25dfc653c3270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bafb62c349ddead71b0bb1312583e4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga2bafb62c349ddead71b0bb1312583e4f">SinkUnmap</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga2bafb62c349ddead71b0bb1312583e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap and reset mapping parameters for an operator sink stream. Unmap and reset mapping parameters for an operator sink stream.  <a href="#ga2bafb62c349ddead71b0bb1312583e4f">More...</a><br /></td></tr>
<tr class="separator:ga2bafb62c349ddead71b0bb1312583e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf671f63da2440f82542e8444cdfb199e"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaf671f63da2440f82542e8444cdfb199e">SourceBoundary</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:gaf671f63da2440f82542e8444cdfb199e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many bytes in this source are before the next packet boundary (for non packet-based sources returns the same as SourceSize.)  <a href="#gaf671f63da2440f82542e8444cdfb199e">More...</a><br /></td></tr>
<tr class="separator:gaf671f63da2440f82542e8444cdfb199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada37e9ae48d1bbd7d4a84f1f3d6da953"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gada37e9ae48d1bbd7d4a84f1f3d6da953">SourceClose</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:gada37e9ae48d1bbd7d4a84f1f3d6da953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to close the source Some sources, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call.  <a href="#gada37e9ae48d1bbd7d4a84f1f3d6da953">More...</a><br /></td></tr>
<tr class="separator:gada37e9ae48d1bbd7d4a84f1f3d6da953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644c1512bb9258138057a0565b387241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga644c1512bb9258138057a0565b387241">SourceConfigure</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, stream_config_key key, uint32 value)</td></tr>
<tr class="memdesc:ga644c1512bb9258138057a0565b387241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a particular source.  <a href="#ga644c1512bb9258138057a0565b387241">More...</a><br /></td></tr>
<tr class="separator:ga644c1512bb9258138057a0565b387241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae56caaf5efeee75f7d7f0cd49f2b7f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f">SourceDrop</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, uint16 amount)</td></tr>
<tr class="memdesc:gae56caaf5efeee75f7d7f0cd49f2b7f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards the indicated number of bytes from the front of the source.  <a href="#gae56caaf5efeee75f7d7f0cd49f2b7f4f">More...</a><br /></td></tr>
<tr class="separator:gae56caaf5efeee75f7d7f0cd49f2b7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0535e0c4822ea8f36c936e77f60df30c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga0535e0c4822ea8f36c936e77f60df30c">SourceIsValid</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga0535e0c4822ea8f36c936e77f60df30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return TRUE if a source is valid, FALSE otherwise.  <a href="#ga0535e0c4822ea8f36c936e77f60df30c">More...</a><br /></td></tr>
<tr class="separator:ga0535e0c4822ea8f36c936e77f60df30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d643b195dfdb398d0c0d2d8ab9d4ec5"><td class="memItemLeft" align="right" valign="top">const uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5">SourceMap</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga6d643b195dfdb398d0c0d2d8ab9d4ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the source into the address map, returning a pointer to the first byte in the source. The number of accessible bytes is as given by <a class="el" href="group__trapset__stream.html#ga08bbe98e69a46c735a44b32d25eda9e9" title="Reports the number of bytes available in the source. ">SourceSize()</a>. At most one source can be mapped in at any time; pointers previously obtained from <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a> become invalid when another call to <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a> is made. Calls to <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> also invalidate previous pointers returned by <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a>. See the <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> documentation for more details.  <a href="#ga6d643b195dfdb398d0c0d2d8ab9d4ec5">More...</a><br /></td></tr>
<tr class="separator:ga6d643b195dfdb398d0c0d2d8ab9d4ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01baa25079f1ed9fa9adb5ce4a0ff715"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715">SourceMapHeader</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga01baa25079f1ed9fa9adb5ce4a0ff715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the first header associated with a source into the address map. The number of accessible words is as given by <a class="el" href="group__trapset__stream.html#ga80c890587108eeff29dcc0d2d81e80ea" title="Reports the number of words available in the first header associated with source. ...">SourceSizeHeader()</a>. At most one header source can be mapped in at any time; pointers previously obtained from <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a> become invalid when another call to <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a> is made. Calls to <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> also invalidate previous pointers returned by <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a>. See the <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> documentation for more details.  <a href="#ga01baa25079f1ed9fa9adb5ce4a0ff715">More...</a><br /></td></tr>
<tr class="separator:ga01baa25079f1ed9fa9adb5ce4a0ff715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b52cdeca100c215205d85bd9735d257"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga4b52cdeca100c215205d85bd9735d257">SourceMapInit</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, stream_device device, uint16 header_len)</td></tr>
<tr class="memdesc:ga4b52cdeca100c215205d85bd9735d257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures operator source mapping parameters before calling SourceMap or SourceMapHeader. Source mapping parameters must be configured for an operator source stream before calling SourceMap or SourceMapHeader. The configuration parameters are #stream_device and header length.  <a href="#ga4b52cdeca100c215205d85bd9735d257">More...</a><br /></td></tr>
<tr class="separator:ga4b52cdeca100c215205d85bd9735d257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08bbe98e69a46c735a44b32d25eda9e9"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga08bbe98e69a46c735a44b32d25eda9e9">SourceSize</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga08bbe98e69a46c735a44b32d25eda9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of bytes available in the source.  <a href="#ga08bbe98e69a46c735a44b32d25eda9e9">More...</a><br /></td></tr>
<tr class="separator:ga08bbe98e69a46c735a44b32d25eda9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80ee91344c8c9e6af1f6fddfc44870c"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaa80ee91344c8c9e6af1f6fddfc44870c">SourceSizeBlocking</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:gaa80ee91344c8c9e6af1f6fddfc44870c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of data bytes available in the source. This is a blocking version of the SourceSize function. It can be used when reading from streams that have bounded transport delays and where the data is known to exist (such as file streams). It can be used as an alternative to having a task waiting for a MESSAGE_MORE_DATA message.  <a href="#gaa80ee91344c8c9e6af1f6fddfc44870c">More...</a><br /></td></tr>
<tr class="separator:gaa80ee91344c8c9e6af1f6fddfc44870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c890587108eeff29dcc0d2d81e80ea"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga80c890587108eeff29dcc0d2d81e80ea">SourceSizeHeader</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga80c890587108eeff29dcc0d2d81e80ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the number of words available in the first header associated with source.  <a href="#ga80c890587108eeff29dcc0d2d81e80ea">More...</a><br /></td></tr>
<tr class="separator:ga80c890587108eeff29dcc0d2d81e80ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c12ae5cd16fe4cd8bfbb000f14f8aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga66c12ae5cd16fe4cd8bfbb000f14f8aa">SourceSynchronise</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source1, <a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source2)</td></tr>
<tr class="memdesc:ga66c12ae5cd16fe4cd8bfbb000f14f8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request to synchronise two Sources Call this function to synchronise timing drifts between two source streams before calling a StreamConnect.  <a href="#ga66c12ae5cd16fe4cd8bfbb000f14f8aa">More...</a><br /></td></tr>
<tr class="separator:ga66c12ae5cd16fe4cd8bfbb000f14f8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99a33d16a9cb121b441169bf7c1114f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaa99a33d16a9cb121b441169bf7c1114f">SourceUnmap</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:gaa99a33d16a9cb121b441169bf7c1114f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmap and reset mapping parameters for an operator source stream. Unmap and reset mapping parameters for an operator source stream.  <a href="#gaa99a33d16a9cb121b441169bf7c1114f">More...</a><br /></td></tr>
<tr class="separator:gaa99a33d16a9cb121b441169bf7c1114f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3adcc0a6c3530f416ee0ec81735709d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga3adcc0a6c3530f416ee0ec81735709d0">StreamConfigure</a> (vm_stream_config_key key, uint16 value)</td></tr>
<tr class="memdesc:ga3adcc0a6c3530f416ee0ec81735709d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the stream subsystem.  <a href="#ga3adcc0a6c3530f416ee0ec81735709d0">More...</a><br /></td></tr>
<tr class="separator:ga3adcc0a6c3530f416ee0ec81735709d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd351636d2d317e6bd2f4c5f76968d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4">StreamConnect</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga4cd351636d2d317e6bd2f4c5f76968d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an automatic connection between a source and sink.  <a href="#ga4cd351636d2d317e6bd2f4c5f76968d4">More...</a><br /></td></tr>
<tr class="separator:ga4cd351636d2d317e6bd2f4c5f76968d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98cf0d2993eab82215bda2d157baef9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga98cf0d2993eab82215bda2d157baef9a">StreamConnectDispose</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga98cf0d2993eab82215bda2d157baef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispose of all data arriving on the specified source by throwing it away.  <a href="#ga98cf0d2993eab82215bda2d157baef9a">More...</a><br /></td></tr>
<tr class="separator:ga98cf0d2993eab82215bda2d157baef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga527bafa672552787830a9444e2058fa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga527bafa672552787830a9444e2058fa9">StreamDisconnect</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga527bafa672552787830a9444e2058fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Break any existing automatic connection involving the source <em>or</em> sink. Source or sink may be zero.  <a href="#ga527bafa672552787830a9444e2058fa9">More...</a><br /></td></tr>
<tr class="separator:ga527bafa672552787830a9444e2058fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1afd52a99980f3dba6eeef6d26b57e"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga2a1afd52a99980f3dba6eeef6d26b57e">StreamMove</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink, <a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, uint16 count)</td></tr>
<tr class="memdesc:ga2a1afd52a99980f3dba6eeef6d26b57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the specified number of bytes from the start of 'source' to the end of 'sink'. The count must be no more than both <a class="el" href="group__trapset__stream.html#gafa1e5dbd177b2b6c27b5dfb316ffbe5e" title="Report how many bytes can successfully be claimed in the corresponding sink. ">SinkSlack()</a> and <a class="el" href="group__trapset__stream.html#gaf671f63da2440f82542e8444cdfb199e" title="Return how many bytes in this source are before the next packet boundary (for non packet-based source...">SourceBoundary()</a>.  <a href="#ga2a1afd52a99980f3dba6eeef6d26b57e">More...</a><br /></td></tr>
<tr class="separator:ga2a1afd52a99980f3dba6eeef6d26b57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84a961372615e789539511b6938be5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaf84a961372615e789539511b6938be5a">StreamPipePair</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *sink_a, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *sink_b, uint16 size_a_to_b, uint16 size_b_to_a)</td></tr>
<tr class="memdesc:gaf84a961372615e789539511b6938be5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a bi-directional Pipe Stream.  <a href="#gaf84a961372615e789539511b6938be5a">More...</a><br /></td></tr>
<tr class="separator:gaf84a961372615e789539511b6938be5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91264b8a2400ddabd6009f3ae4958ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga91264b8a2400ddabd6009f3ae4958ba4">StreamRegionSource</a> (const uint8 *data, uint16 length)</td></tr>
<tr class="memdesc:ga91264b8a2400ddabd6009f3ae4958ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a source from a region of memory. This function allows a region of memory to be treated as a source. This is useful when there is a requirement to handle data (held in a known region of memory) using functions that expect a source, e.g. <a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4" title="Make an automatic connection between a source and sink. ">StreamConnect()</a>, in order to efficiently transfer the data without having to copy it. It is important that the memory being treated as a source persists long enough for the stream operation to complete, i.e., long enough for the source to be read. The source created using this function only exists while the data is being read. However, the memory block being treated as a source is not freed by the stream subsystem once the data has been read. It remains the caller's responsibility to manage the memory and free it when it is appropriate to do so. If length is zero then 0 is returned.  <a href="#ga91264b8a2400ddabd6009f3ae4958ba4">More...</a><br /></td></tr>
<tr class="separator:ga91264b8a2400ddabd6009f3ae4958ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96774ac3651729785b7613da0252b143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga96774ac3651729785b7613da0252b143">StreamSinkFromSource</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga96774ac3651729785b7613da0252b143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Sink from its Source.  <a href="#ga96774ac3651729785b7613da0252b143">More...</a><br /></td></tr>
<tr class="separator:ga96774ac3651729785b7613da0252b143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77ea395f21e03e0950cca250bc31b081"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga77ea395f21e03e0950cca250bc31b081">StreamSinksFromBdAddr</a> (uint16 *max, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *sinks, const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *tpaddr)</td></tr>
<tr class="memdesc:ga77ea395f21e03e0950cca250bc31b081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all the sinks connected to a given Bluetooth address.  <a href="#ga77ea395f21e03e0950cca250bc31b081">More...</a><br /></td></tr>
<tr class="separator:ga77ea395f21e03e0950cca250bc31b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9347efae49c219b06a6bbeb2bbac0560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga9347efae49c219b06a6bbeb2bbac0560">StreamSourceFromSink</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga9347efae49c219b06a6bbeb2bbac0560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Source from its Sink.  <a href="#ga9347efae49c219b06a6bbeb2bbac0560">More...</a><br /></td></tr>
<tr class="separator:ga9347efae49c219b06a6bbeb2bbac0560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0196a72f22747ec494ea5c82738785ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga0196a72f22747ec494ea5c82738785ae">TransformAdpcmDecode</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga0196a72f22747ec494ea5c82738785ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an ADPCM decode transform between source and sink.  <a href="#ga0196a72f22747ec494ea5c82738785ae">More...</a><br /></td></tr>
<tr class="separator:ga0196a72f22747ec494ea5c82738785ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319e203b0dfdb668abc618c560106b83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga319e203b0dfdb668abc618c560106b83">TransformChunk</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga319e203b0dfdb668abc618c560106b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transform between the specified source and sink.  <a href="#ga319e203b0dfdb668abc618c560106b83">More...</a><br /></td></tr>
<tr class="separator:ga319e203b0dfdb668abc618c560106b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba075340217a9c754fb56b72111f667"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gacba075340217a9c754fb56b72111f667">TransformConfigure</a> (<a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> transform, vm_transform_config_key key, uint16 value)</td></tr>
<tr class="memdesc:gacba075340217a9c754fb56b72111f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure parameters associated with a transform.  <a href="#gacba075340217a9c754fb56b72111f667">More...</a><br /></td></tr>
<tr class="separator:gacba075340217a9c754fb56b72111f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4c7ffdbf28a9717e428a256584190b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaef4c7ffdbf28a9717e428a256584190b">TransformConvertClock</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:gaef4c7ffdbf28a9717e428a256584190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clock domain converter transform between the specified source and sink. The transform converts the 32 bits timing information present in the source buffer to sink's clock domain before writing to sink buffer.  <a href="#gaef4c7ffdbf28a9717e428a256584190b">More...</a><br /></td></tr>
<tr class="separator:gaef4c7ffdbf28a9717e428a256584190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaed4873776a8d9110478375ef6d901d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaaaed4873776a8d9110478375ef6d901d">TransformDisconnect</a> (<a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> transform)</td></tr>
<tr class="memdesc:gaaaed4873776a8d9110478375ef6d901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect and destroy a transform.  <a href="#gaaaed4873776a8d9110478375ef6d901d">More...</a><br /></td></tr>
<tr class="separator:gaaaed4873776a8d9110478375ef6d901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94154d78ad0d6357b3bb5237852159c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga94154d78ad0d6357b3bb5237852159c7">TransformFromSink</a> (<a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga94154d78ad0d6357b3bb5237852159c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the transform connected to a sink.  <a href="#ga94154d78ad0d6357b3bb5237852159c7">More...</a><br /></td></tr>
<tr class="separator:ga94154d78ad0d6357b3bb5237852159c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bb5dde865dff67b71d6246a5edb325a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga8bb5dde865dff67b71d6246a5edb325a">TransformFromSource</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source)</td></tr>
<tr class="memdesc:ga8bb5dde865dff67b71d6246a5edb325a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the transform connected to a source.  <a href="#ga8bb5dde865dff67b71d6246a5edb325a">More...</a><br /></td></tr>
<tr class="separator:ga8bb5dde865dff67b71d6246a5edb325a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e3c74ac0fac1ef8f3f65e84a039dac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaa9e3c74ac0fac1ef8f3f65e84a039dac">TransformHash</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:gaa9e3c74ac0fac1ef8f3f65e84a039dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hash transform between specified source and sink streams. Transform will calculate hash of source data packet and write lower 16 bits of hash to configurable position in sink stream buffer. It can also be configured to prepend an RTP header before writing to sink stream buffer.  <a href="#gaa9e3c74ac0fac1ef8f3f65e84a039dac">More...</a><br /></td></tr>
<tr class="separator:gaa9e3c74ac0fac1ef8f3f65e84a039dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951137cb51b3cac04a26a5e039d2940d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga951137cb51b3cac04a26a5e039d2940d">TransformPacketise</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga951137cb51b3cac04a26a5e039d2940d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a packetising transform between the specified source and sink. The packetising transform loads audio frames into L2CAP packets (or vice versa). The packet format is proprietary (TWS+), based on RTP. Various configuration is supported on the master (audio-&gt;L2CAP) side to limit the size and timing of packets, as well as the codec and packet format.  <a href="#ga951137cb51b3cac04a26a5e039d2940d">More...</a><br /></td></tr>
<tr class="separator:ga951137cb51b3cac04a26a5e039d2940d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4dbeff4be4c543c9177da4af70458a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga7f4dbeff4be4c543c9177da4af70458a">TransformPollTraffic</a> (<a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> transform)</td></tr>
<tr class="memdesc:ga7f4dbeff4be4c543c9177da4af70458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report if any traffic has been handled by this transform. Reads and clears a bit that reports any activity on a transform. This can be used to detect activity on connect streams.  <a href="#ga7f4dbeff4be4c543c9177da4af70458a">More...</a><br /></td></tr>
<tr class="separator:ga7f4dbeff4be4c543c9177da4af70458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a808fb2c7b80a8a83e909406a7b13de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga9a808fb2c7b80a8a83e909406a7b13de">TransformSlice</a> (<a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> source, <a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> sink)</td></tr>
<tr class="memdesc:ga9a808fb2c7b80a8a83e909406a7b13de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a transform between the specified source and sink.  <a href="#ga9a808fb2c7b80a8a83e909406a7b13de">More...</a><br /></td></tr>
<tr class="separator:ga9a808fb2c7b80a8a83e909406a7b13de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf22eed0cce39ff36711d0cfa86641705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#gaf22eed0cce39ff36711d0cfa86641705">TransformStart</a> (<a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> transform)</td></tr>
<tr class="memdesc:gaf22eed0cce39ff36711d0cfa86641705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a transform; newly created transforms must be started.  <a href="#gaf22eed0cce39ff36711d0cfa86641705">More...</a><br /></td></tr>
<tr class="separator:gaf22eed0cce39ff36711d0cfa86641705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5564c09d7cccf1dbbb169beaba7c59ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__stream.html#ga5564c09d7cccf1dbbb169beaba7c59ed">TransformStop</a> (<a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> transform)</td></tr>
<tr class="memdesc:ga5564c09d7cccf1dbbb169beaba7c59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a transform,.  <a href="#ga5564c09d7cccf1dbbb169beaba7c59ed">More...</a><br /></td></tr>
<tr class="separator:ga5564c09d7cccf1dbbb169beaba7c59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga715fb92bae5a9c213967a6aca1fbdc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga715fb92bae5a9c213967a6aca1fbdc07">&#9670;&nbsp;</a></span>MessageStreamGetTaskFromSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageStreamGetTaskFromSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Task currently associated with a sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3e6b29387d4d131579530d16965a6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3e6b29387d4d131579530d16965a6ea">&#9670;&nbsp;</a></span>MessageStreamGetTaskFromSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageStreamGetTaskFromSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the task currently associated with a source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad848ada501da6f2c204729a7fb07ef33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad848ada501da6f2c204729a7fb07ef33">&#9670;&nbsp;</a></span>MessageStreamTaskFromSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageStreamTaskFromSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a Task with a Sink. </p>
<dl class="section note"><dt>Note</dt><dd># Task cannot be registered for operator sink which is not connected to a source. # Task cannot be registered for operator sink which is connected to an operator source. # Task can be registered on all streams irrespective of whether they are connected or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to use. </td></tr>
    <tr><td class="paramname">task</td><td>The task to associate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous task for this sink, if any, or zero(0) otherwise. </dd></dl>

</div>
</div>
<a id="gad58fed69bc9ad44da333d2d1a37d1aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad58fed69bc9ad44da333d2d1a37d1aac">&#9670;&nbsp;</a></span>MessageStreamTaskFromSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageStreamTaskFromSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a task with a source. </p>
<dl class="section note"><dt>Note</dt><dd># Task cannot be registered for operator source which is not connected to a sink. # Task cannot be registered for operator source which is connected to an operator sink. # Task can be registered on all streams irrespective of whether they are connected or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to use </td></tr>
    <tr><td class="paramname">task</td><td>The task to associate with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous task for this source, if any, or zero(0) otherwise. </dd></dl>

</div>
</div>
<a id="gaca0b400738008b680f601f253403a4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0b400738008b680f601f253403a4a7">&#9670;&nbsp;</a></span>SinkAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to alias two Sinks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink1</td><td>The first Sink to be aliased </td></tr>
    <tr><td class="paramname">sink2</td><td>The second Sink to be aliased </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sinks are aliased successfully, else FALSE.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="gad33984eda4f93d6b4b3402ddf9ada719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad33984eda4f93d6b4b3402ddf9ada719">&#9670;&nbsp;</a></span>SinkClaim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SinkClaim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to claim the indicated number of extra bytes in a sink. Claims will certainly fail if the sink is invalid, or if SinkSlack indicates that the space is unavailable. SinkClaim(sink, 0) will return the number of octets that are currently claimed in the sink. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns 0xFFFF, irrespective of whether the operator sink stream is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to claim. </td></tr>
    <tr><td class="paramname">extra</td><td>The number of bytes to attempt to claim. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset, from the address returned by SinkMap, of the newly claimed region if the claim was successful, 0xFFFF otherwise. This value is also the number of octets claimed at the point SinkClaim is called. </dd></dl>

</div>
</div>
<a id="gad628d260c93237d0cbba09851743cf8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad628d260c93237d0cbba09851743cf8a">&#9670;&nbsp;</a></span>SinkClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns FALSE, irrespective of whether the operator sink stream is valid or not. </dd>
<dd>
For Pipe streams, a <a class="el" href="group__trapset__stream.html#gad628d260c93237d0cbba09851743cf8a" title="Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SinkClose(Sink)</a> call shall close the sink of that stream and the corresponding source of the other stream, with which this stream shares the common buffer. Also, any transform that exists on these source or sink shall get disconnected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the source could be closed, and FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga5a7b135a6f46872186ae95eba1cc9be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a7b135a6f46872186ae95eba1cc9be3">&#9670;&nbsp;</a></span>SinkConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stream_config_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a particular sink. </p>
<p>See #stream_config_key for the possible keys and their meanings. Note that some keys apply only to specific kinds of sink.</p>
<dl class="section note"><dt>Note</dt><dd>This trap can not configure an operator sink stream. So, it always returns FALSE when passed an operator sink stream input. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to configure. </td></tr>
    <tr><td class="paramname">key</td><td>The key to configure. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to 'key' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if the request could not be performed, TRUE otherwise. </dd></dl>

</div>
</div>
<a id="ga4fcdc75c8a60b0d2edb1e0bf92994a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fcdc75c8a60b0d2edb1e0bf92994a03">&#9670;&nbsp;</a></span>SinkFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the indicated number of bytes out of the sink. The specified bytes of data are passed to the corresponding byte stream, for example out to the UART, or into BlueStack as if sent by a RFC_DATA_IND for UART/RFCOMM sinks respectively. Pointers previously obtained from SinkMap or SinkMapHeader become invalid after a call to SinkFlush. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns FALSE, irrespective of whether the operator sink stream is valid or not. </dd>
<dd>
If the sink is a StreamFileSink, StreamFilesystemSink or an ImageUpgradeStreamGetSink then further data must not be written to the sink before MESSAGE_MORE_SPACE has been received. Alternatively the SinkFlushBlocking trap can be called instead of SinkFlush on the above sink types. SinkFlushBlocking provides a guarantee that the data has been written by the time the trap returns. </dd>
<dd>
The claimed number of bytes in the sink must be mapped and initialised before flush operation is called into. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to flush. </td></tr>
    <tr><td class="paramname">amount</td><td>The number of bytes to flush. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, or FALSE if the operation failed because the sink was invalid or amount exceeded the size of the sink as reported by SinkClaim(sink, 0). </dd></dl>

</div>
</div>
<a id="gaae97fe5b2078952ba408bb27d352c027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae97fe5b2078952ba408bb27d352c027">&#9670;&nbsp;</a></span>SinkFlushBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkFlushBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute a blocking flush operation to flush the indicated number of bytes out of the sink and only return once they've left. The specified bytes of data are passed to the corresponding byte stream and the function waits for confirmation that the bytes have been processed before returning. For example an image upgrade sink would pass bytes to the QSPI device to write and wait until the write is complete before returning. Not all stream types support SinkFlushBlocking. If the given stream doesn't support SinkFlushBlocking this function will return FALSE. Pointers previously obtained from SinkMap or SinkMapHeader become invalid after a call to SinkFlushBlocking. This is a blocking version of the SinkFlush function. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns FALSE, irrespective of whether the operator sink stream is valid or not. </dd>
<dd>
The claimed number of bytes in the sink must be mapped and initialised before flush operation is called into. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to flush. </td></tr>
    <tr><td class="paramname">amount</td><td>The number of bytes to flush. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, or FALSE if the operation failed because the sink was invalid, or doesn't support blocking flushes, or amount exceeded the size of the sink as reported by SinkClaim(sink, 0). </dd></dl>

</div>
</div>
<a id="gaaf18e29bb788b113a9de60361479f146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf18e29bb788b113a9de60361479f146">&#9670;&nbsp;</a></span>SinkFlushHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkFlushHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the indicated number of bytes out of the sink, with a header. Associates the header with the message. The specified bytes of data are then passed to the corresponding byte stream, for example out to the UART, or into BlueStack as if sent by a RFC_DATA_IND for UART/RFCOMM sinks respectively. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns FALSE, irrespective of whether the operator sink stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to flush data from. </td></tr>
    <tr><td class="paramname">amount</td><td>The number of bytes of data to flush. </td></tr>
    <tr><td class="paramname">header</td><td>The header to use. </td></tr>
    <tr><td class="paramname">length</td><td>The size of the header. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, or FALSE if the operation failed because the sink was invalid or amount exceeded the size of the sink as reported by SinkClaim(sink, 0). </dd></dl>

</div>
</div>
<a id="ga919f283d937498f8c72427260b04b298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga919f283d937498f8c72427260b04b298">&#9670;&nbsp;</a></span>SinkGetBdAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkGetBdAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the Bluetooth address from a sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to fetch the Bluetooth address from. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>If the address is found it will be returned to the location pointed at by this value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if such an address was found, FALSE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns FALSE because BlueCore firmware can not get Bluetooth address from operator sink stream. </dd></dl>

</div>
</div>
<a id="ga4b57d4faf6a2b73616db3813184567b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b57d4faf6a2b73616db3813184567b6">&#9670;&nbsp;</a></span>SinkGetRssi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkGetRssi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16 *&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RSSI for the ACL for a sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink which uses the ACL, </td></tr>
    <tr><td class="paramname">rssi</td><td>If the sink corresponds to an ACL the RSSI in dBm will be written to this location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the RSSI was obtained, FALSE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then it always returns FALSE because it is not a ACL sink. </dd></dl>

</div>
</div>
<a id="ga9058e625d9dc68ac6d073eb974cfb32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9058e625d9dc68ac6d073eb974cfb32a">&#9670;&nbsp;</a></span>SinkGetWallclock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkGetWallclock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bt_wallclock_info *&#160;</td>
          <td class="paramname"><em>wallclock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Bluetooth wallclock information of ACL link for sink. The wallclock information contains the bluetooth piconet clock counter value <br />
 and system timestamp at which the piconet clock value was updated. BT clock counter ticks in units of 312.5 microseconds (i.e. half a Bluetooth slot) and system timestamp is reported in microseconds. The wallclock information also contains change counter which is incremented on each change in wallclock information due to ACL role switch. </p>
<dl class="section note"><dt>Note</dt><dd>The sink must be a L2CAP sink stream otherwise it always returns Zero. The application must enable the wallclock feature by using SinkConfigure or SourceConfigure before calling this function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>Identifies the underlying ACL link </td></tr>
    <tr><td class="paramname">wallclock</td><td>If wallclock information could be read, it will be returned to the location pointed at by this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the sink identifies an ACL link and the wallclock information could be read, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga5e87bd2f21892e0df6e00672687b2940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e87bd2f21892e0df6e00672687b2940">&#9670;&nbsp;</a></span>SinkIsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkIsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if a sink is valid, FALSE otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Even if the sink is an operator sink, this trap should able to check whether the supplied sink is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90fa999d02ab67d94ff39f657b979a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90fa999d02ab67d94ff39f657b979a64">&#9670;&nbsp;</a></span>SinkMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* SinkMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the sink into the address map, returning a pointer to the first claimed byte in the sink. Only the total number of claimed bytes (as returned by SinkClaim(sink,0)) are accessible. At most one sink can be mapped in at any time; pointers previously obtained from SinkMap become invalid when another call to SinkMap is made. </p>
<dl class="section note"><dt>Note</dt><dd>An implementation detail first introduced in ADK6 means that the return value of this function for a given sink is no longer a constant. Therefore, any code that relies on the value returned by SinkMap to remain the same between SinkFlush calls may fail. </dd>
<dd>
Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator sink stream is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to map into the address map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the sink is invalid. </dd></dl>

</div>
</div>
<a id="ga34c429bd554ae7eb872b8330c75333a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34c429bd554ae7eb872b8330c75333a3">&#9670;&nbsp;</a></span>SinkMapInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkMapInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stream_device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>header_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures operator sink mapping parameters before calling SinkMap. Sink mapping parameters must be configured for an operator sink stream before calling SinkMap. The configuration parameters are #stream_device and header length. </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is not an operator sink then it always returns zero(0). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>Identifies the operator sink stream. </td></tr>
    <tr><td class="paramname">device</td><td>Type of operator sink device. </td></tr>
    <tr><td class="paramname">header_len</td><td>Length of header in bytes to be used with operator sink stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if sink mapping parameters have been configured, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="gafa1e5dbd177b2b6c27b5dfb316ffbe5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa1e5dbd177b2b6c27b5dfb316ffbe5e">&#9670;&nbsp;</a></span>SinkSlack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SinkSlack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report how many bytes can successfully be claimed in the corresponding sink. </p>
<dl class="section note"><dt>Note</dt><dd>Operator sink stream mapping parameters must be configured by using SinkMapInit before calling this function. If the sink is an operator sink stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator sink stream is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the sink is not valid. </dd></dl>

</div>
</div>
<a id="ga42bcbadf3d88b1f463f25dfc653c3270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42bcbadf3d88b1f463f25dfc653c3270">&#9670;&nbsp;</a></span>SinkSynchronise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkSynchronise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to synchronise two Sinks Call this function to synchronise timing drifts between two sink streams before calling a StreamConnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink1</td><td>The first Sink to be synchronised </td></tr>
    <tr><td class="paramname">sink2</td><td>The second Sink to be synchronised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the Sinks are synchronised successfully, else FALSE. </dd></dl>

</div>
</div>
<a id="ga2bafb62c349ddead71b0bb1312583e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bafb62c349ddead71b0bb1312583e4f">&#9670;&nbsp;</a></span>SinkUnmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SinkUnmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap and reset mapping parameters for an operator sink stream. Unmap and reset mapping parameters for an operator sink stream. </p>
<dl class="section note"><dt>Note</dt><dd>If the sink is not an operator sink then it always returns zero(0). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>Identifies the operator sink to unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if sink has been unmapped successfully, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="gaf671f63da2440f82542e8444cdfb199e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf671f63da2440f82542e8444cdfb199e">&#9670;&nbsp;</a></span>SourceBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SourceBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return how many bytes in this source are before the next packet boundary (for non packet-based sources returns the same as SourceSize.) </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to evaluate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the source is invalid. </dd></dl>

</div>
</div>
<a id="gada37e9ae48d1bbd7d4a84f1f3d6da953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada37e9ae48d1bbd7d4a84f1f3d6da953">&#9670;&nbsp;</a></span>SourceClose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to close the source Some sources, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns <br />
 FALSE, irrespective of whether the operator source stream is valid or not. </dd>
<dd>
For Pipe streams, a SourceClose(Src) call shall close the source of that stream and the corresponding sink of the other stream, with which this stream shares the common buffer. Also, any transform that exists on these source or sink shall get disconnected. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to close </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the source could be closed, and FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga644c1512bb9258138057a0565b387241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644c1512bb9258138057a0565b387241">&#9670;&nbsp;</a></span>SourceConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stream_config_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a particular source. </p>
<p>See #stream_config_key for the possible keys and their meanings. Note that some keys apply only to specific kinds of source. </p><dl class="section note"><dt>Note</dt><dd>This trap cannot configure operator source stream. So, it always returns FALSE over operator source stream input. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to configure. </td></tr>
    <tr><td class="paramname">key</td><td>The key to configure. </td></tr>
    <tr><td class="paramname">value</td><td>The value to write to 'key' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE if the request could not be performed, TRUE otherwise. </dd></dl>

</div>
</div>
<a id="gae56caaf5efeee75f7d7f0cd49f2b7f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae56caaf5efeee75f7d7f0cd49f2b7f4f">&#9670;&nbsp;</a></span>SourceDrop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SourceDrop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards the indicated number of bytes from the front of the source. </p>
<dl class="section note"><dt>Note</dt><dd>An implementation detail first introduced in ADK6 means that pointers previously obtained from SourceMap or SourceMapHeader will not automatically point to the first non-dropped data item after SourceDrop is called. Effectively, SourceDrop invalidates pointers previously obtained from SourceMap or SourceMapHeader. </dd>
<dd>
Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, data will not be dropped, irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source to drop the data from. </td></tr>
    <tr><td class="paramname">amount</td><td>The number of bytes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0535e0c4822ea8f36c936e77f60df30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0535e0c4822ea8f36c936e77f60df30c">&#9670;&nbsp;</a></span>SourceIsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceIsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return TRUE if a source is valid, FALSE otherwise. </p>
<dl class="section note"><dt>Note</dt><dd>Even if the source is an operator source, this trap should be able to check whether the supplied source stream is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d643b195dfdb398d0c0d2d8ab9d4ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d643b195dfdb398d0c0d2d8ab9d4ec5">&#9670;&nbsp;</a></span>SourceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8* SourceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the source into the address map, returning a pointer to the first byte in the source. The number of accessible bytes is as given by <a class="el" href="group__trapset__stream.html#ga08bbe98e69a46c735a44b32d25eda9e9" title="Reports the number of bytes available in the source. ">SourceSize()</a>. At most one source can be mapped in at any time; pointers previously obtained from <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a> become invalid when another call to <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a> is made. Calls to <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> also invalidate previous pointers returned by <a class="el" href="group__trapset__stream.html#ga6d643b195dfdb398d0c0d2d8ab9d4ec5" title="Map the source into the address map, returning a pointer to the first byte in the source...">SourceMap()</a>. See the <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> documentation for more details. </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to map into the address map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the source is invalid. </dd></dl>

</div>
</div>
<a id="ga01baa25079f1ed9fa9adb5ce4a0ff715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01baa25079f1ed9fa9adb5ce4a0ff715">&#9670;&nbsp;</a></span>SourceMapHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* SourceMapHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map the first header associated with a source into the address map. The number of accessible words is as given by <a class="el" href="group__trapset__stream.html#ga80c890587108eeff29dcc0d2d81e80ea" title="Reports the number of words available in the first header associated with source. ...">SourceSizeHeader()</a>. At most one header source can be mapped in at any time; pointers previously obtained from <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a> become invalid when another call to <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a> is made. Calls to <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> also invalidate previous pointers returned by <a class="el" href="group__trapset__stream.html#ga01baa25079f1ed9fa9adb5ce4a0ff715" title="Map the first header associated with a source into the address map. The number of accessible words is...">SourceMapHeader()</a>. See the <a class="el" href="group__trapset__stream.html#gae56caaf5efeee75f7d7f0cd49f2b7f4f" title="Discards the indicated number of bytes from the front of the source. ">SourceDrop()</a> documentation for more details. </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source whose header we wish to map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first word in the header, or zero if the source is invalid or has no headers. </dd></dl>

</div>
</div>
<a id="ga4b52cdeca100c215205d85bd9735d257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b52cdeca100c215205d85bd9735d257">&#9670;&nbsp;</a></span>SourceMapInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceMapInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stream_device&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>header_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures operator source mapping parameters before calling SourceMap or SourceMapHeader. Source mapping parameters must be configured for an operator source stream before calling SourceMap or SourceMapHeader. The configuration parameters are #stream_device and header length. </p>
<dl class="section note"><dt>Note</dt><dd>If the source is not an operator source then it always returns zero(0). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Identifies the operator source. </td></tr>
    <tr><td class="paramname">device</td><td>Type of operator source device. </td></tr>
    <tr><td class="paramname">header_len</td><td>Length of header in bytes to be used with operator source stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if source mapping parameters have been configured, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ga08bbe98e69a46c735a44b32d25eda9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08bbe98e69a46c735a44b32d25eda9e9">&#9670;&nbsp;</a></span>SourceSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SourceSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of bytes available in the source. </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to fetch the size of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the source is invalid. </dd></dl>

</div>
</div>
<a id="gaa80ee91344c8c9e6af1f6fddfc44870c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80ee91344c8c9e6af1f6fddfc44870c">&#9670;&nbsp;</a></span>SourceSizeBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SourceSizeBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of data bytes available in the source. This is a blocking version of the SourceSize function. It can be used when reading from streams that have bounded transport delays and where the data is known to exist (such as file streams). It can be used as an alternative to having a task waiting for a MESSAGE_MORE_DATA message. </p>
<dl class="section note"><dt>Note</dt><dd>Not all stream types support SourceSizeBlocking. If the given stream doesn't support SourceSizeBlocking this function will return SourceSize result. </dd>
<dd>
For writable filesystem if data read into source has failed then it will return 0 indicating FAILURE and no data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to evaluate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero if the source is invalid or if read data into source had failed. </dd></dl>

</div>
</div>
<a id="ga80c890587108eeff29dcc0d2d81e80ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c890587108eeff29dcc0d2d81e80ea">&#9670;&nbsp;</a></span>SourceSizeHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 SourceSizeHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the number of words available in the first header associated with source. </p>
<dl class="section note"><dt>Note</dt><dd>Operator source stream mapping parameters must be configured by using SourceMapInit before calling this function. If the source is an operator source stream with uninitialized mapping parameters, then it always returns zero(0), irrespective of whether the operator source stream is valid or not.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source whose header size is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero if the source is invalid or has no header. </dd></dl>

</div>
</div>
<a id="ga66c12ae5cd16fe4cd8bfbb000f14f8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66c12ae5cd16fe4cd8bfbb000f14f8aa">&#9670;&nbsp;</a></span>SourceSynchronise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceSynchronise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request to synchronise two Sources Call this function to synchronise timing drifts between two source streams before calling a StreamConnect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source1</td><td>The first Source to be synchronised </td></tr>
    <tr><td class="paramname">source2</td><td>The second Source to be synchronised </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the Sources are synchronised successfully, else FALSE. </dd></dl>

</div>
</div>
<a id="gaa99a33d16a9cb121b441169bf7c1114f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa99a33d16a9cb121b441169bf7c1114f">&#9670;&nbsp;</a></span>SourceUnmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SourceUnmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmap and reset mapping parameters for an operator source stream. Unmap and reset mapping parameters for an operator source stream. </p>
<dl class="section note"><dt>Note</dt><dd>If the source is not an operator source then it always returns zero(0). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Identifies the operator source to unmap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if source has been unmapped successfully, otherwise FALSE. </dd></dl>

</div>
</div>
<a id="ga3adcc0a6c3530f416ee0ec81735709d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3adcc0a6c3530f416ee0ec81735709d0">&#9670;&nbsp;</a></span>StreamConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamConfigure </td>
          <td>(</td>
          <td class="paramtype">vm_stream_config_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the stream subsystem. </p>
<p>Reasons for a FALSE return value include attempting to use an invalid <em>key</em>, attempting to use a <em>key</em> not supported in the current firmware build and attempting to use a <em>value</em> that is not suitable for the <em>key</em> being used. The application will be panicked if it attempts to enable or disable streams when any corresponding L2CAP/RFCOMM connection is open. Note that this trap is also used to enable/disable an application's interest in receiving certain messages (eg.see keys #VM_STREAM_USB_ALT_IF_MSG_ENABLED and #VM_STREAM_USB_ATTACH_MSG_ENABLED). This trap is also used to enable L2CAP large buffers for particular PSM using key #VM_STREAM_L2CAP_ADD_LARGE_BUFFER_ON_PSM and remove all large buffer information using key #VM_STREAM_L2CAP_REMOVE_ALL_LARGE_BUFFER. #VM_STREAM_L2CAP_ADD_LARGE_BUFFER_ON_PSM key should be used to configure before sending or accepting L2CAP connection request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Keys are defined in #vm_stream_config_key. </td></tr>
    <tr><td class="paramname">value</td><td>The value to set <em>key</em> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the configure worked, FALSE if the configure failed. </dd></dl>

</div>
</div>
<a id="ga4cd351636d2d317e6bd2f4c5f76968d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4cd351636d2d317e6bd2f4c5f76968d4">&#9670;&nbsp;</a></span>StreamConnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> StreamConnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an automatic connection between a source and sink. </p>
<dl class="section note"><dt>Note</dt><dd>Transform created via this call is started implicitly. It is not desired to start or stop such transforms by invoking <em><a class="el" href="group__trapset__stream.html#gaf22eed0cce39ff36711d0cfa86641705" title="Start a transform; newly created transforms must be started. ">TransformStart()</a></em> or <em><a class="el" href="group__trapset__stream.html#ga5564c09d7cccf1dbbb169beaba7c59ed" title="Stop a transform,. ">TransformStop()</a></em> respectively from the application. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source data will be taken from. </td></tr>
    <tr><td class="paramname">sink</td><td>The Sink data will be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An already started transform on success, or zero on failure. </dd></dl>

</div>
</div>
<a id="ga98cf0d2993eab82215bda2d157baef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98cf0d2993eab82215bda2d157baef9a">&#9670;&nbsp;</a></span>StreamConnectDispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamConnectDispose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispose of all data arriving on the specified source by throwing it away. </p>
<p>On success the source is effectively connected using <a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4" title="Make an automatic connection between a source and sink. ">StreamConnect()</a>; you can stop discarding data from the source by calling StreamDisconnect(source, 0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source whose data is to be disposed of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE on failure, TRUE on success. </dd></dl>

</div>
</div>
<a id="ga527bafa672552787830a9444e2058fa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga527bafa672552787830a9444e2058fa9">&#9670;&nbsp;</a></span>StreamDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StreamDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Break any existing automatic connection involving the source <em>or</em> sink. Source or sink may be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source to check for connections. </td></tr>
    <tr><td class="paramname">sink</td><td>The Sink to check for connections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a1afd52a99980f3dba6eeef6d26b57e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1afd52a99980f3dba6eeef6d26b57e">&#9670;&nbsp;</a></span>StreamMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 StreamMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the specified number of bytes from the start of 'source' to the end of 'sink'. The count must be no more than both <a class="el" href="group__trapset__stream.html#gafa1e5dbd177b2b6c27b5dfb316ffbe5e" title="Report how many bytes can successfully be claimed in the corresponding sink. ">SinkSlack()</a> and <a class="el" href="group__trapset__stream.html#gaf671f63da2440f82542e8444cdfb199e" title="Return how many bytes in this source are before the next packet boundary (for non packet-based source...">SourceBoundary()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>An implementation detail first introduced in ADK6 means that pointers returned by SourceMap, SourceMapHeader, SinkMap or SinkMapHeader will be invalidated after a call to StreamMove. </dd>
<dd>
If either source or sink is an operator source/sink stream then it always returns zero(0), irrespective of whether the operator source/sink stream is valid or not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink to move data from. </td></tr>
    <tr><td class="paramname">source</td><td>The Source to move data from. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to move. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on failure and the count on success. </dd></dl>

</div>
</div>
<a id="gaf84a961372615e789539511b6938be5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf84a961372615e789539511b6938be5a">&#9670;&nbsp;</a></span>StreamPipePair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamPipePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *&#160;</td>
          <td class="paramname"><em>sink_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *&#160;</td>
          <td class="paramname"><em>sink_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size_a_to_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size_b_to_a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a bi-directional Pipe Stream. </p>
<dl class="section note"><dt>Note</dt><dd>This trap creates two streams with buffers. sink of stream a and source of stream b share a common buffer and forms one Pipe. Similarly, sink of stream b and source of stream a share another common buffer and forms the second Pipe. Data arriving at one end of the pipe will be automatically available at the other end of the pipe. For example: Data arriving at sink of stream a will be automatically available at source of stream b and data arriving at sink of stream b will be automatically available at source of stream a. Application must pass a valid buffer size for both the interconnected buffers of stream a and stream b or else this trap will return FALSE. Passing the size as either Zero or greater than the supported buffer memory size is considered as invalid size. Typically, the maximum supported buffer memory size is lesser than 4KB. It is also strongly recommended not to use buffer memory with large size. </dd>
<dd>
Destroying the entire pipe stream requires the application to individually invoke close (on either the sink or source) of both the pipes. In order to destroy the Pipe Stream, Application can call either <a class="el" href="group__trapset__stream.html#gada37e9ae48d1bbd7d4a84f1f3d6da953" title="Request to close the source Some sources, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SourceClose()</a> or <a class="el" href="group__trapset__stream.html#gad628d260c93237d0cbba09851743cf8a" title="Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SinkClose()</a> trap. Closing one of the Pipe ends (source or sink) shall also close the source or sink of the other end. However, the other pipe and hence its corresponding source and sink will remain active. In order to destroy the other pipe, application needs to call either <a class="el" href="group__trapset__stream.html#gada37e9ae48d1bbd7d4a84f1f3d6da953" title="Request to close the source Some sources, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SourceClose()</a> or <a class="el" href="group__trapset__stream.html#gad628d260c93237d0cbba09851743cf8a" title="Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SinkClose()</a> again on the other pipe. Closing any one pipe using <a class="el" href="group__trapset__stream.html#gada37e9ae48d1bbd7d4a84f1f3d6da953" title="Request to close the source Some sources, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SourceClose()</a> or <a class="el" href="group__trapset__stream.html#gad628d260c93237d0cbba09851743cf8a" title="Request to close the sink Some sinks, such as RFCOMM connections or the USB hardware, have a lifetime defined by other means, and cannot be closed using this call. ">SinkClose()</a> trap will not invalidate the source and sink ids since these are required to retrieve the sink or source of the other pipe using either <a class="el" href="group__trapset__stream.html#ga9347efae49c219b06a6bbeb2bbac0560" title="Find the Source from its Sink. ">StreamSourceFromSink()</a> or <a class="el" href="group__trapset__stream.html#ga96774ac3651729785b7613da0252b143" title="Find the Sink from its Source. ">StreamSinkFromSource()</a> trap.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink_a</td><td>Address of the sink of stream a </td></tr>
    <tr><td class="paramname">sink_b</td><td>Address of the sink of stream b </td></tr>
    <tr><td class="paramname">size_a_to_b</td><td>Size of the buffer to transfer data from stream a to stream b </td></tr>
    <tr><td class="paramname">size_b_to_a</td><td>Size of the buffer to transfer data from stream b to stream a </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the Pipe Stream is created successfully, else FALSE. </dd></dl>

</div>
</div>
<a id="ga91264b8a2400ddabd6009f3ae4958ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91264b8a2400ddabd6009f3ae4958ba4">&#9670;&nbsp;</a></span>StreamRegionSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> StreamRegionSource </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a source from a region of memory. This function allows a region of memory to be treated as a source. This is useful when there is a requirement to handle data (held in a known region of memory) using functions that expect a source, e.g. <a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4" title="Make an automatic connection between a source and sink. ">StreamConnect()</a>, in order to efficiently transfer the data without having to copy it. It is important that the memory being treated as a source persists long enough for the stream operation to complete, i.e., long enough for the source to be read. The source created using this function only exists while the data is being read. However, the memory block being treated as a source is not freed by the stream subsystem once the data has been read. It remains the caller's responsibility to manage the memory and free it when it is appropriate to do so. If length is zero then 0 is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The memory that the source will be created from. </td></tr>
    <tr><td class="paramname">length</td><td>The size of the memory region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga96774ac3651729785b7613da0252b143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96774ac3651729785b7613da0252b143">&#9670;&nbsp;</a></span>StreamSinkFromSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> StreamSinkFromSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Sink from its Source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source whose sink is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the source is an operator source stream then this trap always returns zero(0), because BlueCore firmware can not convert operator source stream into an operator sink stream. </dd></dl>

</div>
</div>
<a id="ga77ea395f21e03e0950cca250bc31b081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77ea395f21e03e0950cca250bc31b081">&#9670;&nbsp;</a></span>StreamSinksFromBdAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StreamSinksFromBdAddr </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a> *&#160;</td>
          <td class="paramname"><em>sinks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtp__bdaddr.html">tp_bdaddr</a> *&#160;</td>
          <td class="paramname"><em>tpaddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all the sinks connected to a given Bluetooth address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>Stores up to *max sinks in the array given, and updates *max. </td></tr>
    <tr><td class="paramname">sinks</td><td>The array of sinks to store into. </td></tr>
    <tr><td class="paramname">tpaddr</td><td>The Bluetooth address to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if there was enough space, FALSE if some had to be discarded. </dd></dl>

</div>
</div>
<a id="ga9347efae49c219b06a6bbeb2bbac0560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9347efae49c219b06a6bbeb2bbac0560">&#9670;&nbsp;</a></span>StreamSourceFromSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a> StreamSourceFromSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Source from its Sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The Sink whose source is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the sink is an operator sink stream then this trap always returns zero(0), because BlueCore firmware can not convert operator sink stream into operator source stream. </dd></dl>

</div>
</div>
<a id="ga0196a72f22747ec494ea5c82738785ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0196a72f22747ec494ea5c82738785ae">&#9670;&nbsp;</a></span>TransformAdpcmDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformAdpcmDecode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an ADPCM decode transform between source and sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source containing ADPCM encoded data </td></tr>
    <tr><td class="paramname">sink</td><td>The destination sink </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga319e203b0dfdb668abc618c560106b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga319e203b0dfdb668abc618c560106b83">&#9670;&nbsp;</a></span>TransformChunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transform between the specified source and sink. </p>
<p>Copies data in chunks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source to use in the transform. </td></tr>
    <tr><td class="paramname">sink</td><td>The Sink to use in the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform. </dd></dl>

</div>
</div>
<a id="gacba075340217a9c754fb56b72111f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba075340217a9c754fb56b72111f667">&#9670;&nbsp;</a></span>TransformConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vm_transform_config_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure parameters associated with a transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to configure. </td></tr>
    <tr><td class="paramname">key</td><td>Valid values depend on the transform. </td></tr>
    <tr><td class="paramname">value</td><td>Valid values depend on the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns FALSE if the key was unrecognised, or if the value was out of bounds. </dd></dl>

</div>
</div>
<a id="gaef4c7ffdbf28a9717e428a256584190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4c7ffdbf28a9717e428a256584190b">&#9670;&nbsp;</a></span>TransformConvertClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformConvertClock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a clock domain converter transform between the specified source and sink. The transform converts the 32 bits timing information present in the source buffer to sink's clock domain before writing to sink buffer. </p>
<dl class="section note"><dt>Note</dt><dd>The transform will support any source and sink stream of application subsystem. The conversion from source clock domain to sink clock domain happens based on the timing offset received either from source or sink or both. For instance, if source is a file stream and sink is an L2cap stream then system time present in file source data would be converted based on the wallclock offset details provided by L2cap sink. </dd>
<dd>
Transform would work based on following configurations: 1) VM_TRANSFORM_CLK_CONVERT_START_OFFSET 2) VM_TRANSFORM_CLK_CONVERT_REPETITION_OFFSET 3) VM_TRANSFORM_CLK_CONVERT_NUM_REPETITIONS</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to use in the transform. </td></tr>
    <tr><td class="paramname">sink</td><td>The sink to use in the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform. </dd></dl>

</div>
</div>
<a id="gaaaed4873776a8d9110478375ef6d901d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaed4873776a8d9110478375ef6d901d">&#9670;&nbsp;</a></span>TransformDisconnect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformDisconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect and destroy a transform. </p>
<p>The transform can no longer be used after successful disconnecting of the transform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, FALSE on failure. </dd></dl>

</div>
</div>
<a id="ga94154d78ad0d6357b3bb5237852159c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94154d78ad0d6357b3bb5237852159c7">&#9670;&nbsp;</a></span>TransformFromSink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformFromSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the transform connected to a sink. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sink</td><td>The sink to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform connected to the specified sink, or zero if no transform or connection is active. </dd></dl>

</div>
</div>
<a id="ga8bb5dde865dff67b71d6246a5edb325a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bb5dde865dff67b71d6246a5edb325a">&#9670;&nbsp;</a></span>TransformFromSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformFromSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the transform connected to a source. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to look for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transform connected to the specified source, or zero if no transform or connection is active. </dd></dl>

</div>
</div>
<a id="gaa9e3c74ac0fac1ef8f3f65e84a039dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e3c74ac0fac1ef8f3f65e84a039dac">&#9670;&nbsp;</a></span>TransformHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hash transform between specified source and sink streams. Transform will calculate hash of source data packet and write lower 16 bits of hash to configurable position in sink stream buffer. It can also be configured to prepend an RTP header before writing to sink stream buffer. </p>
<dl class="section note"><dt>Note</dt><dd>Following configurations are required for functioning of this transform: 1) VM_TRANSFORM_HASH_PREFIX_RTP_HEADER 2) VM_TRANSFORM_HASH_RTP_PAYLOAD_TYPE 3) VM_TRANSFORM_HASH_RTP_SSRC_LOWER 4) VM_TRANSFORM_HASH_RTP_SSRC_UPPER 5) VM_TRANSFORM_HASH_SOURCE_OFFSET 6) VM_TRANSFORM_HASH_SOURCE_SIZE 7) VM_TRANSFORM_HASH_SOURCE_MODIFY_OFFSET </dd>
<dd>
The transform can connect any source and sink including audio or operator streams except the case when both source and sink are either audio or operator stream.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to use in the transform. </td></tr>
    <tr><td class="paramname">sink</td><td>The sink to use in the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform. </dd></dl>

</div>
</div>
<a id="ga951137cb51b3cac04a26a5e039d2940d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga951137cb51b3cac04a26a5e039d2940d">&#9670;&nbsp;</a></span>TransformPacketise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformPacketise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a packetising transform between the specified source and sink. The packetising transform loads audio frames into L2CAP packets (or vice versa). The packet format is proprietary (TWS+), based on RTP. Various configuration is supported on the master (audio-&gt;L2CAP) side to limit the size and timing of packets, as well as the codec and packet format. </p>
<dl class="section note"><dt>Note</dt><dd>The audio endpoint must be connected to an operator capable of handling unexpected disconnections of the stream while the chain is active (e.g. switched passthrough consumer or RTP decode), in order to allow the firmware to stop the audio service in the case of a link loss. Such an operator must be present both on the input of the packetiser (on the forwarding device) and the output of the depacketizer (on the receiving device).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source to use in the transform. </td></tr>
    <tr><td class="paramname">sink</td><td>The sink to use in the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform. </dd></dl>

</div>
</div>
<a id="ga7f4dbeff4be4c543c9177da4af70458a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f4dbeff4be4c543c9177da4af70458a">&#9670;&nbsp;</a></span>TransformPollTraffic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformPollTraffic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report if any traffic has been handled by this transform. Reads and clears a bit that reports any activity on a transform. This can be used to detect activity on connect streams. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the transform exists and has processed data, FALSE otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If the transform is connected between stream and an operator then this trap reports traffic by the transform. But, if the transform is connected between two operators inside the DSP then the trap would return FALSE. </dd></dl>

</div>
</div>
<a id="ga9a808fb2c7b80a8a83e909406a7b13de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a808fb2c7b80a8a83e909406a7b13de">&#9670;&nbsp;</a></span>TransformSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a> TransformSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="source___8h.html#afbe187e42995c6b6af38624c70e7a3e2">Source</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="sink___8h.html#a250a23fcb6a29255bb2526a002d691b2">Sink</a>&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a transform between the specified source and sink. </p>
<p>Removes bytes from start and end of packets. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The Source to use in the transform. </td></tr>
    <tr><td class="paramname">sink</td><td>The Sink to use in the transform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on failure, otherwise the transform. </dd></dl>

</div>
</div>
<a id="gaf22eed0cce39ff36711d0cfa86641705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf22eed0cce39ff36711d0cfa86641705">&#9670;&nbsp;</a></span>TransformStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start a transform; newly created transforms must be started. </p>
<dl class="section note"><dt>Note</dt><dd>Application shouldn't call this function for transforms created via <em><a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4" title="Make an automatic connection between a source and sink. ">StreamConnect()</a></em> call as those transforms are started implicitly. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE on failure, TRUE on success. </dd></dl>

</div>
</div>
<a id="ga5564c09d7cccf1dbbb169beaba7c59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5564c09d7cccf1dbbb169beaba7c59ed">&#9670;&nbsp;</a></span>TransformStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TransformStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="transform___8h.html#ab631d9d4bad9b139aec5417d6c819fb7">Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop a transform,. </p>
<dl class="section note"><dt>Note</dt><dd>Application shouldn't call this function for transforms created via <em><a class="el" href="group__trapset__stream.html#ga4cd351636d2d317e6bd2f4c5f76968d4" title="Make an automatic connection between a source and sink. ">StreamConnect()</a></em> call. To stop data flow for such transforms, application would typically call <em><a class="el" href="group__trapset__stream.html#gaaaed4873776a8d9110478375ef6d901d" title="Disconnect and destroy a transform. ">TransformDisconnect()</a></em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform to stop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>FALSE on failure, TRUE on success. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
