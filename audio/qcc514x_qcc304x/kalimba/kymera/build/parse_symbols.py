#!/usr/bin/env python
############################################################################
# CONFIDENTIAL
#
# Copyright (c) 2015 - 2018 Qualcomm Technologies International, Ltd.
#
############################################################################
"""
Parse a Kalimba symbols file generated by kreadelf, and beautify the output.
"""
import sys
import re
import argparse

class Arguments:
    """ Class to parse and hold the arguments of the script. """
    def __init__(self, argv):
        """
        Parse the command line arguments and store them into the object.
        """
        parser = argparse.ArgumentParser(description="This script parses symbol files output " + \
                                         "by kreadelf, and presents them in a more useful form.")
        parser.add_argument("-c",
                            action="store_true", dest="show_chaff", default=False,
                            help="Show 'chaff', i.e. boring symbols. Default is off.")
        parser.add_argument("-w",
                            action="store", type=str, dest="bits", default="24",
                            help="Select 24/32 bit target")
        parser.add_argument("-l",
                            action="store", type=str, dest="linkscript",
                            help="Use this linkscript for section definitions")
        parser.add_argument("args",
                            help="Kalimba symbols file generated by kreadelf",
                            type=str, nargs=1)
        options = parser.parse_args()

        self.script_path = argv[0]
        self.show_chaff = options.show_chaff
        self.arch4 = options.bits == "32"
        self.linkscript = options.linkscript
        self.symbols_file = options.args[0]

class Entry:
    """ Class to hold information about any type of symbol. """
    def __init__(self):
        self.name = ""
        self.start = int(0)
        self.end = int(0)
        self.type = ""
        self.value = ""
        self.topflags = int(0)
        self.hexval = ""
        self.realval = int(0)
        self.size = ""
        self.bind = ""
        self.vis = ""
        self.ndx = ""
        self.region = ""
        self.boring = False

    def __str__(self):
        result = ""
        for key in self.__dict__:
            result += str(key)
            try:
                value = hex(self.__dict__[key])
            except TypeError:
                value = str(self.__dict__[key])
            result += ":" + value + ", "
        return result

class LinkerScript:
    """
    Extract and contain the regions and overlays of a linker script.
    """
    def __init__(self):
        self.regions = {}
        self.overlays = {}
        #                        | Region  Name |StartAddr|EndAddr| Type
        #                        |   group 1    |   g2    |  g3   |  g4
        self.pattern_1 = re.compile(r"^region\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+);")
        #                        | Overlay Name  |Region |Bit width
        #                        |    group 1    |  g2   |   g3
        self.pattern_2 = re.compile(r"^overlay\s+(\S+)\s+(\S+)\s+(\S+);")

    def parse_linkerscript(self, file_name):
        """
        Reads the content of a linker script into memory and then
        extract the regions and overlays information from it.
        """
        content = None
        lines = []
        try:
            with open(file_name) as file:
                content = file.read()
            lines = content.split("\n")
        except IOError:
            pass

        for line in lines:
            match = re.search(self.pattern_1, line)
            if match:
                entry = Entry()
                entry.name = match.group(1)
                entry.start = int(match.group(2), 16)
                entry.end = int(match.group(3), 16)
                entry.type = match.group(4)
                self.regions[entry.name] = entry
            else:
                match = re.search(self.pattern_2, line)
                if match:
                    name = match.group(1)
                    region = match.group(2)

                    if region in self.regions:
                        self.overlays[name] = self.regions[region]
                    else:
                        print("unsupported region: " + region)
                        sys.exit(1)

    def find_region(self, address, top_flags):
        """
        Find out which region this address is in.
        Input parameters: address (integer), top_flags top two hex digits (integer)
        Returns: region or None if there isn't one defined.
        """

        # First, look in the top flags of the address (which are inserted by the compiler)
        # to work out whether the address is in PM or DM.
        # If bit 31 is set, the symbol is code, rather than data.
        # If bit 24 is set, the symbol is in NVMEM (could be code or data).
        # So code in NVMEM starts "81" and code in PM RAM starts "80".
        is_code = 0
        in_nvmem = 0

        if top_flags & 0x80:
            is_code = 1

        if top_flags & 0x01:
            # Actually since the PM RAM addresses overlap with DM RAM (not PM ROM),
            # We don't need to do anything with this flag yet.
            in_nvmem = 1

        # Extract the overlays one at a time, sorted smallest first
        sorted_overlays = sorted(self.overlays,
                                 key=lambda x: self.overlays[x].end - self.overlays[x].start)
        for key in sorted_overlays:
            if self.overlays[key].type == "CODE" and not is_code:
                continue
            if self.overlays[key].type == "DATA" and is_code:
                continue
            if not in_nvmem:
                continue
            if address >= self.overlays[key].start and address <= self.overlays[key].end:
                return key

        # Now do the same for non-overlay regions
        sorted_regions = sorted(self.regions,
                                key=lambda x: self.regions[x].end - self.regions[x].start)
        for key in sorted_regions:
            if self.regions[key].type == "CODE" and not is_code:
                continue
            if self.regions[key].type == "DATA" and is_code:
                continue
            if address >= self.regions[key].start and address <= self.regions[key].end:
                return key

        return None

class ElfSymbols:
    """
    Contains symbol information extracted from the output of readelf.
    """
    def __init__(self, arch4):
        self.arch4 = arch4
        self.constants = []
        self.stuff = {}
        self.chaff = {}

    def parse_symbolsfile(self, data):
        """
        Parse each line of the symbol file into a list of entries.
        """
        result = []

        #                     |  Num:| Value | Size | Type  | Bind  | Vis   |  Ndx  | [Name] |
        #                     |  g1  |  g2   |  g3  |  g4   |  g5   |  g6   |   g7  |  g8    |
        pattern = re.compile(r"(\d+):\s+(\S+)\s+(\d)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)?")

        for line in data:
            match = re.search(pattern, line)
            if match:
                entry = Entry()
                entry.value = match.group(2)
                if self.arch4:
                    entry.topflags = int(match.group(2)[0:2], 16)
                    if (entry.topflags & 0xf0) == 0x80:
                        entry.hexval = '0' + match.group(2)[1:]
                    else:
                        entry.hexval = match.group(2)[0:]
                else:
                    # Strip off the first two hex digits. We use them separately.
                    entry.topflags = int(match.group(2)[0:2], 16)
                    entry.hexval = match.group(2)[2:]

                entry.realval = int(entry.hexval, 16)
                entry.size = match.group(3)
                entry.type = match.group(4)
                entry.bind = match.group(5)
                entry.vis = match.group(6)
                entry.ndx = match.group(7)
                entry.name = match.group(8)
                result.append(entry)
            else:
                continue
        return result

    def sort_entry_list(self, entries, linker_script):
        """
        Sort a list of entries into constants, soi (symbols of interest), and extras
        based on linker regions and overlays.
        """
        for entry in entries:
            # Figure out which hash/array to put the entry in. All of the hashes are keyed on ndx;
            # ndx implies where in the memory map the thing lives, which is our best way
            # of figuring out what it's for.
            if (entry.type == 'NOTYPE') and (entry.ndx == 'ABS'):
                # Constant definition
                self.constants.append(entry)
            elif (entry.type == 'NOTYPE') and (entry.ndx == 'UND'):
                # These are usually pseudo-variables - put into the chaff
                if entry.ndx not in self.chaff:
                    self.chaff[entry.ndx] = []
                self.chaff[entry.ndx].append(entry)
            elif (entry.type == 'NOTYPE') and (entry.bind == 'GLOBAL'):
                # NOTYPE GLOBAL with a genuine Index seems quite rare.
                # It often defines the __Base and __Limit symbols for a region.
                # Caution: the value for __Limit is actually <final address in the region> + 1.
                if entry.name[-7:] == "__Limit":
                    entry.region = linker_script.find_region(entry.realval- 0x1, entry.topflags)
                else:
                    entry.region = linker_script.find_region(entry.realval, entry.topflags)

                if not entry.region:
                    entry.region = entry.ndx

                if not entry.region in self.stuff:
                    self.stuff[entry.region] = []
                self.stuff[entry.region].append(entry)

            elif entry.type == 'SECTION':
                # Don't do anything with these.
                pass
            elif entry.type == 'FILE':
                # Ignore these for now.
                pass
            elif entry.type == 'FUNC' or entry.type == 'OBJECT' or entry.type == 'NOTYPE':
                # Build up a hash of arrays of entries.
                entry.region = linker_script.find_region(entry.realval, entry.topflags)
                if not entry.region:
                    entry.region = entry.ndx


                # Check for 'boring' code labels, e.g. '.Lg77' or 'Lc_init_fault_1'
                if entry.name[0:2] == ".L" or entry.name[0:3] == "Lc_":
                    entry.boring = True

                if entry.region not in self.stuff:
                    self.stuff[entry.region] = []
                self.stuff[entry.region].append(entry)

            else:
                if entry.region not in self.chaff:
                    self.chaff[entry.region] = []
                self.chaff[entry.region].append(entry)

    @staticmethod
    def from_file(linker_script, file_name, arch4):
        """
        Reads the output of readelf stored in file_name and using a
        linker script object, generate a ElfSymbols object.
        The method must be told whether the platform is ARCH4 or not.
        """
        content = None
        try:
            with open(file_name) as file:
                content = file.read()
            lines = content.split("\n")
        except IOError as err:
            sys.stderr.write("%s: unable to open %s\n" % (sys.argv[0], file_name))
            raise err

        elf_symbols = ElfSymbols(arch4)
        entries = elf_symbols.parse_symbolsfile(lines)
        elf_symbols.sort_entry_list(entries, linker_script)
        return elf_symbols

    def print_constants(self):
        """ Pretty print constants. """
        print("\n*********************************************************************")
        print("        CONSTANTS ")
        print("*********************************************************************")
        for entry in self.constants:
            print("  " + entry.name + ": " + str(entry.value))

    def print_stuff(self, print_boring):
        """ Pretty print stuff. """
        print("\n*********************************************************************")
        print("        SYMBOLS ")
        print("*********************************************************************")
        for key in sorted(self.stuff):
            print("---------------------------------------------------------------------")
            print("        SECTION " + str(key) + ":")
            print("---------------------------------------------------------------------")
            print("   Value  Size Type    Bind   Vis      Ndx Name ")
            entries = self.stuff[key]
            for entry in sorted(entries, key=lambda entry: entry.realval):
                line = "%-4s %5s %-7s %-6s %s   %2s %s" % \
                       (entry.hexval, entry.size, entry.type, entry.bind, entry.vis,
                        entry.ndx, entry.name)
                if print_boring or not entry.boring:
                    print(line)

    def print_chaff(self):
        """ Pretty print boring information. """
        print("\n*********************************************************************\n")
        print("        CHAFF \n")
        print("*********************************************************************\n")
        for key in sorted(self.chaff):
            print("---------------------------------------------------------------------")
            print("        SECTION " + str(key) + ":")
            print("---------------------------------------------------------------------")
            print("   Value  Size Type    Bind   Vis      Ndx Name ")
            entries = self.chaff[key]
            for entry in sorted(entries, key=lambda entry: entry.realval):
                line = "%-4s %5s %-7s %-6s %s   %2s %s" % \
                       (entry.hexval, entry.size, entry.type, entry.bind, entry.vis,
                        entry.ndx, entry.name)
                print(line)

if __name__ == "__main__":
    ARGUMENTS = Arguments(sys.argv)

    LINKERSCRIPT = LinkerScript()
    LINKERSCRIPT.parse_linkerscript(ARGUMENTS.linkscript)
    SYMBOLS = ElfSymbols.from_file(LINKERSCRIPT, ARGUMENTS.symbols_file, ARGUMENTS.arch4)

    SYMBOLS.print_constants()
    SYMBOLS.print_stuff(ARGUMENTS.show_chaff)
    if ARGUMENTS.show_chaff:
        SYMBOLS.print_chaff()
