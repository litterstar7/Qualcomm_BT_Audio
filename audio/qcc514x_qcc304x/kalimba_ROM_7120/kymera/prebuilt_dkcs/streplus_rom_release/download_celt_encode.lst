
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2008181118/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_celt_encode.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$celt.encoder_init>:
   
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODER_INIT.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   push r5;
84200000:	00 00 70 f3 	push r5;
   r9 = r5;
84200004:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200008:	10 00 77 d1 	r5 = M[r5 + 16];

   // -- disable re-init flag
   M[r5 + $celt.enc.REINIT_ENCODER_FIELD] = 0;
8420000c:	14 00 07 d5 	M[r5 + 20] = Null;
      
   // reset byte pos
   r0 = $celt.BYTE_POS_MAX_VALUE;
84200010:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r0;
84200014:	a4 00 27 d5 	M[r5 + 164] = r0;
   
   // -- read mode variables
   r10 = $celt.mode.STRUC_SIZE ;
84200018:	14 00 c0 01 	r10 = Null + 20;
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
8420001c:	00 00 a7 d1 	r8 = M[r5 + 0];
   I3 = r8;
84200020:	af 00 30 50 	I3 = Null + r8;
   I6 = r5 + $celt.enc.MODE_FIELDS_OFFSET_FIELD;
84200024:	3c 00 67 51 	I6 = r5 + 60;
   do read_single_vars_loop;
84200028:	03 00 f0 e5 	do $M.celt.encoder_init.read_single_vars_loop;
      r0 = M[I3, MK1];
8420002c:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      M[I6, MK1] = r0;
84200030:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84200034 <$M.celt.encoder_init.read_single_vars_loop>:
   read_single_vars_loop:
      
   r0 = &$celt.ec_enc_tell;
84200034:	20 04 00 fd 	r0 = Null + 69210632;
84200038:	08 12 20 01 
   M[r5 + $celt.enc.TELL_FUNC_FIELD] = r0;
8420003c:	30 00 27 d5 	M[r5 + 48] = r0;
   r0 = &$celt.alg_quant;
84200040:	20 04 00 fd 	r0 = Null + 69215856;
84200044:	70 26 20 01 
   M[r5 + $celt.enc.ALG_QUANT_FUNC_FIELD] = r0;
84200048:	34 00 27 d5 	M[r5 + 52] = r0;
   r0 = &$celt.ec_enc_uint;
8420004c:	20 04 00 fd 	r0 = Null + 69210880;
84200050:	00 13 20 01 
   M[r5 + $celt.dec.EC_UINT_FUNC_FIELD] = r0;
84200054:	38 00 27 d5 	M[r5 + 56] = r0;

   pop r5;
84200058:	00 00 74 f3 	pop r5;
   rts;
8420005c:	0f 00 0d dc 	rts;

84200060 <$_celt_encode_lib_init>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_LIB_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif
   // Save the registers C expects us to preserve that get trashed
   PUSH_ALL_C
84200060:	c0 af 00 f1 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
84200064:	77 00 01 f1 	pushm <I0, I1, I2, I4, I5, I6>;
84200068:	00 f7 01 f1 	pushm <M0, M1, M2, L0, L1, L4, L5>;
   r9 = r0;
8420006c:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200070:	0f 00 72 00 	r5 = r0 + Null;
   push r0;
84200074:	00 00 20 f3 	push r0;
 
   
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200078:	10 00 77 d1 	r5 = M[r5 + 16];
   r6 = 1 ;                                  // encoder 
8420007c:	2f 00 80 e4 	r6 = Null + 1;
   r0 = M[r5 + $celt.enc.MODE_FIELD];        // mode 
84200080:	3c 02 27 d1 	r0 = M[r5 + 572];
   call $celt.codec.init_tables;
84200084:	f8 01 f0 e1 	call $celt.codec.init_tables;
   
   pop r0;
84200088:	00 00 24 f3 	pop r0;
   r9 = r0;
8420008c:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200090:	0f 00 72 00 	r5 = r0 + Null;
   call $celt.encoder_init;
84200094:	db ff f0 e1 	call $celt.encoder_init;

   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200098:	10 00 77 d1 	r5 = M[r5 + 16];
   r8 = M[r5 + $celt.enc.PTR_celt_enc_state_pool];
8420009c:	38 02 a7 d1 	r8 = M[r5 + 568];
   r7 = 306;                                 //length($celt_enc_state_pool);
842000a0:	32 01 90 01 	r7 = Null + 306;
   call $celt.alloc_state_mem;
842000a4:	aa 0b f0 e1 	call $celt.alloc_state_mem;
#ifdef KYMERA 
   NULL = M[r5 + $celt.enc.FFT_TABLE_INIT_DONE_FIELD];
842000a8:	40 02 07 d1 	Null = M[r5 + 576];
   if NZ jump dont_init_fft_tables_enc;
842000ac:	06 00 10 dd 	if NE jump $M.celt.encoder_init.dont_init_fft_tables_enc;
   r0 = $celt.FFT_TWIDDLE_SIZE;
842000b0:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.alloc;
842000b4:	07 00 00 fd 	call 0x74f20;
842000b8:	20 4f f0 e1 
   r0 = 1;
842000bc:	2f 00 20 e4 	r0 = Null + 1;
   M[r5 + $celt.enc.FFT_TABLE_INIT_DONE_FIELD] = r0;
842000c0:	40 02 27 d5 	M[r5 + 576] = r0;

842000c4 <$M.celt.encoder_init.dont_init_fft_tables_enc>:
dont_init_fft_tables_enc:
#endif 

   // restore preserved registers
   POP_ALL_C
842000c4:	00 f7 05 f1 	popm <M0, M1, M2, L0, L1, L4, L5>;
842000c8:	77 00 05 f1 	popm <I0, I1, I2, I4, I5, I6>;
842000cc:	c0 af 04 f1 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
   rts;
842000d0:	0f 00 0d dc 	rts;

842000d4 <$celt.encoder_frame_init>:
   
   $celt.encoder_frame_init:
   
   // push rLink onto stack

   push rlink;
842000d4:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODER_FRAME_INIT.PATCH_ID_0,r2)     // celt_patchers
#endif

   // set byte-pos values
   r0 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
842000d8:	a4 00 27 d1 	r0 = M[r5 + 164];
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
842000dc:	e8 01 27 d5 	M[r5 + 488] = r0;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
842000e0:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
842000e4:	03 00 00 fd 	call (m) 0x3a2b0;
842000e8:	b1 a2 f0 e1 
   push r2;
842000ec:	00 00 40 f3 	push r2;
   pop  B0;
842000f0:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_write_address_and_size;
#endif 
   I0 = r0;
842000f4:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
842000f8:	3f 00 c0 50 	L0 = Null + r1;
   
   // get the frame length in bytes
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
842000fc:	00 00 a7 d1 	r8 = M[r5 + 0];
   r0 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84200100:	04 00 27 d1 	r0 = M[r5 + 4];
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
84200104:	ec 01 27 d5 	M[r5 + 492] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
84200108:	f4 01 27 d5 	M[r5 + 500] = r0;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
8420010c:	e8 01 37 d1 	r1 = M[r5 + 488];
   r1 = r0 + r1;
84200110:	3f 00 32 00 	r1 = r0 + r1;
   r1 = r1 AND $celt.BYTE_POS_MAX_VALUE;
84200114:	03 00 33 81 	r1 = r1 AND 0x3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r1;
84200118:	f0 01 37 d5 	M[r5 + 496] = r1;
   
   //I1/L1 -> must point to end of buffer
   I1 = I0;
8420011c:	0f 00 10 58 	I1 = I0 + Null;
   L1 = L0;
84200120:	0f 00 dc 58 	L1 = L0 + Null;
#ifdef BASE_REGISTER_MODE   
   push B0;
84200124:	00 00 a2 f3 	push B0;
   pop B1;
84200128:	00 00 b6 f3 	pop B1;
#endif 
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
8420012c:	f0 01 37 d1 	r1 = M[r5 + 496];
#ifdef DATAFORMAT_32
   r1 = $celt.BYTE_POS_MAX_VALUE - r1;
84200130:	03 00 33 65 	r1 = 3 - r1;
#endif
   r0 = r0 + r1;
84200134:	00 00 23 03 	r0 = r0 + r1;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
84200138:	e8 01 37 d1 	r1 = M[r5 + 488];
   r0 = r0 - r1;
8420013c:	00 00 23 23 	r0 = r0 - r1;
   r0 = r0 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
84200140:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   Words2Addr(r0);
84200144:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
84200148:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I1, M0];
8420014c:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   
   // initialise entropy decoder
   call $celt.ec_enc_init;
84200150:	b5 03 f0 e1 	call $celt.ec_enc_init;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200154:	03 00 00 fd 	jump (m) 0x3b020;
84200158:	21 b0 f0 dd 

8420015c <$_celt_free_decoder_twiddle>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.FREE_DECODER_TWIDDLE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // Save the registers C expects us to preserve that get trashed
   pushm <r5, r9, rLink>;
8420015c:	80 28 00 f1 	pushm <r5, r9, rLink>;
   push I0;
84200160:	00 00 01 f3 	push I0;
   r0 = $celt.FFT_TWIDDLE_SIZE;
84200164:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.release;
84200168:	07 00 00 fd 	call 0x74ff8;
8420016c:	f8 4f f0 e1 

   // restore preserved registers
   pop I0;
84200170:	00 00 05 f3 	pop I0;
   popm <r5, r9, rLink>;
84200174:	80 28 04 f1 	popm <r5, r9, rLink>;

   rts;
84200178:	0f 00 0d dc 	rts;

8420017c <$_celt_frame_encode>:
8420017c:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
   push rlink;
   
   //-- Is re-init required?
   push r5;
84200180:	00 00 70 f3 	push r5;
   r9 = r5;
84200184:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200188:	10 00 77 d1 	r5 = M[r5 + 16];
   Null = M[r5 + $celt.enc.REINIT_ENCODER_FIELD];
8420018c:	14 00 07 d1 	Null = M[r5 + 20];
   if Z jump no_reinit;
84200190:	04 00 00 dd 	if EQ jump $M.celt.frame_encode.no_reinit;
      r5 = r9;
84200194:	0f 00 7b 00 	r5 = r9 + Null;
      call $celt.encoder_init;
84200198:	9a ff f0 e1 	call $celt.encoder_init;
      r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
8420019c:	10 00 77 d1 	r5 = M[r5 + 16];

842001a0 <$M.celt.frame_encode.no_reinit>:
   no_reinit:
   
 #ifdef KYMERA 
   r1 = M[r5 + $celt.enc.PTR_MODE_DM1SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm1scratch_alloc;
842001a0:	28 02 37 d1 	r1 = M[r5 + 552];
   r2 = M[r5 + $celt.enc.PTR_celt_dm1_scratch];//&$celt_dm1_scratch;
842001a4:	30 02 47 d1 	r2 = M[r5 + 560];
   r3 = M[r5 + $celt.enc.PTR_MODE_DM2SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm2scratch_alloc; 
842001a8:	2c 02 57 d1 	r3 = M[r5 + 556];
   r4 = M[r5 + $celt.enc.PTR_celt_dm2_scratch];//&$celt_dm2_scratch;
842001ac:	34 02 67 d1 	r4 = M[r5 + 564];
   call $celt.alloc_scratch_mem;
842001b0:	79 0b f0 e1 	call $celt.alloc_scratch_mem;
 #endif 
 
   // -- Save codec struct pointer --
   M[r5 + $celt.enc.SCRATCHVAR_CODEC_STRUC] = r5;
842001b4:	74 01 77 d5 	M[r5 + 372] = r5;
   // -- See if there is enough input data
   r4 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
842001b8:	44 00 67 d1 	r4 = M[r5 + 68];
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
842001bc:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
842001c0:	03 00 00 fd 	call (m) 0x39dd4;
842001c4:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
   Null = r0 - r4;
842001c8:	6f 00 02 20 	Null = r0 - r4;
   if NEG jump exit_not_enough_input_data;
842001cc:	83 00 40 dd 	if NEG jump $M.celt.frame_encode.exit_not_enough_input_data;
   r0 = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
842001d0:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_data_check;
842001d4:	05 00 00 dd 	if EQ jump $M.celt.frame_encode.end_data_check;
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
842001d8:	03 00 00 fd 	call (m) 0x39dd4;
842001dc:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
      Null = r0 - r4;
842001e0:	6f 00 02 20 	Null = r0 - r4;
      if NEG jump exit_not_enough_input_data;
842001e4:	7d 00 40 dd 	if NEG jump $M.celt.frame_encode.exit_not_enough_input_data;

842001e8 <$M.celt.frame_encode.end_data_check>:
   end_data_check:
   
   // save output buffer addresses
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
842001e8:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
842001ec:	03 00 00 fd 	call (m) 0x3a27a;
842001f0:	7b a2 f0 e1 
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR] = r2;
842001f4:	84 01 47 d5 	M[r5 + 388] = r2;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR] = r0;
842001f8:	7c 01 27 d5 	M[r5 + 380] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN] = r1;
842001fc:	80 01 37 d5 	M[r5 + 384] = r1;
   r0 =  M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
84200200:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_save;
84200204:	06 00 00 dd 	if EQ jump $M.celt.frame_encode.end_ch_addr_save;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
84200208:	03 00 00 fd 	call (m) 0x3a27a;
8420020c:	7b a2 f0 e1 
   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR] = r2;
84200210:	90 01 47 d5 	M[r5 + 400] = r2;
#else
   call $cbuffer.get_read_address_and_size;
#endif

   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR] = r0;
84200214:	88 01 27 d5 	M[r5 + 392] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN] = r1;
84200218:	8c 01 37 d5 	M[r5 + 396] = r1;

8420021c <$M.celt.frame_encode.end_ch_addr_save>:
   end_ch_addr_save:

   //-- See if there is at least one frame output space 
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
8420021c:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
84200220:	03 00 00 fd 	call (m) 0x39d88;
84200224:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
#ifdef DATAFORMAT_32
   r0 = r0 LSHIFT LOG2_ADDR_PER_WORD;
84200228:	02 00 22 8d 	r0 = r0 LSHIFT 2;
#else
   r0 = r0 + r0;
#endif
   r1 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
8420022c:	a4 00 37 d1 	r1 = M[r5 + 164];
   r2 = r0 + r1;
84200230:	3f 00 42 00 	r2 = r0 + r1;
   r2 = r2 - 1;
84200234:	3f 00 44 e4 	r2 = r2 - 1;
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84200238:	04 00 37 d1 	r1 = M[r5 + 4];
   r0 = $codec.NOT_ENOUGH_OUTPUT_SPACE;
8420023c:	af 00 20 e4 	r0 = Null + 2;
   Null = r2 - r1;
84200240:	3f 00 04 20 	Null = r2 - r1;
   if NEG jump exit;
84200244:	66 00 40 dd 	if NEG jump $M.celt.frame_encode.exit;

   // -- stereo to mono --
   // Please note right channel signal is mixed into left channel signal. 
   // The mono output signal will be a mixed signal of left and right channels. 
   r0 = 1;
84200248:	2f 00 20 e4 	r0 = Null + 1;
   Null = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
8420024c:	08 00 0b d1 	Null = M[r9 + 8];
   if Z r0 = 0;
84200250:	00 00 20 00 	if EQ r0 = Null + Null;
   r1 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200254:	08 00 37 d1 	r1 = M[r5 + 8];
   r2 = r1 XOR r0; 
84200258:	2f 00 43 88 	r2 = r1 XOR r0;
   r0 = r0 AND r2;
8420025c:	00 00 24 83 	r0 = r0 AND r2;
   M[r5 + $celt.enc.SCRATCHVAR_STEREO_TO_MONO] = r0;
84200260:	78 01 27 d5 	M[r5 + 376] = r0;
   
   if Z jump end_stereo_to_mono_convert;
84200264:	22 00 00 dd 	if EQ jump $M.celt.frame_encode.end_stereo_to_mono_convert;
      r10 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84200268:	44 00 c7 d1 	r10 = M[r5 + 68];
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR];
8420026c:	7c 01 27 d1 	r0 = M[r5 + 380];
      I4 = r0;
84200270:	2f 00 40 50 	I4 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN];
84200274:	80 01 27 d1 	r0 = M[r5 + 384];
      L4 = r0;
84200278:	2f 00 e0 50 	L4 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR];
8420027c:	88 01 27 d1 	r0 = M[r5 + 392];
      I5 = r0;
84200280:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN];
84200284:	8c 01 27 d1 	r0 = M[r5 + 396];
      L5 = r0;
84200288:	2f 00 f0 50 	L5 = Null + r0;
#ifdef BASE_REGISTER_MODE  
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR];
8420028c:	84 01 27 d1 	r0 = M[r5 + 388];
      push r0; 
84200290:	00 00 20 f3 	push r0;
      pop B4;
84200294:	00 00 c6 f3 	pop B4;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR];
84200298:	90 01 27 d1 	r0 = M[r5 + 400];
      push r0;
8420029c:	00 00 20 f3 	push r0;
      pop B5; 
842002a0:	00 00 d6 f3 	pop B5;
#endif       
      r2 = 0.5;
842002a4:	00 40 00 fd 	r2 = Null + 1073741824;
842002a8:	00 00 40 01 
      r10 = r10 - 1;
842002ac:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[I5, MK1];
842002b0:	25 00 00 03 	Null = Null + Null, r0 = M[I5,4];
      rMAC = r0 * r2;
842002b4:	4f 00 12 cc 	rMAC = r0 * r2 (SS);
      do stereo_to_mono_loop;
842002b8:	04 00 f0 e5 	do $M.celt.frame_encode.stereo_to_mono_loop;
         r0 = M[I4, 0];
842002bc:	20 00 00 03 	Null = Null + Null, r0 = M[I4,0];
         rMAC = rMAC + r0 * r2, r0 = M[I5, MK1];
842002c0:	25 00 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I5,4];
         rMAC = r0 * r2, M[I4, MK1] = rMAC;
842002c4:	91 00 24 cf 	rMAC = r0 * r2 (SS), M[I4,4] = rMAC;

842002c8 <$M.celt.frame_encode.stereo_to_mono_loop>:
      stereo_to_mono_loop:
      r0 = M[I4, 0];
842002c8:	20 00 00 03 	Null = Null + Null, r0 = M[I4,0];
      rMAC = rMAC + r0 * r2;
842002cc:	4f 00 12 ac 	rMAC = rMAC + r0 * r2 (SS);
      M[I4, MK1] = rMAC;    
842002d0:	91 00 00 03 	Null = Null + Null, M[I4,4] = rMAC;
      L5 = 0;
842002d4:	00 00 f0 51 	L5 = Null + 0;
      L4 = 0;
842002d8:	00 00 e0 51 	L4 = Null + 0;
      
#ifdef BASE_REGISTER_MODE 
      push Null; 
842002dc:	00 00 00 f3 	push Null;
      pop B4;
842002e0:	00 00 c6 f3 	pop B4;
      push Null; 
842002e4:	00 00 00 f3 	push Null;
      pop B5; 
842002e8:	00 00 d6 f3 	pop B5;

842002ec <$M.celt.frame_encode.end_stereo_to_mono_convert>:
#endif
      
   end_stereo_to_mono_convert:
   
   push r9;
842002ec:	00 00 b0 f3 	push r9;

   // -- Preemphasis
   call $celt.preemphasis;
842002f0:	14 02 f0 e1 	call $celt.preemphasis;
   
  // --
  call  $celt.transient_analysis;
842002f4:	84 04 f0 e1 	call $celt.transient_analysis;


   // -- Windowing and MDCT
   call $celt.mdct_analysis;
842002f8:	3d 00 f0 e1 	call $celt.mdct_analysis;
    
   // -- Bands processing
   call $celt.bands_process;
842002fc:	32 0a f0 e1 	call $celt.bands_process;

   pop r9;
84200300:	00 00 b4 f3 	pop r9;
   
   // -- Initialise frame encoder
   call $celt.encoder_frame_init;
84200304:	74 ff f0 e1 	call $celt.encoder_frame_init;


   // -- update output buffer addresses
   r0 =  M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
84200308:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
8420030c:	03 00 00 fd 	call (m) 0x3a27a;
84200310:	7b a2 f0 e1 
   push r2;
84200314:	00 00 40 f3 	push r2;
   pop  B4;
84200318:	00 00 c6 f3 	pop B4;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   r4 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
8420031c:	44 00 67 d1 	r4 = M[r5 + 68];
   I4 = r0;
84200320:	2f 00 40 50 	I4 = Null + r0;
   L4 = r1;
84200324:	3f 00 e0 50 	L4 = Null + r1;
   Words2Addr(r4);
84200328:	02 00 66 91 	r4 = r4 ASHIFT 2;
   M0 = r4;
8420032c:	6f 00 80 50 	M0 = Null + r4;
   r0 = M[I4, M0];
84200330:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
   r1 = I4;
84200334:	4f 00 30 44 	r1 = Null + I4;
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
84200338:	04 00 2b d1 	r0 = M[r9 + 4];
   call $cbuffer.set_read_address;
8420033c:	03 00 00 fd 	call (m) 0x3a2e6;
84200340:	e7 a2 f0 e1 
   
   // -- see if right buffer is enabled
   r0 =  M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
84200344:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_update;
84200348:	0c 00 00 dd 	if EQ jump $M.celt.frame_encode.end_ch_addr_update;
#ifdef BASE_REGISTER_MODE
    call $cbuffer.get_read_address_and_size_and_start_address;
8420034c:	03 00 00 fd 	call (m) 0x3a27a;
84200350:	7b a2 f0 e1 
    push r2;
84200354:	00 00 40 f3 	push r2;
    pop  B4;
84200358:	00 00 c6 f3 	pop B4;
#else  
    call $cbuffer.get_read_address_and_size;
#endif
    I4 = r0;
8420035c:	2f 00 40 50 	I4 = Null + r0;
    L4 = r1;
84200360:	3f 00 e0 50 	L4 = Null + r1;
    r0 = M[I4, M0];
84200364:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
    r1 = I4;
84200368:	4f 00 30 44 	r1 = Null + I4;
    r0 = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
8420036c:	08 00 2b d1 	r0 = M[r9 + 8];
    call $cbuffer.set_read_address;
84200370:	03 00 00 fd 	call (m) 0x3a2e6;
84200374:	e7 a2 f0 e1 

84200378 <$M.celt.frame_encode.end_ch_addr_update>:
 end_ch_addr_update:
    L4 = 0;
84200378:	00 00 e0 51 	L4 = Null + 0;
 #ifdef BASE_REGISTER_MODE
    push Null;
8420037c:	00 00 00 f3 	push Null;
    pop  B4;
84200380:	00 00 c6 f3 	pop B4;
#endif

   push r9;
84200384:	00 00 b0 f3 	push r9;
  
   // -- encode flags
   r0 = $celt.FLAG_INTRA;
84200388:	00 20 20 01 	r0 = Null + 8192;
   M[r5 + $celt.enc.INTRA_ENER_FIELD] = r0;
8420038c:	54 01 27 d5 	M[r5 + 340] = r0;
   M[r5 + $celt.enc.HAS_PITCH_FIELD] = Null;
84200390:	5c 01 07 d5 	M[r5 + 348] = Null;
   //M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = Null;
   r0 = $celt.FLAG_FOLD;
84200394:	00 04 20 01 	r0 = Null + 1024;
   M[r5 + $celt.enc.HAS_FOLD_FIELD] = r0;
84200398:	60 01 27 d5 	M[r5 + 352] = r0;
   
   // -- more transient processing for short blocks
   Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
8420039c:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ call $celt.transient_block_process;
842003a0:	01 05 10 e1 	if NE call $celt.transient_block_process;
   
   
   call $celt.encode_flags;
842003a4:	0d 0b f0 e1 	call $celt.encode_flags;
   
   // -- quant coarse energy
   call $celt.quant_coarse_energy;
842003a8:	21 02 f0 e1 	call $celt.quant_coarse_energy;
  
   // -- Compute bit allocations
   call $celt.compute_allocation;
842003ac:	2e 0a f0 e1 	call $celt.compute_allocation;
   
   // -- Encode fine energy bits
   call $celt.quant_fine_energy;
842003b0:	87 02 f0 e1 	call $celt.quant_fine_energy;

   // -- Quantise residual bits 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
842003b4:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z call $celt.quant_bands;
842003b8:	2f 05 00 e1 	if EQ call $celt.quant_bands;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
842003bc:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ call $celt.quant_bands_stereo;
842003c0:	a8 05 10 e1 	if NE call $celt.quant_bands_stereo;
   
   // -- Finalize energy quantization
   call $celt.quant_energy_finalise;
842003c4:	b6 02 f0 e1 	call $celt.quant_energy_finalise;
   
   pop r9;
842003c8:	00 00 b4 f3 	pop r9;
   // -- Complete final steps in encoding frame
   //    this also updates output buffer pointers
   call $celt.end_writing_frame;
842003cc:	ef 03 f0 e1 	call $celt.end_writing_frame;
   
   // -- Encoding Successful!
   r0 = $codec.SUCCESS;
842003d0:	00 00 20 01 	r0 = Null + 0;
   jump exit;
842003d4:	02 00 f0 dd 	jump $M.celt.frame_encode.exit;

842003d8 <$M.celt.frame_encode.exit_not_enough_input_data>:
   
   exit_not_enough_input_data:
   // set NOT_ENOUGH_OUTPUT_SPACE flag and exit
   r0 = $codec.NOT_ENOUGH_INPUT_DATA;
842003d8:	2f 00 20 e4 	r0 = Null + 1;

842003dc <$M.celt.frame_encode.exit>:
   
   exit:
   M[r9 + $codec.ENCODER_MODE_FIELD] = r0;
842003dc:	0c 00 2b d5 	M[r9 + 12] = r0;

   pop r5;
842003e0:	00 00 74 f3 	pop r5;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842003e4:	03 00 00 fd 	jump (m) 0x3b020;
842003e8:	21 b0 f0 dd 

842003ec <$celt.mdct_analysis>:
842003ec:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST CH_OUT_BUF           (1 + 2)*ADDR_PER_WORD;
   .CONST CH_COUNTER           (2 + 2)*ADDR_PER_WORD;;
   .CONST BLOCK_COUNTER        (3 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842003f0:	10 00 03 f1 	SP = SP + 16;

   
   M[FP + CH_COUNTER] = Null;
842003f4:	10 00 0c f1 	M[FP + 0x10] = Null;
   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
842003f8:	d8 00 27 d1 	r0 = M[r5 + 216];
   M[FP + CH_INP_BUF] = r0;
842003fc:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
84200400:	14 01 27 d1 	r0 = M[r5 + 276];
   M[FP + CH_OUT_BUF] = r0;
84200404:	0c 00 2c f1 	M[FP + 0xc] = r0;

84200408 <$M.celt.mdct_analysis.chan_process>:
   chan_process:
   
      // -- scale the input if needed
      call scale_in;
84200408:	58 00 f0 e1 	call $M.celt.mdct_analysis.scale_in;

      // -- different procedure for short blocks
      Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
8420040c:	58 01 07 d1 	Null = M[r5 + 344];
      if NZ jump short_proc;   
84200410:	17 00 10 dd 	if NE jump $M.celt.mdct_analysis.short_proc;
   
      // -- Window and reshuffle for MDCT 
      r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84200414:	20 01 27 d1 	r0 = M[r5 + 288];
      I6 = r0;
84200418:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
8420041c:	d4 00 27 d1 	r0 = M[r5 + 212];
      I7 = r0;
84200420:	2f 00 70 50 	I7 = Null + r0;
      r8 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84200424:	44 00 a7 d1 	r8 = M[r5 + 68];
      r0 = M[FP + CH_INP_BUF];
84200428:	08 00 28 f1 	r0 = M[FP + 0x8];
      I0 = r0;
8420042c:	2f 00 00 50 	I0 = Null + r0;
      call $celt.window_reshuffle;
84200430:	4a 09 f0 e1 	call $celt.window_reshuffle;
  
      // -- MDCT spectrum analysis
      r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84200434:	20 01 27 d1 	r0 = M[r5 + 288];
      I6 = r0;
84200438:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
8420043c:	d4 00 27 d1 	r0 = M[r5 + 212];
      I7 = r0;
84200440:	2f 00 70 50 	I7 = Null + r0;
      r8 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD]; //N2
84200444:	44 00 a7 d1 	r8 = M[r5 + 68];
      r0 = M[FP + CH_OUT_BUF];
84200448:	0c 00 28 f1 	r0 = M[FP + 0xc];
      I0 = r0;    
8420044c:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[FP + CH_COUNTER];
84200450:	10 00 28 f1 	r0 = M[FP + 0x10];
      Words2Addr(r0);
84200454:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r5;
84200458:	00 00 27 03 	r0 = r0 + r5;
      r4 = M[r0 + $celt.enc.MAX_SBAND];
8420045c:	f8 01 62 d1 	r4 = M[r0 + 504];
      r0 = M[r5 + $celt.enc.MDCT_FUNCTION_FIELD];
84200460:	0c 00 27 d1 	r0 = M[r5 + 12];
      call r0;
84200464:	0f 00 02 e0 	call r0;
      jump ch_end;
84200468:	35 00 f0 dd 	jump $M.celt.mdct_analysis.ch_end;

8420046c <$M.celt.mdct_analysis.short_proc>:
   
      short_proc:
      // -- short block mdct analysis
      r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
8420046c:	58 00 27 d1 	r0 = M[r5 + 88];
      r0 = r0 - 1;
84200470:	3f 00 22 e4 	r0 = r0 - 1;
      M[FP + BLOCK_COUNTER] = r0;
84200474:	14 00 2c f1 	M[FP + 0x14] = r0;

84200478 <$M.celt.mdct_analysis.block_loop>:
      block_loop:
         // -- Window and reshuffle for MDCT 
         r1 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84200478:	20 01 37 d1 	r1 = M[r5 + 288];
         I6 = r1;
8420047c:	3f 00 60 50 	I6 = Null + r1;
         r1 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
84200480:	d4 00 37 d1 	r1 = M[r5 + 212];
         I7 = r1;
84200484:	3f 00 70 50 	I7 = Null + r1;
         r8 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
84200488:	5c 00 a7 d1 	r8 = M[r5 + 92];
         r1 = M[FP + CH_INP_BUF];
8420048c:	08 00 38 f1 	r1 = M[FP + 0x8];
         r0 = r0 * r8 (int);
84200490:	00 00 2a 9b 	r0 = r0 * r8 (int);
         Words2Addr(r0);
84200494:	02 00 22 91 	r0 = r0 ASHIFT 2;
         I0 = r1 + r0; 
84200498:	2f 00 03 50 	I0 = r1 + r0;
         call $celt.window_reshuffle;      
8420049c:	2f 09 f0 e1 	call $celt.window_reshuffle;
      
         // -- MDCT spectrum analysis
         r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
842004a0:	20 01 27 d1 	r0 = M[r5 + 288];
         I6 = r0;
842004a4:	2f 00 60 50 	I6 = Null + r0;
         r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
842004a8:	d4 00 27 d1 	r0 = M[r5 + 212];
         I7 = r0;
842004ac:	2f 00 70 50 	I7 = Null + r0;
         r8 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
842004b0:	5c 00 a7 d1 	r8 = M[r5 + 92];
         r0 = M[r5 + $celt.enc.SHORT_FREQ_FIELD];
842004b4:	1c 01 27 d1 	r0 = M[r5 + 284];
         r1 = M[FP + BLOCK_COUNTER];
842004b8:	14 00 38 f1 	r1 = M[FP + 0x14];
         r1 = r1 * r8 (int);
842004bc:	00 00 3a 9b 	r1 = r1 * r8 (int);
         Words2Addr(r1);
842004c0:	02 00 33 91 	r1 = r1 ASHIFT 2;
         I0 = r0 + r1;     
842004c4:	3f 00 02 50 	I0 = r0 + r1;
         r0 = M[FP + CH_COUNTER];
842004c8:	10 00 28 f1 	r0 = M[FP + 0x10];
         Words2Addr(r0);
842004cc:	02 00 22 91 	r0 = r0 ASHIFT 2;
         r0 = r0 + r5;
842004d0:	00 00 27 03 	r0 = r0 + r5;
         r4 = M[r0 + $celt.enc.MAX_SBAND];
842004d4:	f8 01 62 d1 	r4 = M[r0 + 504];
         r0 = M[r5 + $celt.enc.MDCT_SHORT_FUNCTION_FIELD];
842004d8:	10 00 27 d1 	r0 = M[r5 + 16];
         call r0;
842004dc:	0f 00 02 e0 	call r0;
         r0 = M[FP + BLOCK_COUNTER];
842004e0:	14 00 28 f1 	r0 = M[FP + 0x14];
         r0 = r0 - 1;
842004e4:	3f 00 22 e4 	r0 = r0 - 1;
         M[FP + BLOCK_COUNTER] = r0;
842004e8:	14 00 2c f1 	M[FP + 0x14] = r0;
      if POS jump block_loop;
842004ec:	e3 ff 50 dd 	if POS jump $M.celt.mdct_analysis.block_loop;
   
      // -- interleaving
      // r4 = freq
      r4 = M[FP + CH_OUT_BUF];
842004f0:	0c 00 68 f1 	r4 = M[FP + 0xc];
      I0 = r4;   
842004f4:	6f 00 00 50 	I0 = Null + r4;
      r0 = M[r5 + $celt.enc.SHORT_FREQ_FIELD];
842004f8:	1c 01 27 d1 	r0 = M[r5 + 284];
      I4 = r0;
842004fc:	2f 00 40 50 	I4 = Null + r0;
      r6 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
84200500:	58 00 87 d1 	r6 = M[r5 + 88];
      Words2Addr(r6);
84200504:	02 00 88 91 	r6 = r6 ASHIFT 2;
      M1 = r6;
84200508:	8f 00 90 50 	M1 = Null + r6;
      Addr2Words(r6);
8420050c:	fe 00 88 91 	r6 = r6 ASHIFT -2;
      M2 = 1 * ADDR_PER_WORD;
84200510:	04 00 a0 51 	M2 = Null + 4;
      M3 = 1;
84200514:	01 00 b0 51 	M3 = Null + 1;

84200518 <$M.celt.mdct_analysis.shortf_outer_loop>:
      shortf_outer_loop:
         r10 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
84200518:	5c 00 c7 d1 	r10 = M[r5 + 92];
         r10 = r10 - M3, r0 = M[I4, M2];
8420051c:	22 00 cb 66 	r10 = r10 - M3, r0 = M[I4,M2];
         r4 = r4 + ADDR_PER_WORD;
84200520:	bf 00 66 e4 	r4 = r4 + 4;
         do shortf_inner_loop;
84200524:	02 00 f0 e5 	do $M.celt.mdct_analysis.shortf_inner_loop;
            r0 = M[I4, M2], M[I0, M1] = r0; 
84200528:	22 a1 00 02 	Null = Null + Null, M[I0,M1] = r0, r0 = M[I4,M2];

8420052c <$M.celt.mdct_analysis.shortf_inner_loop>:
         shortf_inner_loop:
         M[I0, M1] = r0;
8420052c:	00 a1 00 02 	Null = Null + Null, M[I0,M1] = r0;
         I0 = r4;
84200530:	6f 00 00 50 	I0 = Null + r4;
         r6 = r6 - 1;
84200534:	3f 00 88 e4 	r6 = r6 - 1;
      if NZ jump shortf_outer_loop;
84200538:	f8 ff 10 dd 	if NE jump $M.celt.mdct_analysis.shortf_outer_loop;

8420053c <$M.celt.mdct_analysis.ch_end>:
      ch_end:
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
8420053c:	08 00 27 d1 	r0 = M[r5 + 8];
      r1 = M[FP + CH_COUNTER];
84200540:	10 00 38 f1 	r1 = M[FP + 0x10];
      r1 = r1 + 1;
84200544:	2f 00 33 e4 	r1 = r1 + 1;
      M[FP + CH_COUNTER] = r1;
84200548:	10 00 3c f1 	M[FP + 0x10] = r1;
      Null = r0 - r1;
8420054c:	3f 00 02 20 	Null = r0 - r1;
      if NEG jump cleanup_and_exit;
84200550:	19 00 40 dd 	if NEG jump $M.celt.mdct_analysis.cleanup_and_exit;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84200554:	24 01 27 d1 	r0 = M[r5 + 292];
      M[FP + CH_INP_BUF] = r0;
84200558:	08 00 2c f1 	M[FP + 0x8] = r0;
      r0 = M[r5 + $celt.enc.FREQ2_FIELD];
8420055c:	18 01 27 d1 	r0 = M[r5 + 280];
      M[FP + CH_OUT_BUF] = r0;
84200560:	0c 00 2c f1 	M[FP + 0xc] = r0;
   jump chan_process;
84200564:	a9 ff f0 dd 	jump $M.celt.mdct_analysis.chan_process;

84200568 <$M.celt.mdct_analysis.scale_in>:

   scale_in:
   // -- scale in the input in order to get the best result from fft module
   // Negative scale factors will be compensated in mdct analysis
   r0 = M[FP + CH_COUNTER];
84200568:	10 00 28 f1 	r0 = M[FP + 0x10];
   Words2Addr(r0);
8420056c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r0 = r0 + r5;
84200570:	00 00 27 03 	r0 = r0 + r5;
   r2 = M[r0 + $celt.enc.MAX_SBAND];
84200574:	f8 01 42 d1 	r2 = M[r0 + 504];
   if LE rts;
84200578:	0d 00 0d dc 	if LE rts;
   
   r3 = M[FP + CH_INP_BUF];
8420057c:	08 00 58 f1 	r3 = M[FP + 0x8];
   I0 = r3;
84200580:	5f 00 00 50 	I0 = Null + r3;
   r4 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84200584:	40 00 67 d1 	r4 = M[r5 + 64];
   r0 =  M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84200588:	44 00 27 d1 	r0 = M[r5 + 68];
   r10 = r4 + r0;
8420058c:	2f 00 c6 00 	r10 = r4 + r0;
   M0 = 1 * ADDR_PER_WORD;
84200590:	04 00 80 51 	M0 = Null + 4;
   r10 = r10 - 1;
84200594:	3f 00 cc e4 	r10 = r10 - 1;
   I1 = r3 , r0 = M[I0, M0];
84200598:	5f 20 10 50 	I1 = Null + r3, r0 = M[I0,M0];
   do scale_in_loop;
8420059c:	03 00 f0 e5 	do $M.celt.mdct_analysis.scale_in_loop;
      r1 = r0 ASHIFT r2, r0 = M[I0, M0];
842005a0:	4f 20 32 90 	r1 = r0 ASHIFT r2, r0 = M[I0,M0];
      M[I1, M0] = r1;
842005a4:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;

842005a8 <$M.celt.mdct_analysis.scale_in_loop>:
   scale_in_loop:
   r1 = r0 ASHIFT r2;
842005a8:	4f 00 32 90 	r1 = r0 ASHIFT r2;
   M[I1, M0] = r1;
842005ac:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   rts;
842005b0:	0f 00 0d dc 	rts;

842005b4 <$M.celt.mdct_analysis.cleanup_and_exit>:
cleanup_and_exit:   
   SP = SP - STACK_FRAME_SIZE;
842005b4:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
842005b8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842005bc:	0f 00 0d dc 	rts;

842005c0 <$_celt_mdct_radix2>:
842005c0:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST SCALE_FACTOR         (0 + 2)*ADDR_PER_WORD;
   .CONST TEMP                 (1 + 2)*ADDR_PER_WORD;
   .CONST TMP_VAR              (7 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     8*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842005c4:	20 00 03 f1 	SP = SP + 32;


   M[FP + TEMP + 0* ADDR_PER_WORD] = r8;
842005c8:	0c 00 ac f1 	M[FP + 0xc] = r8;
   r0 = I6;
842005cc:	6f 00 20 44 	r0 = Null + I6;
   M[FP + TEMP + 1* ADDR_PER_WORD] = r0;
842005d0:	10 00 2c f1 	M[FP + 0x10] = r0;
   r0 = I7;
842005d4:	7f 00 20 44 	r0 = Null + I7;
   M[FP + TEMP + 2* ADDR_PER_WORD] = r0;
842005d8:	14 00 2c f1 	M[FP + 0x14] = r0;
   r0 = I0;
842005dc:	0f 00 20 44 	r0 = Null + I0;
 #ifdef BASE_REGISTER_MODE
   push r0;
842005e0:	00 00 20 f3 	push r0;
   pop B0;
842005e4:	00 00 a6 f3 	pop B0;
#endif
   M[FP + TEMP + 3* ADDR_PER_WORD] = r0; 
842005e8:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 5* ADDR_PER_WORD] = r5;
842005ec:	20 00 7c f1 	M[FP + 0x20] = r5;
   
   
  
   // get scale factor from mode object
   r0 = M[r5 + $celt.enc.MODE_TRIG_OFFSET_FIELD];
842005f0:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = &$celt.mode.TRIG_VECTOR_SIZE;
842005f4:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
842005f8:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
842005fc:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
84200600:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84200604:	3f 00 22 50 	I2 = r0 + r1;
   r0 = r0 + r1;
84200608:	00 00 23 03 	r0 = r0 + r1;
   M[FP + TEMP + 4* ADDR_PER_WORD] = r0; 
8420060c:	1c 00 2c f1 	M[FP + 0x1c] = r0;
   r0 = M[I2, MK1];
84200610:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   r0 = M[I2, MK1];
84200614:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   M[FP + SCALE_FACTOR] = r0;
84200618:	08 00 2c f1 	M[FP + 0x8] = r0;

   r2 = r8 LSHIFT -1;
8420061c:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.NUM_POINTS_FIELD] = r2;
84200620:	94 01 47 d5 	M[r5 + 404] = r2;
   r1 = I6;
84200624:	6f 00 30 44 	r1 = Null + I6;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.REAL_ADDR_FIELD] = r1;
84200628:	98 01 37 d5 	M[r5 + 408] = r1;
   r1 = I7;
8420062c:	7f 00 30 44 	r1 = Null + I7;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.IMAG_ADDR_FIELD] = r1;
84200630:	9c 01 37 d5 	M[r5 + 412] = r1;



   // compensation for negative global scale factors
   rMAC = r4;
84200634:	0f 00 16 00 	rMAC = r4 + Null;
   if POS jump no_further_scale;
84200638:	0b 00 50 dd 	if POS jump $M.celt.mdct_radix2.no_further_scale;
      // get the size of fft (N)
      r2 = signdet r2;
8420063c:	0f 00 44 d8 	r2 = SIGNDET r2;
      r2 = (DAWTH-2) - r2;
84200640:	1e 00 44 65 	r2 = 30 - r2;
      
      // calc g = 2.0**(s / N)
      rMAC = rMAC ASHIFT -8 (56bit);
84200644:	f8 00 11 91 	rMAC = rMAC ASHIFT -8 (56bit);
      Div = rMAC / r2;
84200648:	00 00 14 d9 	Div = rMAC / r2;
      r0 = DivResult;      
8420064c:	01 00 20 d9 	r0 = DivResult;
      call $math.pow2_taylor;
84200650:	07 00 00 fd 	call 0x744b8;
84200654:	b8 44 f0 e1 
      
      // sf = sf * g
      r1 = M[FP + SCALE_FACTOR];
84200658:	08 00 38 f1 	r1 = M[FP + 0x8];
      r1 = r1 * r0 (frac);
8420065c:	00 00 32 97 	r1 = r1 * r0 (frac);
      M[FP + SCALE_FACTOR] = r1;
84200660:	08 00 3c f1 	M[FP + 0x8] = r1;

84200664 <$M.celt.mdct_radix2.no_further_scale>:
   no_further_scale:
   
   push r5;
84200664:	00 00 70 f3 	push r5;
   M3 = 4;
84200668:	04 00 b0 51 	M3 = Null + 4;
   M0 = 1 * ADDR_PER_WORD;
8420066c:	04 00 80 51 	M0 = Null + 4;
   M1 = 0;
84200670:	00 00 90 51 	M1 = Null + 0;
   r2 = M[I2,M0];
84200674:	00 48 00 02 	Null = Null + Null, r2 = M[I2,M0];
   r3 = M[I2, M0];
84200678:	00 58 00 02 	Null = Null + Null, r3 = M[I2,M0];
   r4 = M[I2, M0], r0 = M[I6, M1];
8420067c:	29 68 00 02 	Null = Null + Null, r4 = M[I2,M0], r0 = M[I6,M1];
   r4 = - r4, r5 = M[I2, M0];
84200680:	6f 78 60 20 	r4 = Null - r4, r5 = M[I2,M0];
   r5 = - r5;
84200684:	7f 00 70 20 	r5 = Null - r5;
   r1 = FP + TMP_VAR;
84200688:	24 00 37 f1 	r1 = FP + 36;
   I1 = r1;
8420068c:	3f 00 10 50 	I1 = Null + r1;

84200690 <$M.celt.mdct_radix2.prerot_outer_loop>:
   prerot_outer_loop:
      r10 = r8 LSHIFT -3;
84200690:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do prerot_inner_loop;
84200694:	0a 00 f0 e5 	do $M.celt.mdct_radix2.prerot_inner_loop;
         rMAC = r0*r4,  r1 = M[I7, M1];
84200698:	3d 00 26 ce 	rMAC = r0 * r4 (SS), r1 = M[I7,M1];
         rMAC = rMAC + r5*r1;
8420069c:	3f 00 17 ac 	rMAC = rMAC + r5 * r1 (SS);
         rMAC = r1*r4, M[I6, M0] = rMAC;
842006a0:	98 00 36 ce 	rMAC = r1 * r4 (SS), M[I6,M0] = rMAC;
         rMAC = rMAC - r0*r5;
842006a4:	7f 00 12 bc 	rMAC = rMAC - r0 * r5 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I7, M0] = rMAC;      // (-c) * cfreq
842006a8:	9c 00 64 ce 	rMAC = r4 * r2 (SS), M[I7,M0] = rMAC;
         rMAC = rMAC - r5 * r3, r0 = M[I6, M1]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842006ac:	29 00 75 be 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I6,M1];
         rMAC = r4 * r3, M[I1,M1] = rMAC;       // (-c_old) * sfreq
842006b0:	5f 95 16 cc 	rMAC = r4 * r3 (SS), M[I1,M1] = rMAC;
         rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
842006b4:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I1,M1];              // r5 = (-s)'
842006b8:	0f 65 71 00 	r5 = rMAC + Null, r4 = M[I1,M1];

842006bc <$M.celt.mdct_radix2.prerot_inner_loop>:
      prerot_inner_loop:
      // load the constant points mid way to improve accuracy
      r4 = M[I2,M0];
842006bc:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
      r4 = -r4, r5 = M[I2,M0];
842006c0:	6f 78 60 20 	r4 = Null - r4, r5 = M[I2,M0];
      r5 = -r5;      
842006c4:	7f 00 70 20 	r5 = Null - r5;
      M3 = M3 - 1;
842006c8:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump prerot_outer_loop;
842006cc:	f1 ff 10 dd 	if NE jump $M.celt.mdct_radix2.prerot_outer_loop;
   
   pop r5;
842006d0:	00 00 74 f3 	pop r5;
#ifdef BASE_REGISTER_MODE
   push Null;
842006d4:	00 00 00 f3 	push Null;
   pop B0;
842006d8:	00 00 a6 f3 	pop B0;
#endif 
   // set up data in fft_structure
   I7 = r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT;
842006dc:	94 01 77 51 	I7 = r5 + 404;
   // -- call the ifft --
   r8 = M[FP + SCALE_FACTOR];
842006e0:	08 00 a8 f1 	r8 = M[FP + 0x8];
   //r8 = r8 * r8 (frac);
   call $math.scaleable_fft;
842006e4:	07 00 00 fd 	call 0x74be8;
842006e8:	e8 4b f0 e1 


   r8 = M[FP + TEMP + 0 * ADDR_PER_WORD];
842006ec:	0c 00 a8 f1 	r8 = M[FP + 0xc];
   r0 = M[FP + TEMP + 3 * ADDR_PER_WORD];  
842006f0:	18 00 28 f1 	r0 = M[FP + 0x18];
   I4 = r0;
842006f4:	2f 00 40 50 	I4 = Null + r0;
#ifdef BASE_REGISTER_MODE
    push B0;
842006f8:	00 00 a2 f3 	push B0;
	pop B4;
842006fc:	00 00 c6 f3 	pop B4;
    push B0;
84200700:	00 00 a2 f3 	push B0;
	pop B5;
84200704:	00 00 d6 f3 	pop B5;
#endif 
   Words2Addr(r8);
84200708:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I5 = I4 + r8;
8420070c:	af 00 54 58 	I5 = I4 + r8;
   Addr2Words(r8);
84200710:	fe 00 aa 91 	r8 = r8 ASHIFT -2;
   I5 = I5 - 1 * ADDR_PER_WORD;
84200714:	04 00 55 79 	I5 = I5 - 4;
      
   r0 = M[FP + TEMP + 4 * ADDR_PER_WORD];
84200718:	1c 00 28 f1 	r0 = M[FP + 0x1c];
   I7 = r0 + 2 * ADDR_PER_WORD;
8420071c:	08 00 72 51 	I7 = r0 + 8;

   // calculate some bit reverse constants
   r6 = SIGNDET r8; // perform the last memory write
84200720:	0f 00 8a d8 	r6 = SIGNDET r8;
   r6 = r6 + 2 - LOG2_ADDR_PER_WORD;                     
84200724:	00 00 88 01 	r6 = r6 + 0;
   r6 = 1 LSHIFT r6;
84200728:	01 00 88 e9 	r6 = 0x1 LSHIFT r6;
   M2 = r6;                         // bit reverse shift register
8420072c:	8f 00 a0 50 	M2 = Null + r6;
   r0 = M[FP + TEMP + 1 * ADDR_PER_WORD];
84200730:	10 00 28 f1 	r0 = M[FP + 0x10];
#ifdef BASE_REGISTER_MODE
    push r0;
84200734:	00 00 20 f3 	push r0;
	pop B0;
84200738:	00 00 a6 f3 	pop B0;
#endif 
   call $math.address_bitreverse;
8420073c:	07 00 00 fd 	call 0x748ec;
84200740:	ec 48 f0 e1 
   I0 = r1;
84200744:	3f 00 00 50 	I0 = Null + r1;
   r0 = M[FP + TEMP + 2 * ADDR_PER_WORD];
84200748:	14 00 28 f1 	r0 = M[FP + 0x14];
#ifdef BASE_REGISTER_MODE
    push r0;
8420074c:	00 00 20 f3 	push r0;
	pop B1;
84200750:	00 00 b6 f3 	pop B1;
#endif 
   call $math.address_bitreverse;
84200754:	07 00 00 fd 	call 0x748ec;
84200758:	ec 48 f0 e1 
   I1 = r1;
8420075c:	3f 00 10 50 	I1 = Null + r1;

 
   // data is returned bit reversed, so enable bit reverse addressing on AG1
   rFlags = rFlags OR $BR_FLAG;
84200760:	40 00 ee 85 	rFlags = rFlags OR 0x40;

   // load bit reversed tmp c location
   r0 = FP + TMP_VAR;
84200764:	24 00 27 f1 	r0 = FP + 36;
   call $math.address_bitreverse;
84200768:	07 00 00 fd 	call 0x748ec;
8420076c:	ec 48 f0 e1 
   I2 = r1;
84200770:	3f 00 20 50 	I2 = Null + r1;
   
   // postrot_outer_loop below needs to run 4 times but the last iteration 
   // causes misaligned memory access due to bit reverse addressing. To 
   // avoid this the loop is unrolled to execute the last iterration setparately
   // with this memory access removed.
   r6 = 4 - 1;
84200774:	03 00 80 01 	r6 = Null + 3;
   M3 = -2 * ADDR_PER_WORD;
84200778:	f8 ff b0 51 	M3 = Null + -8;
   M0 = 1 * ADDR_PER_WORD;
8420077c:	04 00 80 51 	M0 = Null + 4;
   M1 = 0;
84200780:	00 00 90 51 	M1 = Null + 0;
   r2 = M[I7,M0];
84200784:	4c 00 00 02 	Null = Null + Null, r2 = M[I7,M0];
   r3 = M[I7, M0];
84200788:	5c 00 00 02 	Null = Null + Null, r3 = M[I7,M0];
   r4 = M[I7, M0], r0 = M[I1, M2];
8420078c:	6c 26 00 02 	Null = Null + Null, r0 = M[I1,M2], r4 = M[I7,M0];
   r5 = M[I7, M0];
84200790:	7c 00 00 02 	Null = Null + Null, r5 = M[I7,M0];

84200794 <$M.celt.mdct_radix2.postrot_outer_loop>:
   postrot_outer_loop:
      M0 = 2 * ADDR_PER_WORD;
84200794:	08 00 80 51 	M0 = Null + 8;
      r10 = r8 LSHIFT -3;
84200798:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do postrot_inner_loop;
8420079c:	0a 00 f0 e5 	do $M.celt.mdct_radix2.postrot_inner_loop;
         rMAC = r0*r5,  r1 = M[I0, M2];
842007a0:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
         rMAC = rMAC + r4*r1;
842007a4:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
         rMAC = r1*r5, M[I4, M0] = rMAC;
842007a8:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
         rMAC = rMAC - r0*r4;
842007ac:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
842007b0:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
         rMAC = rMAC - r5 * r3, r0 = M[I1, M2]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842007b4:	5f 26 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I1,M2];
         rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
842007b8:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
         rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
842007bc:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
842007c0:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];

842007c4 <$M.celt.mdct_radix2.postrot_inner_loop>:
      postrot_inner_loop:
      // load the constant points mid way to improve accuracy
      M0 = 1 * ADDR_PER_WORD;
842007c4:	04 00 80 51 	M0 = Null + 4;
      r4 = M[I7, M0];
842007c8:	6c 00 00 02 	Null = Null + Null, r4 = M[I7,M0];
      r5 = M[I7,M0];
842007cc:	7c 00 00 02 	Null = Null + Null, r5 = M[I7,M0];
      r6 = r6 - 1;
842007d0:	3f 00 88 e4 	r6 = r6 - 1;
   if NZ jump postrot_outer_loop;
842007d4:	f0 ff 10 dd 	if NE jump $M.celt.mdct_radix2.postrot_outer_loop;

   // Run the last iteration of the outer loop with last iteration 
   // of its inner loop unrolled
    M0 = 2 * ADDR_PER_WORD;
842007d8:	08 00 80 51 	M0 = Null + 8;
    r10 = r8 LSHIFT -3;
842007dc:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
    r10 = r10 - 1;  // Avoid the last iteration
842007e0:	3f 00 cc e4 	r10 = r10 - 1;
    do postrot_inner_loop_2;
842007e4:	0a 00 f0 e5 	do $M.celt.mdct_radix2.postrot_inner_loop_2;
       rMAC = r0*r5,  r1 = M[I0, M2];
842007e8:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
       rMAC = rMAC + r4*r1;
842007ec:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
       rMAC = r1*r5, M[I4, M0] = rMAC;
842007f0:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
       rMAC = rMAC - r0*r4;
842007f4:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
         
       // update the multipliers: "c" and "s"
       rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
842007f8:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
       rMAC = rMAC - r5 * r3, r0 = M[I1, M2]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842007fc:	5f 26 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I1,M2];
       rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
84200800:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
       rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
84200804:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
       r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
84200808:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];

8420080c <$M.celt.mdct_radix2.postrot_inner_loop_2>:
    postrot_inner_loop_2:

    // Run the last iteration with bit reverse addressing removed
    rMAC = r0*r5,  r1 = M[I0, M2];
8420080c:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
    rMAC = rMAC + r4*r1;
84200810:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
    rMAC = r1*r5, M[I4, M0] = rMAC;
84200814:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
    rMAC = rMAC - r0*r4;
84200818:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
     
    // update the multipliers: "c" and "s"
    rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
8420081c:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
    rMAC = rMAC - r5 * r3;                 // (-c)'= (-c) * cfreq - (-s) * sfreq - avoid bit reverse addressing
84200820:	5f 00 17 bc 	rMAC = rMAC - r5 * r3 (SS);
    rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
84200824:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
    rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
84200828:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
    r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
8420082c:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];
   
#ifdef BASE_REGISTER_MODE
   push Null;
84200830:	00 00 00 f3 	push Null;
   pop  B4;
84200834:	00 00 c6 f3 	pop B4;
   push Null;
84200838:	00 00 00 f3 	push Null;
   pop  B0;
8420083c:	00 00 a6 f3 	pop B0;
   push Null;
84200840:	00 00 00 f3 	push Null;
   pop  B1;
84200844:	00 00 b6 f3 	pop B1;
   push Null;
84200848:	00 00 00 f3 	push Null;
   pop  B5;
8420084c:	00 00 d6 f3 	pop B5;
#endif
   rFlags = rFlags AND $NOT_BR_FLAG;
84200850:	bf ff ee 81 	rFlags = rFlags AND 0xffbf;
   
    r5 = M[FP + TEMP + 5 * ADDR_PER_WORD];
84200854:	20 00 78 f1 	r5 = M[FP + 0x20];
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84200858:	e0 ff 03 f1 	SP = SP + -32;
   popm <FP,rLink>;
8420085c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200860:	0f 00 0d dc 	rts;

84200864 <$celt.codec.init_tables>:
84200864:	00 00 d0 f3 	push rLink;

   $celt.codec.init_tables:

   // push rLink onto stack
   push rLink;
   push r4;
84200868:	00 00 60 f3 	push r4;
   r1 = r0;                 // mode
8420086c:	0f 00 32 00 	r1 = r0 + Null;
   r3 = $all_modes;
84200870:	70 00 00 fd 	r3 = Null + 7347316;
84200874:	74 1c 50 01 
   Words2Addr(r0);
84200878:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r3 = M[r3 + r0];         // index into the appropriate mode
8420087c:	00 00 52 d3 	r3 = M[r3 + r0];
   r4 = $all_modes_size;
84200880:	70 00 00 fd 	r4 = Null + 7347328;
84200884:	80 1c 60 01 
   r4 = M[r4 + r0];         // index into the appropriate mode size
84200888:	00 00 62 d3 	r4 = M[r4 + r0];

   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
8420088c:	00 00 a7 d1 	r8 = M[r5 + 0];
   r7 = r8;
84200890:	0f 00 9a 00 	r7 = r8 + Null;
   r0 = r8;
84200894:	0f 00 2a 00 	r0 = r8 + Null;
   r10 = M[r4 + 0*MK1];
84200898:	00 00 c6 d1 	r10 = M[r4 + 0];
   Words2Addr(r10);
8420089c:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842008a0:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842008a4:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
   r2 =  M[r3 + 0*MK1];
842008a8:	00 00 45 d1 	r2 = M[r3 + 0];
   call copytoramTables;
842008ac:	62 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables;

   r10 = M[r4 + 1*MK1];
842008b0:	04 00 c6 d1 	r10 = M[r4 + 4];
   r2 =  M[r3 + 1*MK1];
842008b4:	04 00 45 d1 	r2 = M[r3 + 4];
   r0 = r8;
842008b8:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.EBAND_OFFSET] = r0;
842008bc:	24 00 29 d5 	M[r7 + 36] = r0;
   Words2Addr(r10);
842008c0:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842008c4:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842008c8:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack3;
842008cc:	79 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack3;
#else
   call copytoramTables;
#endif

   r10 = M[r4 + 2*MK1];
842008d0:	08 00 c6 d1 	r10 = M[r4 + 8];
   r2 =  M[r3 + 2*MK1];
842008d4:	08 00 45 d1 	r2 = M[r3 + 8];
   r0 = r8;
842008d8:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.ALLOCVECTORS_OFFSET] = r0;
842008dc:	28 00 29 d5 	M[r7 + 40] = r0;
   Words2Addr(r10);
842008e0:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842008e4:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842008e8:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack4;
842008ec:	84 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack4;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 3*MK1];
842008f0:	0c 00 45 d1 	r2 = M[r3 + 12];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.WINDOW_OFFSET] = r2;
842008f4:	2c 00 49 d5 	M[r7 + 44] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r10 = M[r4 + 4*MK1];
842008f8:	10 00 c6 d1 	r10 = M[r4 + 16];
   r2 =  M[r3 + 4*MK1];
842008fc:	10 00 45 d1 	r2 = M[r3 + 16];
   r0 = r8;
84200900:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.PROB_OFFSET] = r0;
84200904:	30 00 29 d5 	M[r7 + 48] = r0;
   Words2Addr(r10);
84200908:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
8420090c:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200910:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84200914:	4e 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif
   r10 = M[r4 + 5*MK1];
84200918:	14 00 c6 d1 	r10 = M[r4 + 20];
   r2 =  M[r3 + 5*MK1];
8420091c:	14 00 45 d1 	r2 = M[r3 + 20];
   r0 = r8;
84200920:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.BITS_OFFSET] = r0;
84200924:	34 00 29 d5 	M[r7 + 52] = r0;
   Words2Addr(r10);
84200928:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
8420092c:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200930:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84200934:	46 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 6*MK1];
84200938:	18 00 45 d1 	r2 = M[r3 + 24];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.EBANDS_DIF_SQRT_OFFSET] = r2;
8420093c:	38 00 49 d5 	M[r7 + 56] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r2 =  M[r3 + 7*MK1];
84200940:	1c 00 45 d1 	r2 = M[r3 + 28];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.TRIG_OFFSET] = r2;
84200944:	3c 00 49 d5 	M[r7 + 60] = r2;
   call copytoramTables;
#endif

#ifdef CELT_TABLE_NO_FLASH_COPY

   r0 = &$celt.flaglist;
84200948:	70 00 00 fd 	r0 = Null + 7347468;
8420094c:	0c 1d 20 01 
   M[r5 + $celt.dec.PTR_FLAGLIST_TABLE_FIELD] = r0;
84200950:	10 02 27 d5 	M[r5 + 528] = r0;

   r0 = &$celt.eMeans;
84200954:	70 00 00 fd 	r0 = Null + 7347500;
84200958:	2c 1d 20 01 
   M[r5 + $celt.dec.PTR_EMEANS_TABLE_FIELD] = r0;
8420095c:	14 02 27 d5 	M[r5 + 532] = r0;

   r0 = &$celt.maxN;
84200960:	70 00 00 fd 	r0 = Null + 7347600;
84200964:	90 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_N_TABLE_FIELD]= r0;
84200968:	18 02 27 d5 	M[r5 + 536] = r0;

   r0 = &$celt.maxK;
8420096c:	70 00 00 fd 	r0 = Null + 7347660;
84200970:	cc 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_K_TABLE_FIELD] = r0;
84200974:	1c 02 27 d5 	M[r5 + 540] = r0;

   r0 = &$celt.inv2;
84200978:	70 00 00 fd 	r0 = Null + 7347720;
8420097c:	08 1e 20 01 
   M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD]= r0;
84200980:	20 02 27 d5 	M[r5 + 544] = r0;

   NULL = r6 ;
84200984:	0f 00 08 00 	Null = r6 + Null;
   if NZ jump encoder_table;
84200988:	15 00 10 dd 	if NE jump $M.celt.codec.init_tables.encoder_table;
   r0 = &$celt.transientWindow;
8420098c:	70 00 00 fd 	r0 = Null + 7347340;
84200990:	8c 1c 20 01 
   M[r5 + $celt.dec.PTR_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
84200994:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.decode_jump_table;
84200998:	70 00 00 fd 	r0 = Null + 7347752;
8420099c:	28 1e 20 01 
   M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD] = r0;
842009a0:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
   r2 = &$celt.decode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.dec.PTR_MODE_DM1SCRATCH_ALLOC];
842009a4:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $dec_mode_dm1scratch_alloc;
842009a8:	70 00 00 fd 	r2 = Null + 7347076;
842009ac:	84 1b 40 01 
   Words2Addr(r1);
842009b0:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
842009b4:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
842009b8:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
842009bc:	24 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.dec.PTR_MODE_DM2SCRATCH_ALLOC];
842009c0:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $dec_mode_dm2scratch_alloc;
842009c4:	70 00 00 fd 	r2 = Null + 7347088;
842009c8:	90 1b 40 01 
   r2 = M[r2 + r1];
842009cc:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
842009d0:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
842009d4:	29 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;
#else
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   jump tables_set;
842009d8:	14 00 f0 dd 	jump $M.celt.codec.init_tables.tables_set;

842009dc <$M.celt.codec.init_tables.encoder_table>:

encoder_table:
#ifdef CELT_TABLE_NO_FLASH_COPY
   r0 = &$celt.inv_transientWindow;
842009dc:	70 00 00 fd 	r0 = Null + 7347404;
842009e0:	cc 1c 20 01 
   M[r5 + $celt.enc.PTR_INV_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
842009e4:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.encode_jump_table;
842009e8:	70 00 00 fd 	r0 = Null + 7347772;
842009ec:	3c 1e 20 01 
   M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD] = r0;
842009f0:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
   r2 = &$celt.encode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.enc.PTR_MODE_DM1SCRATCH_ALLOC];
842009f4:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $enc_mode_dm1scratch_alloc;
842009f8:	70 00 00 fd 	r2 = Null + 7347100;
842009fc:	9c 1b 40 01 
   Words2Addr(r1);
84200a00:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
84200a04:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
84200a08:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
84200a0c:	10 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.enc.PTR_MODE_DM2SCRATCH_ALLOC];
84200a10:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $enc_mode_dm2scratch_alloc;
84200a14:	70 00 00 fd 	r2 = Null + 7347112;
84200a18:	a8 1b 40 01 
   r2 = M[r2 + r1];
84200a1c:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
84200a20:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
84200a24:	15 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;

84200a28 <$M.celt.codec.init_tables.tables_set>:
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

tables_set:
   pop r4;
84200a28:	00 00 64 f3 	pop r4;
   jump $pop_rLink_and_rts;
84200a2c:	03 00 00 fd 	jump (m) 0x3b020;
84200a30:	21 b0 f0 dd 

84200a34 <$M.celt.codec.init_tables.copytoramTables>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables:
   I4 = r0;
84200a34:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200a38:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
84200a3c:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram;
84200a40:	02 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram;
      r0 = M[I1,MK1] , M[I4,MK1] = r0;
84200a44:	a1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r0;

84200a48 <$M.celt.codec.init_tables.copy_celt_table_to_ram>:
   copy_celt_table_to_ram:

   rts;
84200a48:	0f 00 0d dc 	rts;

84200a4c <$M.celt.codec.init_tables.copytoramTables_upack2>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2:
   I4 = r0;
84200a4c:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200a50:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
84200a54:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   r10 = r10 LSHIFT -1;
84200a58:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   do copy_celt_table_to_ram_upack2;
84200a5c:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2;
      r2 = r0 AND 0x0000FFFF;
84200a60:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84200a64:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84200a68:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
84200a6c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200a70:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200a74 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2>:
   copy_celt_table_to_ram_upack2:


   rts;
84200a74:	0f 00 0d dc 	rts;

84200a78 <$M.celt.codec.init_tables.copytoramTables_upack2_odd>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2_odd:
   I4 = r0;
84200a78:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200a7c:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 - 1;
84200a80:	3f 00 cc e4 	r10 = r10 - 1;
   r10 = r10 LSHIFT -1;
84200a84:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   r0 = M[I1,MK1];
84200a88:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack2_odd;
84200a8c:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd;
      r2 = r0 AND 0x0000FFFF;
84200a90:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84200a94:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84200a98:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
84200a9c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200aa0:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200aa4 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd>:
   copy_celt_table_to_ram_upack2_odd:
    r2 = r0 AND 0x0000FFFF;
84200aa4:	ff ff 42 81 	r2 = r0 AND 0xffff;
    M[I4,MK1] = r2;
84200aa8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;

   rts;
84200aac:	0f 00 0d dc 	rts;

84200ab0 <$M.celt.codec.init_tables.copytoramTables_upack3>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack3:
   I4 = r0;
84200ab0:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200ab4:	4f 00 10 50 	I1 = Null + r2;
   r10 = 8 ;
84200ab8:	08 00 c0 01 	r10 = Null + 8;
   //r10 = r10 - 1 ;
   r0 = M[I1,MK1];
84200abc:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack3;
84200ac0:	09 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack3;
      r2 = r0 AND 0x000003FF;
84200ac4:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
84200ac8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
84200acc:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
84200ad0:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
84200ad4:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -20 ;
84200ad8:	ec 00 42 8d 	r2 = r0 LSHIFT -20;
      r2 = r2 AND 0x000003FF;
84200adc:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200ae0:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200ae4 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack3>:
   copy_celt_table_to_ram_upack3:
      r2 = r0 AND 0x000003FF;
84200ae4:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
84200ae8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
84200aec:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
84200af0:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
84200af4:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
   rts;
84200af8:	0f 00 0d dc 	rts;

84200afc <$M.celt.codec.init_tables.copytoramTables_upack4>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack4:
   I4 = r0;
84200afc:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200b00:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 LSHIFT -2;
84200b04:	fe 00 cc 8d 	r10 = r10 LSHIFT -2;
   r0 = M[I1,MK1];
84200b08:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack4;
84200b0c:	0c 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack4;
      r2 = r0 AND 0x000000FF;
84200b10:	ff 00 42 81 	r2 = r0 AND 0xff;
      M[I4,MK1] = r2;
84200b14:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -8 ;
84200b18:	f8 00 42 8d 	r2 = r0 LSHIFT -8;
      r2 = r2 AND 0x000000FF;
84200b1c:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
84200b20:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -16 ;
84200b24:	f0 00 42 8d 	r2 = r0 LSHIFT -16;
      r2 = r2 AND 0x000000FF;
84200b28:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
84200b2c:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -24 ;
84200b30:	e8 00 42 8d 	r2 = r0 LSHIFT -24;
      r2 = r2 AND 0x000000FF;
84200b34:	ff 00 44 81 	r2 = r2 AND 0xff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200b38:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200b3c <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack4>:
   copy_celt_table_to_ram_upack4:

   rts;
84200b3c:	0f 00 0d dc 	rts;

84200b40 <$celt.preemphasis>:
84200b40:	7c 01 27 d1 	r0 = M[r5 + 380];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PREEMPHASIS.PATCH_ID_0,r1)     // celt_patchers
#endif   

   r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR];
   r1 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN];
84200b44:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
84200b48:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
84200b4c:	3f 00 f0 50 	L5 = Null + r1;
#ifdef BASE_REGISTER_MODE  
   r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR];
84200b50:	84 01 27 d1 	r0 = M[r5 + 388];
   push r0; 
84200b54:	00 00 20 f3 	push r0;
   pop B5;
84200b58:	00 00 d6 f3 	pop B5;
#endif 
   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
84200b5c:	d8 00 27 d1 	r0 = M[r5 + 216];
   I0 = r0;
84200b60:	2f 00 00 50 	I0 = Null + r0;
   r3 = 0.5;//0.5; //scale factor
84200b64:	00 40 00 fd 	r3 = Null + 1073741824;
84200b68:	00 00 50 01 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200b6c:	08 00 27 d1 	r0 = M[r5 + 8];
   M0 = r0 + 1;
84200b70:	01 00 82 51 	M0 = r0 + 1;
   r4 = M[r5 + $celt.enc.MODE_E_PRED_COEF_FIELD];   //r0 = alpha
84200b74:	50 00 67 d1 	r4 = M[r5 + 80];
   r4 = -r4;
84200b78:	6f 00 60 20 	r4 = Null - r4;
   r4 = r4 * r3(frac);
84200b7c:	00 00 65 97 	r4 = r4 * r3 (frac);
   r6 = r5;
84200b80:	0f 00 87 00 	r6 = r5 + Null;
   r0 = M[r5 + $celt.enc.HIST_OLA_LEFT_FIELD];
84200b84:	94 00 27 d1 	r0 = M[r5 + 148];
   I6 = r0;
84200b88:	2f 00 60 50 	I6 = Null + r0;

84200b8c <$M.celt.preemphasis.chan_loop>:
   chan_loop:
      I1 = I0;
84200b8c:	0f 00 10 58 	I1 = I0 + Null;
      r0 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84200b90:	40 00 27 d1 	r0 = M[r5 + 64];
      Words2Addr(r0);
84200b94:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I0 = I0 + r0;
84200b98:	00 00 02 5b 	I0 = I0 + r0;
      r10 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84200b9c:	44 00 c7 d1 	r10 = M[r5 + 68];
      r10 = r10 - 1;
84200ba0:	3f 00 cc e4 	r10 = r10 - 1;
      r2 = M[r6 + $celt.enc.PREEMPH_HIST_SAMPLE_FIELD];  
84200ba4:	9c 00 48 d1 	r2 = M[r6 + 156];
      r1 = M[I5, 0];
84200ba8:	34 00 00 03 	Null = Null + Null, r1 = M[I5,0];
      rMAC = r2 * r4, r2 = M[I5, MK1];
84200bac:	45 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I5,4];
      do preemphasis_loop;
84200bb0:	03 00 f0 e5 	do $M.celt.preemphasis.preemphasis_loop;
         rMAC = rMAC + r1 * r3, r1 = M[I5, 0];
84200bb4:	34 00 35 af 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,0];
         rMAC = r4 * r2, M[I0, MK1] = rMAC, r2 = M[I5, MK1];
84200bb8:	45 91 64 cf 	rMAC = r4 * r2 (SS), M[I0,4] = rMAC, r2 = M[I5,4];

84200bbc <$M.celt.preemphasis.preemphasis_loop>:
      preemphasis_loop:
      rMAC = rMAC + r1 * r3;
84200bbc:	5f 00 13 ac 	rMAC = rMAC + r1 * r3 (SS);
      M[I0, MK1] = rMAC;
84200bc0:	00 91 00 03 	Null = Null + Null, M[I0,4] = rMAC;
      M[r6 + $celt.enc.PREEMPH_HIST_SAMPLE_FIELD] = r2;      
84200bc4:	9c 00 48 d5 	M[r6 + 156] = r2;
      
      // copy overlap
      r10 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84200bc8:	40 00 c7 d1 	r10 = M[r5 + 64];
      Words2Addr(r10);
84200bcc:	02 00 cc 91 	r10 = r10 ASHIFT 2;
      I0 = I0 - r10;
84200bd0:	00 00 0c 7b 	I0 = I0 - r10;
      Addr2Words(r10);
84200bd4:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
      do copy_hist_ola_loop;
84200bd8:	03 00 f0 e5 	do $M.celt.preemphasis.copy_hist_ola_loop;
         r0 = M[I0, MK1], r1 = M[I6, 0];
84200bdc:	38 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I6,0];
         M[I1, MK1] = r1, M[I6, MK1] = r0;
84200be0:	a9 b5 00 03 	Null = Null + Null, M[I1,4] = r1, M[I6,4] = r0;

84200be4 <$M.celt.preemphasis.copy_hist_ola_loop>:
      copy_hist_ola_loop:
      
      // set up registers for second channel
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR];
84200be4:	88 01 27 d1 	r0 = M[r5 + 392];
      r1 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN];
84200be8:	8c 01 37 d1 	r1 = M[r5 + 396];
      I5 = r0;
84200bec:	2f 00 50 50 	I5 = Null + r0;
      L5 = r1;
84200bf0:	3f 00 f0 50 	L5 = Null + r1;

#ifdef BASE_REGISTER_MODE        
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR];
84200bf4:	90 01 27 d1 	r0 = M[r5 + 400];
      push r0;
84200bf8:	00 00 20 f3 	push r0;
      pop B5;
84200bfc:	00 00 d6 f3 	pop B5;
#endif      
      r6 = r6 + ADDR_PER_WORD;
84200c00:	bf 00 88 e4 	r6 = r6 + 4;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84200c04:	24 01 27 d1 	r0 = M[r5 + 292];
      I0 = r0; 
84200c08:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.enc.HIST_OLA_RIGHT_FIELD];
84200c0c:	98 00 27 d1 	r0 = M[r5 + 152];
      I6 = r0;
84200c10:	2f 00 60 50 	I6 = Null + r0;
      // run for right channel if exisiting
      M0 = M0 - 1;
84200c14:	01 00 88 79 	M0 = M0 - 1;
   if NZ jump chan_loop;   
84200c18:	dd ff 10 dd 	if NE jump $M.celt.preemphasis.chan_loop;
   L5 = 0;
84200c1c:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE  
   push Null;
84200c20:	00 00 00 f3 	push Null;
   pop B5;
84200c24:	00 00 d6 f3 	pop B5;
#endif
   
   rts;   
84200c28:	0f 00 0d dc 	rts;

84200c2c <$celt.quant_coarse_energy>:
84200c2c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST TEMP                 (4 + 2)*ADDR_PER_WORD;
   .CONST BUDGET               (7 + 2)*ADDR_PER_WORD;
   .CONST COUNTER              (8 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     9*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84200c30:	24 00 03 f1 	SP = SP + 36;

   // reset prev for both channels
   M[FP + PREV] = Null;
84200c34:	10 00 0c f1 	M[FP + 0x10] = Null;
   M[FP + PREV + 1*MK1] = Null;
84200c38:	14 00 0c f1 	M[FP + 0x14] = Null;
   r1 = M[r5 + $celt.enc.MODE_PROB_ADDR_FIELD];
84200c3c:	6c 00 37 d1 	r1 = M[r5 + 108];
   I7 = r1;
84200c40:	3f 00 70 50 	I7 = Null + r1;
   r2 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84200c44:	48 00 47 d1 	r2 = M[r5 + 72];
   M[FP + COUNTER] = r2;
84200c48:	28 00 4c f1 	M[FP + 0x28] = r2;
   r0 = M[r5 + $celt.enc.MODE_E_PRED_COEF_FIELD];
84200c4c:	50 00 27 d1 	r0 = M[r5 + 80];
   // calc coef
   Null = M[r5 + $celt.enc.INTRA_ENER_FIELD];
84200c50:	54 01 07 d1 	Null = M[r5 + 340];
   if Z jump intra_end;
84200c54:	05 00 00 dd 	if EQ jump $M.celt.quant_coarse_energy.intra_end;
      r0 = r2 + r2;
84200c58:	4f 00 24 00 	r0 = r2 + r2;
      Words2Addr(r0);
84200c5c:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I7 = I7 + r0;
84200c60:	00 00 72 5b 	I7 = I7 + r0;
      r0 = 0;       
84200c64:	00 00 20 01 	r0 = Null + 0;

84200c68 <$M.celt.quant_coarse_energy.intra_end>:
   intra_end:
   M[FP + COEF] = r0;
84200c68:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = r0 * 0.8 (frac);
84200c6c:	66 66 00 fd 	r0 = r0 * 0.799999999813735485076904296875 (frac);
84200c70:	66 66 22 95 
   M[FP + BETA] = r0;
84200c74:	0c 00 2c f1 	M[FP + 0xc] = r0;
   
   // calc budget
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84200c78:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT 2;
84200c7c:	02 00 33 8d 	r1 = r1 LSHIFT 2;
   r1 = r1 - 8; // budget
84200c80:	08 00 33 21 	r1 = r1 - 8;
   M[FP + BUDGET] = r1;
84200c84:	24 00 3c f1 	M[FP + 0x24] = r1;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84200c88:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
84200c8c:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84200c90:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0; 
84200c94:	2f 00 30 50 	I3 = Null + r0;
   r0 = FP + PREV;
84200c98:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0;
84200c9c:	2f 00 40 50 	I4 = Null + r0;
   M2 = 0;
84200ca0:	00 00 a0 51 	M2 = Null + 0;
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
84200ca4:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0;
84200ca8:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
84200cac:	e0 00 27 d1 	r0 = M[r5 + 224];
   I6 = r0;
84200cb0:	2f 00 60 50 	I6 = Null + r0;
   //I3=oldEband
   //I4=prev
   //I5=logband
   //I6=error
   //I7=prob
   r4 = 0;
84200cb4:	00 00 60 01 	r4 = Null + 0;

84200cb8 <$M.celt.quant_coarse_energy.loop_encode_coarse>:
   loop_encode_coarse:
      call run_ch;
84200cb8:	15 00 f0 e1 	call $M.celt.quant_coarse_energy.run_ch;
      
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200cbc:	08 00 27 d1 	r0 = M[r5 + 8];
      if Z jump end_ch;
84200cc0:	0c 00 00 dd 	if EQ jump $M.celt.quant_coarse_energy.end_ch;
      I2 = I2 - 1 * MK1;
84200cc4:	04 00 22 79 	I2 = I2 - 4;
      I3 = I3 + ($celt.MAX_BANDS-1)*MK1;
84200cc8:	60 00 33 59 	I3 = I3 + 96;
      I4 = I4 + 1*MK1;
84200ccc:	04 00 44 59 	I4 = I4 + 4;
      I5 = I5 + ($celt.MAX_BANDS-1)*MK1;
84200cd0:	60 00 55 59 	I5 = I5 + 96;
      I6 = I6 + ($celt.MAX_BANDS-1)*MK1;
84200cd4:	60 00 66 59 	I6 = I6 + 96;
      I7 = I7 - 2*MK1;
84200cd8:	08 00 77 79 	I7 = I7 - 8;
      call run_ch;
84200cdc:	0c 00 f0 e1 	call $M.celt.quant_coarse_energy.run_ch;
      I3 = I3 - ($celt.MAX_BANDS*MK1);
84200ce0:	64 00 33 79 	I3 = I3 - 100;
      I4 = I4 - 1*MK1;
84200ce4:	04 00 44 79 	I4 = I4 - 4;
      I5 = I5 - ($celt.MAX_BANDS*MK1);
84200ce8:	64 00 55 79 	I5 = I5 - 100;
      I6 = I6 - ($celt.MAX_BANDS*MK1);
84200cec:	64 00 66 79 	I6 = I6 - 100;

84200cf0 <$M.celt.quant_coarse_energy.end_ch>:
      end_ch:
      r0 = M[FP + COUNTER];
84200cf0:	28 00 28 f1 	r0 = M[FP + 0x28];
      r0 = r0 - 1;
84200cf4:	3f 00 22 e4 	r0 = r0 - 1;
      M[FP + COUNTER] = r0;
84200cf8:	28 00 2c f1 	M[FP + 0x28] = r0;
   if NZ jump loop_encode_coarse;
84200cfc:	ef ff 10 dd 	if NE jump $M.celt.quant_coarse_energy.loop_encode_coarse;
 
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84200d00:	dc ff 03 f1 	SP = SP + -36;
   popm <FP,rLink>;
84200d04:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200d08:	0f 00 0d dc 	rts;

84200d0c <$M.celt.quant_coarse_energy.run_ch>:
   run_ch:
      push rlink;
84200d0c:	00 00 d0 f3 	push rLink;
      M[FP + TEMP + 1*MK1] = Null;
84200d10:	1c 00 0c f1 	M[FP + 0x1c] = Null;
      call $celt.ec_enc_tell;    
84200d14:	3d 01 f0 e1 	call $celt.ec_enc_tell;
      r1 = M[FP + BUDGET];
84200d18:	24 00 38 f1 	r1 = M[FP + 0x24];
      Null = r0 - r1;      
84200d1c:	3f 00 02 20 	Null = r0 - r1;
      if LE jump calc_q;
84200d20:	05 00 d0 dd 	if LE jump $M.celt.quant_coarse_energy.calc_q;
         r1 = -1;
84200d24:	3f 00 30 e4 	r1 = Null - 1;
         r2 = 1.0;
84200d28:	ff 7f 00 fd 	r2 = Null + 2147483647;
84200d2c:	ff ff 40 01 
         jump set_error;
84200d30:	16 00 f0 dd 	jump $M.celt.quant_coarse_energy.set_error;

84200d34 <$M.celt.quant_coarse_energy.calc_q>:
      calc_q:
      r0 = M[I2, MK1];
84200d34:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
#ifdef CELT_USE_EXTERNAL_MEMORY
      r7 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84200d38:	14 02 97 d1 	r7 = M[r5 + 532];
      r7 = r7 + $celt.E_MEANS_SIZE*MK1;
84200d3c:	14 00 99 01 	r7 = r7 + 20;
      Null = I2 - r7;
84200d40:	9f 00 02 68 	Null = I2 - r7;
#else // CELT_USE_EXTERNAL_MEMORY
      Null = I2 - (&$celt.eMeans + $celt.E_MEANS_SIZE*MK1);
#endif // CELT_USE_EXTERNAL_MEMORY
      if GT r0 = r0 - r0;  //r1=eBand=x     
84200d44:	2c 00 22 20 	if GT r0 = r0 - r0;
      M[FP + TEMP + 1*MK1] = r0;
84200d48:	1c 00 2c f1 	M[FP + 0x1c] = r0;
      r7 = M[FP + COEF];      
84200d4c:	08 00 98 f1 	r7 = M[FP + 0x8];
      r2 = r7*r0(frac);
84200d50:	2f 00 49 94 	r2 = r7 * r0 (frac);
      r2 = r2 - r0, r1 = M[I5, MK1];        //r0 =oldBand, r2 = -mean
84200d54:	35 00 42 23 	r2 = r2 - r0, r1 = M[I5,4];
      r1 = r1 + r2, r0 = M[I3, 0];
84200d58:	00 2c 34 03 	r1 = r1 + r2, r0 = M[I3,0];
      r0 = r0*r7(frac), r3 = M[I4, 0];
84200d5c:	50 00 29 97 	r0 = r0 * r7 (frac), r3 = M[I4,0];
      r1 = r1 - r0, r2 = M[I7, MK1];
84200d60:	4d 00 32 23 	r1 = r1 - r0, r2 = M[I7,4];
      r1 = r1 - r3, r3 = M[I7, MK1];
84200d64:	5d 00 35 23 	r1 = r1 - r3, r3 = M[I7,4];
      M[FP + TEMP + 0] = r1;
84200d68:	18 00 3c f1 	M[FP + 0x18] = r1;
      r1 = r1*128(frac);
84200d6c:	00 00 00 fd 	r1 = r1 * 5.9604644775390625e-08 (frac);
84200d70:	80 00 33 95 
      call $celt.ec_laplace_encode_start;
84200d74:	e0 08 f0 e1 	call $celt.ec_laplace_encode_start;
      r2 = r1*(-1.0/128.0)(int);
84200d78:	00 ff 00 fd 	r2 = r1 * -16777216 (int);
84200d7c:	00 00 43 99 
      r0 = M[FP + TEMP + 0];
84200d80:	18 00 28 f1 	r0 = M[FP + 0x18];
      r2 = r2 + r0;      
84200d84:	00 00 42 03 	r2 = r2 + r0;

84200d88 <$M.celt.quant_coarse_energy.set_error>:
      set_error:
      M[I6, MK1] = r2;
84200d88:	c9 00 00 03 	Null = Null + Null, M[I6,4] = r2;
      r1 = r1 ASHIFT (DAWTH-8);
84200d8c:	18 00 33 91 	r1 = r1 ASHIFT 24;
      r0 = M[FP + TEMP + 1*MK1];
84200d90:	1c 00 28 f1 	r0 = M[FP + 0x1c];
      r4 = M[I4, 0];                            //r4 = p
84200d94:	60 00 00 03 	Null = Null + Null, r4 = M[I4,0];
      r4 = r4 + r0, r2 = M[I3, 0];              //r4 = m+ p, r2 =b
84200d98:	00 4c 62 03 	r4 = r4 + r0, r2 = M[I3,0];
      r4 = r4 + r1;                             //r4 = m+p+q
84200d9c:	00 00 63 03 	r4 = r4 + r1;
      r7 = M[FP + COEF];                             //r7 = c
84200da0:	08 00 98 f1 	r7 = M[FP + 0x8];
      r3 = r2 - r0;                             //r3 = b -m
84200da4:	2f 00 54 20 	r3 = r2 - r0;
      r3 = r3 * r7 (frac);                      //r3 = (b-m)*c
84200da8:	00 00 59 97 	r3 = r3 * r7 (frac);
      r3 = r3 + r4;                             //r3 -->b
84200dac:	00 00 56 03 	r3 = r3 + r4;
      rMAC = r0*r7;
84200db0:	9f 00 12 cc 	rMAC = r0 * r7 (SS);
      r0 = M[FP + BETA];
84200db4:	0c 00 28 f1 	r0 = M[FP + 0xc];
      rMAC = rMAC + r1*r0, M[I3, MK1] = r3;       //save C-Energy
84200db8:	00 dd 32 af 	rMAC = rMAC + r1 * r0 (SS), M[I3,4] = r3;
      r4 = r4 - rMAC;
84200dbc:	00 00 61 23 	r4 = r4 - rMAC;
      r4 = 0, M[I4, 0] = r4;                    //save prev
84200dc0:	e0 00 66 23 	r4 = r4 - r4, M[I4,0] = r4;
      jump $pop_rLink_and_rts;
84200dc4:	03 00 00 fd 	jump (m) 0x3b020;
84200dc8:	21 b0 f0 dd 

84200dcc <$celt.quant_fine_energy>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.QUANT_FINE_ENERGY.PATCH_ID_0,r2)     // celt_patchers
#endif  

   // push rLink onto stack
   push rlink;
84200dcc:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84200dd0:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84200dd4:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.FINE_QUANT_FIELD];
84200dd8:	08 01 27 d1 	r0 = M[r5 + 264];
   I2 = r0;
84200ddc:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84200de0:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84200de4:	2f 00 30 50 	I3 = Null + r0;
   M0 = 1;
84200de8:	01 00 80 51 	M0 = Null + 1;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200dec:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84200df0:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
84200df4:	e0 00 27 d1 	r0 = M[r5 + 224];
   I5 = r0 - 1*MK1;
84200df8:	04 00 52 71 	I5 = r0 - 4;

84200dfc <$M.celt.quant_fine_energy.fine_quant_loop>:
   fine_quant_loop:
      r2 = M[I2, MK1], r0 = M[I5, MK1];
84200dfc:	25 49 00 03 	Null = Null + Null, r2 = M[I2,4], r0 = M[I5,4];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
84200e00:	e4 01 47 d5 	M[r5 + 484] = r2;
      if LE jump b_loop;
84200e04:	0b 00 d0 dd 	if LE jump $M.celt.quant_fine_energy.b_loop;
      push r2;
84200e08:	00 00 40 f3 	push r2;
      call run_ch;
84200e0c:	0d 00 f0 e1 	call $M.celt.quant_fine_energy.run_ch;
      pop r2;
84200e10:	00 00 44 f3 	pop r2;
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200e14:	08 00 27 d1 	r0 = M[r5 + 8];
      if Z jump end_ch;
84200e18:	06 00 00 dd 	if EQ jump $M.celt.quant_fine_energy.b_loop;
      I3 = I3 + ($celt.MAX_BANDS*MK1);
84200e1c:	64 00 33 59 	I3 = I3 + 100;
      I5 = I5 + ($celt.MAX_BANDS*MK1);
84200e20:	64 00 55 59 	I5 = I5 + 100;
      call run_ch;
84200e24:	07 00 f0 e1 	call $M.celt.quant_fine_energy.run_ch;
      I3 = I3 - ($celt.MAX_BANDS*MK1);
84200e28:	64 00 33 79 	I3 = I3 - 100;
      I5 = I5 - ($celt.MAX_BANDS*MK1);
84200e2c:	64 00 55 79 	I5 = I5 - 100;

84200e30 <$M.celt.quant_fine_energy.b_loop>:
      end_ch:         
      b_loop:
      M3 = M3 - M0, r0 = M[I3, MK1];
84200e30:	00 2d b8 7f 	M3 = M3 - M0, r0 = M[I3,4];
   if NZ jump fine_quant_loop;
84200e34:	f2 ff 10 dd 	if NE jump $M.celt.quant_fine_energy.fine_quant_loop;
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200e38:	03 00 00 fd 	jump (m) 0x3b020;
84200e3c:	21 b0 f0 dd 

84200e40 <$M.celt.quant_fine_energy.run_ch>:
   run_ch:
   push rlink;
84200e40:	00 00 d0 f3 	push rLink;
   r0 = M[I5, 0];
84200e44:	24 00 00 03 	Null = Null + Null, r0 = M[I5,0];
#ifndef K32   
   r0 = r0 + 0x8000;   //TODO:make sure sat avoided
#else
   r0 = r0 + 0x800000; //TODO:make sure sat avoided
84200e48:	80 00 00 fd 	r0 = r0 + 8388608;
84200e4c:	00 00 22 01 
#endif   
   r1 = r2 - (DAWTH-8);
84200e50:	18 00 34 21 	r1 = r2 - 24;
   r0 = r0 ASHIFT r1;
84200e54:	00 00 23 93 	r0 = r0 ASHIFT r1;
   r1 = 1 LSHIFT r2;
84200e58:	01 00 34 e9 	r1 = 0x1 LSHIFT r2;
   r1 = r1 - 1;
84200e5c:	3f 00 33 e4 	r1 = r1 - 1;
   Null = r0 - r1;
84200e60:	3f 00 02 20 	Null = r0 - r1;
   if POS r0 = r1;
84200e64:	05 00 23 00 	if POS r0 = r1 + Null;
#ifndef K32   
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84200e68:	d4 01 27 d5 	M[r5 + 468] = r0;
#endif   
   r1 = r0 + r0;
84200e6c:	2f 00 32 00 	r1 = r0 + r0;
   r1 = r1 + 1;
84200e70:	2f 00 33 e4 	r1 = r1 + 1;
   r2 = (DAWTH-9) - r2;
84200e74:	17 00 44 65 	r2 = 23 - r2;
   r1 = r1 ASHIFT r2, r0 = M[I3, 0];
84200e78:	00 2c 34 93 	r1 = r1 ASHIFT r2, r0 = M[I3,0];
#ifndef K32
   r1 = r1 - 0x8000;   
#else
   r1 = r1 - 0x800000;   
84200e7c:	80 00 00 fd 	r1 = r1 - 8388608;
84200e80:	00 00 33 21 
#endif   
   r0 = r0 + r1, r2 = M[I5, 0];
84200e84:	44 00 23 03 	r0 = r0 + r1, r2 = M[I5,0];
   r2 = r2 - r1, M[I3, 0] = r0;
84200e88:	00 ac 43 23 	r2 = r2 - r1, M[I3,0] = r0;
   M[I5, 0] = r2;
84200e8c:	c4 00 00 03 	Null = Null + Null, M[I5,0] = r2;
   call $celt.ec_enc_bits;
84200e90:	00 01 f0 e1 	call $celt.ec_enc_bits;
   // pop rLink from stack
   jump $pop_rLink_and_rts;  
84200e94:	03 00 00 fd 	jump (m) 0x3b020;
84200e98:	21 b0 f0 dd 

84200e9c <$celt.quant_energy_finalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.QUANT_ENERGY_FINALISE.PATCH_ID_0,r1)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
84200e9c:	00 00 d0 f3 	push rLink;
   
   // work out bits left
   r4 = 0;
84200ea0:	00 00 60 01 	r4 = Null + 0;
   call $celt.ec_enc_tell;
84200ea4:	d9 00 f0 e1 	call $celt.ec_enc_tell;
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84200ea8:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 * 8(int);
84200eac:	08 00 33 99 	r1 = r1 * 8 (int);
   M2 = r1 - r0;
84200eb0:	2f 00 a3 70 	M2 = r1 - r0;
   
   // mono/stereo 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200eb4:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84200eb8:	2f 00 60 50 	I6 = Null + r0;
   M3 = 1;
84200ebc:	01 00 b0 51 	M3 = Null + 1;

84200ec0 <$M.celt.quant_energy_finalise.prio_loop>:
   prio_loop:
      r10 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84200ec0:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = M[r5 + $celt.enc.FINE_QUANT_FIELD];
84200ec4:	08 01 27 d1 	r0 = M[r5 + 264];
      I2 = r0;
84200ec8:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84200ecc:	8c 00 27 d1 	r0 = M[r5 + 140];
      I3 = r0;
84200ed0:	2f 00 30 50 	I3 = Null + r0;
      I4 = r0 + ($celt.MAX_BANDS*MK1);
84200ed4:	64 00 42 51 	I4 = r0 + 100;
      r0 = M[r5 + $celt.enc.FINE_PRIORITY_FIELD];
84200ed8:	0c 01 27 d1 	r0 = M[r5 + 268];
      I5 = r0;
84200edc:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
84200ee0:	e0 00 27 d1 	r0 = M[r5 + 224];
      I7 = r0;
84200ee4:	2f 00 70 50 	I7 = Null + r0;
      do finalise_loop;
84200ee8:	29 00 f0 e5 	do $M.celt.quant_energy_finalise.end_finalise_loop;
         r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200eec:	08 00 27 d1 	r0 = M[r5 + 8];
         Null = M2 - r0;
84200ef0:	2f 00 0a 68 	Null = M2 - r0;
         if LE jump end_finalise_loop;
84200ef4:	26 00 d0 dd 	if LE jump $M.celt.quant_energy_finalise.end_finalise_loop;
         r0 = M[I2, 0], r1 = M[I5, 0];
84200ef8:	34 28 00 03 	Null = Null + Null, r0 = M[I2,0], r1 = M[I5,0];
         Null = r0 - 7;
84200efc:	07 00 02 21 	Null = r0 - 7;
         if POS jump next_fin;
84200f00:	20 00 50 dd 	if POS jump $M.celt.quant_energy_finalise.next_fin;
         Null = r1 - M3;
84200f04:	bf 00 03 64 	Null = r1 - M3;
         if Z jump next_fin;
84200f08:	1e 00 00 dd 	if EQ jump $M.celt.quant_energy_finalise.next_fin;
            r2 = 1;
84200f0c:	2f 00 40 e4 	r2 = Null + 1;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
84200f10:	e4 01 47 d5 	M[r5 + 484] = r2;
            r1 = M[I7, 0];
84200f14:	3c 00 00 03 	Null = Null + Null, r1 = M[I7,0];
            Null = r1;
84200f18:	0f 00 03 00 	Null = r1 + Null;
            if NEG r2 = 0;
84200f1c:	04 00 40 00 	if NEG r2 = Null + Null;
#ifndef K32            
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r2;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else 
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r2;                 
84200f20:	d4 01 47 d5 	M[r5 + 468] = r2;
#endif            
            call $celt.ec_enc_bits;
84200f24:	db 00 f0 e1 	call $celt.ec_enc_bits;
            //calc offset
            r0 = M[I7, 0];
84200f28:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
            r0 = r0 + r0, r2 = M[I2, 0];
84200f2c:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84200f30:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = 14 - r2;
84200f34:	0e 00 44 65 	r2 = 14 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I3, 0];
84200f38:	00 3c 24 93 	r0 = r0 ASHIFT r2, r1 = M[I3,0];
            r0 = r0 + r1;
84200f3c:	00 00 23 03 	r0 = r0 + r1;
            M2 = M2 -1;
84200f40:	01 00 aa 79 	M2 = M2 - 1;
            Null = I6, M[I3, 0] = r0;
84200f44:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
            if Z jump next_fin;
84200f48:	0e 00 00 dd 	if EQ jump $M.celt.quant_energy_finalise.next_fin;
            I7 = I7 + ($celt.MAX_BANDS*MK1);
84200f4c:	64 00 77 59 	I7 = I7 + 100;
            r1 = M[I7, 0];
84200f50:	3c 00 00 03 	Null = Null + Null, r1 = M[I7,0];
#ifndef K32            
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r1;
84200f54:	d4 01 37 d5 	M[r5 + 468] = r1;
#endif            
            call $celt.ec_enc_bits;
84200f58:	ce 00 f0 e1 	call $celt.ec_enc_bits;
            r0 = M[I7, 0];
84200f5c:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
            r0 = r0 + r0, r2 = M[I2, 0];
84200f60:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84200f64:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = 14 - r2;
84200f68:	0e 00 44 65 	r2 = 14 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I4, 0];
84200f6c:	30 00 24 93 	r0 = r0 ASHIFT r2, r1 = M[I4,0];
            r0 = r0 + r1;
84200f70:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
84200f74:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;
            M2 = M2 -1;
84200f78:	01 00 aa 79 	M2 = M2 - 1;
            I7 = I7 - ($celt.MAX_BANDS*MK1);
84200f7c:	64 00 77 79 	I7 = I7 - 100;

84200f80 <$M.celt.quant_energy_finalise.next_fin>:
            next_fin:
            r0 = M[I2, MK1], r1 = M[I5, MK1];
84200f80:	35 29 00 03 	Null = Null + Null, r0 = M[I2,4], r1 = M[I5,4];
            r0 = M[I3, MK1], r1 = M[I7, MK1];
84200f84:	3d 2d 00 03 	Null = Null + Null, r0 = M[I3,4], r1 = M[I7,4];
            r1 = M[I4, MK1]; 
84200f88:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];

84200f8c <$M.celt.quant_energy_finalise.end_finalise_loop>:
        finalise_loop:
        end_finalise_loop:
   M3 = M3 - 1;
84200f8c:	01 00 bb 79 	M3 = M3 - 1;
   if Z jump prio_loop;
84200f90:	cc ff 00 dd 	if EQ jump $M.celt.quant_energy_finalise.prio_loop;

   // calculate non-logarithmic bands Energies
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84200f94:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84200f98:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84200f9c:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0;
84200fa0:	2f 00 20 50 	I2 = Null + r0;
   I4 = I2 + ($celt.MAX_BANDS*MK1);
84200fa4:	64 00 42 59 	I4 = I2 + 100;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200fa8:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
84200fac:	01 00 b2 51 	M3 = r0 + 1;
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
84200fb0:	00 00 a7 d1 	r8 = M[r5 + 0];

84200fb4 <$M.celt.quant_energy_finalise.calc_ebands>:
   calc_ebands:
   r10 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84200fb4:	48 00 c7 d1 	r10 = M[r5 + 72];
   do comp_ebands_loop_ch;
84200fb8:	12 00 f0 e5 	do $M.celt.quant_energy_finalise.comp_ebands_loop_ch;
      r0 = M[I3, 0];
84200fbc:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r4 = 0;
84200fc0:	00 00 60 01 	r4 = Null + 0;
      r1 = r0 ASHIFT -(DAWTH-8);
84200fc4:	e8 00 32 91 	r1 = r0 ASHIFT -24;
      if NEG jump calc_log;
84200fc8:	04 00 40 dd 	if NEG jump $M.celt.quant_energy_finalise.calc_log;
         r4 = r1 + 1;
84200fcc:	2f 00 63 e4 	r4 = r1 + 1;
         r1 = r4 ASHIFT (DAWTH-8);
84200fd0:	18 00 36 91 	r1 = r4 ASHIFT 24;
         r0 = r0 - r1;
84200fd4:	00 00 23 23 	r0 = r0 - r1;

84200fd8 <$M.celt.quant_energy_finalise.calc_log>:
      calc_log:
      call $math.pow2_table;
84200fd8:	07 00 00 fd 	call 0x74514;
84200fdc:	14 45 f0 e1 
      r4 = r4 - 12;
84200fe0:	0c 00 66 21 	r4 = r4 - 12;
      // store E in the form of a gain and a shift value
      M[I4, MK1] = r4; 
84200fe4:	e1 00 00 03 	Null = Null + Null, M[I4,4] = r4;
      M[I2, MK1] = r0;
84200fe8:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;

      // minimum energy clipping
      r0 = M[I3, 0];
84200fec:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r1 = r0 + 0.0546875;
84200ff0:	00 07 00 fd 	r1 = r0 + 117440512;
84200ff4:	00 00 32 01 
      if NEG r0 = r0 - r1;
84200ff8:	34 00 22 20 	if NEG r0 = r0 - r1;
      M[I3, MK1] = r0;
84200ffc:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;

84201000 <$M.celt.quant_energy_finalise.comp_ebands_loop_ch>:
   comp_ebands_loop_ch:
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201000:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*MK1);
84201004:	64 00 32 51 	I3 = r0 + 100;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84201008:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0 + (2*$celt.MAX_BANDS*MK1);
8420100c:	c8 00 22 51 	I2 = r0 + 200;
   I4 = I2 + ($celt.MAX_BANDS*MK1);
84201010:	64 00 42 59 	I4 = I2 + 100;
   M3 = M3 - 1;
84201014:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_ebands;
84201018:	e7 ff 10 dd 	if NE jump $M.celt.quant_energy_finalise.calc_ebands;
 
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420101c:	03 00 00 fd 	jump (m) 0x3b020;
84201020:	21 b0 f0 dd 

84201024 <$celt.ec_enc_init>:
84201024:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 0] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 1] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = Null;
#else
   r0 = -1;
84201028:	3f 00 20 e4 	r0 = Null - 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r0;
8420102c:	a0 01 27 d5 	M[r5 + 416] = r0;
   // rng = EC_CODE_TOP
   r0 = 0x80000000;
84201030:	00 80 00 fd 	r0 = Null + -2147483648;
84201034:	00 00 20 01 
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 0] = r0;
84201038:	a4 01 27 d5 	M[r5 + 420] = r0;
   r0 = 8;
8420103c:	08 00 20 01 	r0 = Null + 8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT] = r0;
84201040:	bc 01 27 d5 	M[r5 + 444] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS] = Null;
84201044:	c0 01 07 d5 	M[r5 + 448] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = Null;
84201048:	ac 01 07 d5 	M[r5 + 428] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = Null;
8420104c:	b4 01 07 d5 	M[r5 + 436] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = Null;
84201050:	b8 01 07 d5 	M[r5 + 440] = Null;
#endif   

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201054:	03 00 00 fd 	jump (m) 0x3b020;
84201058:	21 b0 f0 dd 

8420105c <$celt.ec_enc_carry_out>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_CARRY_OUT.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
8420105c:	00 00 d0 f3 	push rLink;
   // r3 = carry
   Null = r3 - $celt.EC_SYM_MAX;
84201060:	ff 00 05 21 	Null = r3 - 255;
   if NZ jump write_sym;
84201064:	04 00 10 dd 	if NE jump $M.celt.ec_enc_carry_out.write_sym;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84201068:	b4 01 47 d1 	r2 = M[r5 + 436];
      r2 = r2 + 1;
8420106c:	2f 00 44 e4 	r2 = r2 + 1;
      jump end;
84201070:	0f 00 f0 dd 	jump $M.celt.ec_enc_carry_out.end;

84201074 <$M.celt.ec_enc_carry_out.write_sym>:
   write_sym:
   r2 = r3 LSHIFT (-$celt.EC_SYM_BITS);
84201074:	f8 00 45 8d 	r2 = r3 LSHIFT -8;

   r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
84201078:	a0 01 37 d1 	r1 = M[r5 + 416];
   if NEG jump end_writing_carry;
8420107c:	03 00 40 dd 	if NEG jump $M.celt.ec_enc_carry_out.end_writing_carry;
      r1 = r1 + r2; 
84201080:	00 00 34 03 	r1 = r1 + r2;
      call $celt.put1byte;
84201084:	c8 08 f0 e1 	call $celt.put1byte;

84201088 <$M.celt.ec_enc_carry_out.end_writing_carry>:
   end_writing_carry:
   r2 = r2 + $celt.EC_SYM_MAX;
84201088:	ff 00 44 01 	r2 = r2 + 255;
   r1 = r2 AND $celt.EC_SYM_MAX;
8420108c:	ff 00 34 81 	r1 = r2 AND 0xff;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84201090:	b4 01 47 d1 	r2 = M[r5 + 436];

84201094 <$M.celt.ec_enc_carry_out.loop_write_sym>:
   loop_write_sym:
      if LE jump end_write_loop;
84201094:	04 00 d0 dd 	if LE jump $M.celt.ec_enc_carry_out.end_write_loop;
      call $celt.put1byte;
84201098:	c3 08 f0 e1 	call $celt.put1byte;
      r2 = r2 - 1;
8420109c:	3f 00 44 e4 	r2 = r2 - 1;
   jump loop_write_sym;
842010a0:	fd ff f0 dd 	jump $M.celt.ec_enc_carry_out.loop_write_sym;

842010a4 <$M.celt.ec_enc_carry_out.end_write_loop>:
   end_write_loop:
   r3 = r3 AND $celt.EC_SYM_MAX; 
842010a4:	ff 00 55 81 	r3 = r3 AND 0xff;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r3;
842010a8:	a0 01 57 d5 	M[r5 + 416] = r3;

842010ac <$M.celt.ec_enc_carry_out.end>:
   end:
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = r2;
842010ac:	b4 01 47 d5 	M[r5 + 436] = r2;
    // pop rLink from stack
   jump $pop_rLink_and_rts;
842010b0:	03 00 00 fd 	jump (m) 0x3b020;
842010b4:	21 b0 f0 dd 

842010b8 <$celt.ec_enc_normalise>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_NORMALISE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842010b8:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 1] = r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 0] = r4;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r6;
#else
    // K32 implementation
    r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
842010bc:	ac 01 97 d1 	r7 = M[r5 + 428];
    r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
842010c0:	a4 01 67 d1 	r4 = M[r5 + 420];

842010c4 <$M.celt.ec_enc_normalise.retry>:
    retry:
       Null = $celt.EC_CODE_BOT - r4;
842010c4:	80 00 00 fd 	Null = 8388608 - r4;
842010c8:	00 00 06 65 
       if NC jump end;
842010cc:	08 00 30 dd 	if NC jump $M.celt.ec_enc_normalise.end;
          r3 = r7 LSHIFT (-$celt.EC_CODE_SHIFT);
842010d0:	e9 00 59 8d 	r3 = r7 LSHIFT -23;
          call $celt.ec_enc_carry_out;
842010d4:	e2 ff f0 e1 	call $celt.ec_enc_carry_out;
          r7 = r7 LSHIFT 8;
842010d8:	08 00 99 8d 	r7 = r7 LSHIFT 8;
          r7 = r7 AND 0x7FFFFFFF;
842010dc:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
842010e0:	ff ff 99 81 
          r4 = r4 LSHIFT 8;
842010e4:	08 00 66 8d 	r4 = r4 LSHIFT 8;
    jump retry;
842010e8:	f7 ff f0 dd 	jump $M.celt.ec_enc_normalise.retry;

842010ec <$M.celt.ec_enc_normalise.end>:
    end:
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r7;
842010ec:	ac 01 97 d5 	M[r5 + 428] = r7;
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r4;
842010f0:	a4 01 67 d5 	M[r5 + 420] = r4;
#endif

   
    // pop rLink from stack
   jump $pop_rLink_and_rts;
842010f4:	03 00 00 fd 	jump (m) 0x3b020;
842010f8:	21 b0 f0 dd 

842010fc <$celt.ec_encode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842010fc:	00 00 d0 f3 	push rLink;
       M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r1;
    end:
    call $celt.ec_enc_normalise;
#else // K32
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84201100:	a4 01 27 d1 	r0 = M[r5 + 420];
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
84201104:	cc 01 47 d1 	r2 = M[r5 + 460];
   rMAC = 0;
84201108:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r0;
8420110c:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   Div = rMAC / r2; // r = rng / ft
84201110:	00 00 14 d9 	Div = rMAC / r2;
   r6 = DivResult;
84201114:	01 00 80 d9 	r6 = DivResult;

84201118 <$celt.ec_encode_bin_jump_point>:
   $celt.ec_encode_bin_jump_point:
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL]; 
84201118:	d4 01 67 d1 	r4 = M[r5 + 468];
   r4 = -r4;                                      // r4 = -fl
8420111c:	6f 00 60 20 	r4 = Null - r4;
   if POS jump update_range_only;
84201120:	0c 00 50 dd 	if POS jump $M.celt.ec_encode.update_range_only;
      r2 = r4 + r2; // (ft + -fl)
84201124:	4f 00 46 00 	r2 = r4 + r2;
      r3 = r2*r6(int); // r*(ft-fl)
84201128:	8f 00 54 98 	r3 = r2 * r6 (int);
      r0 = r0 - r3; // rng - r*(ft - fl)
8420112c:	00 00 25 23 	r0 = r0 - r3;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
84201130:	ac 01 47 d1 	r2 = M[r5 + 428];
      r0 = r2 + r0; // low + rng - r*(ft - fl)
84201134:	2f 00 24 00 	r0 = r2 + r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r0;
84201138:	ac 01 27 d5 	M[r5 + 428] = r0;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
8420113c:	dc 01 47 d1 	r2 = M[r5 + 476];
      r2 = r2 + r4;                             // (fh - fl)
84201140:	00 00 46 03 	r2 = r2 + r4;
      r0 = r2*r6(int); // (r*(fh-fl)
84201144:	8f 00 24 98 	r0 = r2 * r6 (int);
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r0;
84201148:	a4 01 27 d5 	M[r5 + 420] = r0;
      jump end;
8420114c:	07 00 f0 dd 	jump $M.celt.ec_encode.end;

84201150 <$M.celt.ec_encode.update_range_only>:
   update_range_only:
      r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
84201150:	dc 01 27 d1 	r0 = M[r5 + 476];
      r2 = r2 - r0;    // (ft - fh)
84201154:	00 00 42 23 	r2 = r2 - r0;
      r0 = r2*r6(int); // r*(ft - fh)
84201158:	8f 00 24 98 	r0 = r2 * r6 (int);
      r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420115c:	a4 01 37 d1 	r1 = M[r5 + 420];
      r1 = r1 - r0;
84201160:	00 00 32 23 	r1 = r1 - r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r1;   // rng = rng - r*(ft - fh)
84201164:	a4 01 37 d5 	M[r5 + 420] = r1;

84201168 <$M.celt.ec_encode.end>:
   end:
   call $celt.ec_enc_normalise;
84201168:	d4 ff f0 e1 	call $celt.ec_enc_normalise;
#endif

        
    // pop rLink from stack
   jump $pop_rLink_and_rts;
8420116c:	03 00 00 fd 	jump (m) 0x3b020;
84201170:	21 b0 f0 dd 

84201174 <$celt.ec_encode_bin>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE_BIN.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201174:	00 00 d0 f3 	push rLink;
   r2 = 32768;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r2;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1] = Null;
   r7 = 0;
#else
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84201178:	a4 01 27 d1 	r0 = M[r5 + 420];
   r6 = r0 LSHIFT -15;
8420117c:	f1 00 82 8d 	r6 = r0 LSHIFT -15;
   r2 = 32768;
84201180:	00 00 00 fd 	r2 = Null + 32768;
84201184:	00 80 40 01 
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT] = r2;
84201188:	cc 01 47 d5 	M[r5 + 460] = r2;
   r7 = 0;
8420118c:	00 00 90 01 	r7 = Null + 0;
#endif   
      
   jump $celt.ec_encode_bin_jump_point;
84201190:	e2 ff f0 dd 	jump $celt.ec_encode_bin_jump_point;

84201194 <$celt.ec_encode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
    push rlink;
84201194:	00 00 d0 f3 	push rLink;
   //r8 = bits
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS];
84201198:	c0 01 27 d1 	r0 = M[r5 + 448];
   r0 = r0 + r8;
8420119c:	00 00 2a 03 	r0 = r0 + r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS] = r0;
842011a0:	c0 01 27 d5 	M[r5 + 448] = r0;

   r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE];
842011a4:	b8 01 97 d1 	r7 = M[r5 + 440];
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT];
842011a8:	bc 01 67 d1 	r4 = M[r5 + 444];
   r6 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0];
842011ac:	d4 01 87 d1 	r6 = M[r5 + 468];

842011b0 <$M.celt.ec_encode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
842011b0:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
842011b4:	0c 00 40 dd 	if NEG jump $M.celt.ec_encode_raw.end_bits_loop;
         r1 = 8 - r4;
842011b8:	08 00 36 65 	r1 = 8 - r4;
         r1 = r6 LSHIFT r1;
842011bc:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
         r1 = r1 AND 0xFF;
842011c0:	ff 00 33 81 	r1 = r1 AND 0xff;
         r1 = r1 OR r7;
842011c4:	00 00 39 87 	r1 = r1 OR r7;
         call $celt.put1byte_to_end;
842011c8:	96 08 f0 e1 	call $celt.put1byte_to_end;
         r4 = -r4;
842011cc:	6f 00 60 20 	r4 = Null - r4;
         r6 = r6 LSHIFT r4;
842011d0:	00 00 86 8f 	r6 = r6 LSHIFT r4;
         r8 = r8 + r4;
842011d4:	00 00 a6 03 	r8 = r8 + r4;
         r4 = 8;
842011d8:	08 00 60 01 	r4 = Null + 8;
         r7 = 0;
842011dc:	00 00 90 01 	r7 = Null + 0;
   jump loop_until_bits_left;
842011e0:	f4 ff f0 dd 	jump $M.celt.ec_encode_raw.loop_until_bits_left;

842011e4 <$M.celt.ec_encode_raw.end_bits_loop>:
   end_bits_loop: 
   r1 = 8 - r4;
842011e4:	08 00 36 65 	r1 = 8 - r4;
   r1 = r6 LSHIFT r1;
842011e8:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
   r1 = r1 AND 0xFF;
842011ec:	ff 00 33 81 	r1 = r1 AND 0xff;
   r1 = r1 OR r7;
842011f0:	00 00 39 87 	r1 = r1 OR r7;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = r1;
842011f4:	b8 01 37 d5 	M[r5 + 440] = r1;

   r4 = r4 - r8;
842011f8:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT] = r4;
842011fc:	bc 01 67 d5 	M[r5 + 444] = r4;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201200:	03 00 00 fd 	jump (m) 0x3b020;
84201204:	21 b0 f0 dd 

84201208 <$celt.ec_enc_tell>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_TELL.PATCH_ID_0,r3)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201208:	00 00 d0 f3 	push rLink;
   // work out number of bits
   r3 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
8420120c:	04 00 57 d1 	r3 = M[r5 + 4];
   r6 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
84201210:	ec 01 87 d1 	r6 = M[r5 + 492];
   r3 = r3 - r6;
84201214:	00 00 58 23 	r3 = r3 - r6;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84201218:	b4 01 27 d1 	r0 = M[r5 + 436];
   r3 = r3 + r0;
8420121c:	00 00 52 03 	r3 = r3 + r0;
   Null = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
84201220:	a0 01 07 d1 	Null = M[r5 + 416];
   if POS r3 = r3 + 1;
84201224:	25 00 55 e4 	if POS r3 = r3 + 1;
   r3 = r3 * $celt.EC_SYM_BITS (int);
84201228:	08 00 55 99 	r3 = r3 * 8 (int);
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS];
8420122c:	c0 01 27 d1 	r0 = M[r5 + 448];
   r3 = r3 + r0;
84201230:	00 00 52 03 	r3 = r3 + r0;
   r3 = r3 + ($celt.EC_CODE_BITS+1);
84201234:	21 00 55 01 	r3 = r3 + 33;
   r3 = r3 LSHIFT r4;
84201238:	00 00 56 8f 	r3 = r3 LSHIFT r4;
         r2 = r2 OR r0;
      jump tel_loop;
   end_tel_loop:
   r0 = r3 - r2;
#else
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420123c:	a4 01 27 d1 	r0 = M[r5 + 420];
#ifdef K32_BITEXACT
   r1 = 0;
84201240:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r2)
84201244:	0f 00 13 00 	rMAC = r1 + Null;
84201248:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
8420124c:	0f 00 41 d8 	r2 = SIGNDET rMAC;
84201250:	3f 00 44 65 	r2 = 63 - r2;
#else   
   r2 = signdet r0;
   r2 = 31 - r2;
#endif   
   r6 = 16 - r2;
84201254:	10 00 84 65 	r6 = 16 - r2;
   r6 = r0 LSHIFT r6;
84201258:	8f 00 82 8c 	r6 = r0 LSHIFT r6;
   r1 = -1;
8420125c:	3f 00 30 e4 	r1 = Null - 1;

84201260 <$M.celt.ec_enc_tell.tel_loop>:
   tel_loop:
      r4 = r4 - 1;
84201260:	3f 00 66 e4 	r4 = r4 - 1;
      if NEG jump end_tel_loop;
84201264:	08 00 40 dd 	if NEG jump $M.celt.ec_enc_tell.end_tel_loop;
         rMAC = r6 * r6;
84201268:	8f 00 18 cc 	rMAC = r6 * r6 (SS);
         r6 = rMAC LSHIFT (32-15-1);
8420126c:	10 00 81 8d 	r6 = rMAC LSHIFT 16;
         r0 = r6 LSHIFT -16;
84201270:	f0 00 28 8d 	r0 = r6 LSHIFT -16;
         if NZ r6 = r6 LSHIFT r1;
84201274:	31 00 88 8c 	if NE r6 = r6 LSHIFT r1;
         r2 = r2 + r2;
84201278:	00 00 44 03 	r2 = r2 + r2;
         r2 = r2 OR r0;
8420127c:	00 00 42 87 	r2 = r2 OR r0;
      jump tel_loop;
84201280:	f8 ff f0 dd 	jump $M.celt.ec_enc_tell.tel_loop;

84201284 <$M.celt.ec_enc_tell.end_tel_loop>:
   end_tel_loop:
   r0 = r3 - r2;
84201284:	4f 00 25 20 	r0 = r3 - r2;
#endif      
   // pop rLink from stack
   jump $pop_rLink_and_rts;   
84201288:	03 00 00 fd 	jump (m) 0x3b020;
8420128c:	21 b0 f0 dd 

84201290 <$celt.ec_enc_bits>:
#endif
   
   // push rLink onto stack
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;;
   pushm <FP(=SP), rLink>;
84201290:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201294:	08 00 03 f1 	SP = SP + 8;
   r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode_raw;
#else
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84201298:	d4 01 27 d1 	r0 = M[r5 + 468];
   M[FP + TEMP_T] = r0;
8420129c:	08 00 2c f1 	M[FP + 0x8] = r0;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
842012a0:	e4 01 47 d1 	r2 = M[r5 + 484];

842012a4 <$M.celt.ec_enc_bits.loop_check_ftb>:
   loop_check_ftb:
      r3 = $celt.EC_UNIT_BITS - r2;    
842012a4:	08 00 54 65 	r3 = 8 - r2;
      if POS jump end_check_ftb;
842012a8:	0b 00 50 dd 	if POS jump $M.celt.ec_enc_bits.end_check_ftb;
      r1 = -r3;
842012ac:	5f 00 30 20 	r1 = Null - r3;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
842012b0:	e4 01 37 d5 	M[r5 + 484] = r1;
      r0 = r0 LSHIFT r3;
842012b4:	00 00 25 8f 	r0 = r0 LSHIFT r3;
      r0 = r0 AND $celt.EC_UNIT_MASK;
842012b8:	ff 00 22 81 	r0 = r0 AND 0xff;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
842012bc:	d4 01 27 d5 	M[r5 + 468] = r0;
      r8 = $celt.EC_UNIT_BITS;
842012c0:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_encode_raw;
842012c4:	b4 ff f0 e1 	call $celt.ec_encode_raw;
      r0 = M[FP + TEMP_T];
842012c8:	08 00 28 f1 	r0 = M[FP + 0x8];
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
842012cc:	e4 01 47 d1 	r2 = M[r5 + 484];
   jump loop_check_ftb;
842012d0:	f5 ff f0 dd 	jump $M.celt.ec_enc_bits.loop_check_ftb;

842012d4 <$M.celt.ec_enc_bits.end_check_ftb>:
   end_check_ftb:
   r8 = r2;
842012d4:	0f 00 a4 00 	r8 = r2 + Null;
   r2 = 1 LSHIFT r2;
842012d8:	01 00 44 e9 	r2 = 0x1 LSHIFT r2;
   r2 = r2 - 1;
842012dc:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r0 AND r2;
842012e0:	00 00 24 83 	r0 = r0 AND r2;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
842012e4:	d4 01 27 d5 	M[r5 + 468] = r0;
   r0 = r0 + 1;
842012e8:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
842012ec:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode_raw;
842012f0:	a9 ff f0 e1 	call $celt.ec_encode_raw;
#endif
  
   SP = SP - STACK_FRAME_SIZE;
842012f4:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
842012f8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842012fc:	0f 00 0d dc 	rts;

84201300 <$celt.ec_enc_uint>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_UINT.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201300:	00 00 d0 f3 	push rLink;
   r1 = r1 + Carry;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 1] = r1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode;
#else // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
84201304:	cc 01 27 d1 	r0 = M[r5 + 460];
   r0 = r0 - 1;
84201308:	3f 00 22 e4 	r0 = r0 - 1;
#ifdef K32_BITEXACT
   r1 = 0;
8420130c:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r2)
84201310:	0f 00 13 00 	rMAC = r1 + Null;
84201314:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84201318:	0f 00 41 d8 	r2 = SIGNDET rMAC;
8420131c:	3f 00 44 65 	r2 = 63 - r2;
#else   
   r2 = signdet r0;
   r2 = 31 - r2;
#endif   
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
84201320:	e4 01 47 d5 	M[r5 + 484] = r2;
   //r0 = _ft, r2 = ftb
   r3 = $celt.EC_UNIT_BITS -r2;
84201324:	08 00 54 65 	r3 = 8 - r2;
   if GT jump inc_ft;
84201328:	12 00 c0 dd 	if GT jump $M.celt.ec_enc_uint.inc_ft;
     r1 = -r3;
8420132c:	5f 00 30 20 	r1 = Null - r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
84201330:	e4 01 37 d5 	M[r5 + 484] = r1;
     r0 = r0 LSHIFT r3;
84201334:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     r0 = r0 + 1;
84201338:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT] = r0;
8420133c:	cc 01 27 d5 	M[r5 + 460] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84201340:	d4 01 27 d1 	r0 = M[r5 + 468];
     push r0;
84201344:	00 00 20 f3 	push r0;
     r0 = r0 LSHIFT r3;
84201348:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
8420134c:	d4 01 27 d5 	M[r5 + 468] = r0;
     r0 = r0 + 1;
84201350:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84201354:	dc 01 27 d5 	M[r5 + 476] = r0;
     call $celt.ec_encode;
84201358:	69 ff f0 e1 	call $celt.ec_encode;
     pop r0;
8420135c:	00 00 24 f3 	pop r0;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84201360:	d4 01 27 d5 	M[r5 + 468] = r0;
     call $celt.ec_enc_bits;
84201364:	cb ff f0 e1 	call $celt.ec_enc_bits;
     jump $pop_rLink_and_rts;
84201368:	03 00 00 fd 	jump (m) 0x3b020;
8420136c:	21 b0 f0 dd 

84201370 <$M.celt.ec_enc_uint.inc_ft>:
   inc_ft:
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84201370:	d4 01 27 d1 	r0 = M[r5 + 468];
   r0 = r0 + 1;
84201374:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84201378:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode;
8420137c:	60 ff f0 e1 	call $celt.ec_encode;
#endif
   
   jump $pop_rLink_and_rts;
84201380:	03 00 00 fd 	jump (m) 0x3b020;
84201384:	21 b0 f0 dd 

84201388 <$celt.end_writing_frame>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.END_WRITING_FRAME.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
84201388:	00 00 d0 f3 	push rLink;
      r8 = r8 AND 0x7F;         
      r6 = r6 + $celt.EC_SYM_BITS;
      jump retry;
   end_carry_out:
#else // K32
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420138c:	a4 01 27 d1 	r0 = M[r5 + 420];
#ifdef K32_BITEXACT
   r1 = 0;
84201390:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r6)
84201394:	0f 00 13 00 	rMAC = r1 + Null;
84201398:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
8420139c:	0f 00 81 d8 	r6 = SIGNDET rMAC;
842013a0:	3f 00 88 65 	r6 = 63 - r6;
#else   
   r6 = signdet r0;
   r6 = 31 - r6;
#endif   
   r6 = r6 - $celt.EC_CODE_BITS;
842013a4:	20 00 88 21 	r6 = r6 - 32;
   r2 = 0x7FFFFFFF;
842013a8:	ff 7f 00 fd 	r2 = Null + 2147483647;
842013ac:	ff ff 40 01 
   r2 = r2 LSHIFT r6;
842013b0:	00 00 48 8f 	r2 = r2 LSHIFT r6;
   //r2 = msk
   r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
842013b4:	ac 01 97 d1 	r7 = M[r5 + 428];
   r0 = r0 + r7;
842013b8:	00 00 29 03 	r0 = r0 + r7;
   r7 = r7 + r2;
842013bc:	00 00 94 03 	r7 = r7 + r2;
   //a = r7
   //b = r2
   //r4= a&~b=(a xo rb) & a   
   r4 = r7 XOR r2;
842013c0:	4f 00 69 88 	r4 = r7 XOR r2;
   r7 = r4 AND r7;
842013c4:	9f 00 96 80 	r7 = r4 AND r7;
   r4 = r7 OR r2;
842013c8:	4f 00 69 84 	r4 = r7 OR r2;
   Null = r4 - r0;
842013cc:	2f 00 06 20 	Null = r4 - r0;
   if NC jump no_msk_up;
842013d0:	07 00 30 dd 	if NC jump $M.celt.end_writing_frame.no_msk_up;
      r6 = r6 - 1;
842013d4:	3f 00 88 e4 	r6 = r6 - 1;
      r2 = r2 LSHIFT -1;
842013d8:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
      r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
842013dc:	ac 01 67 d1 	r4 = M[r5 + 428];
      r7 = r2 + r4;
842013e0:	6f 00 94 00 	r7 = r2 + r4;
      r4 = r7 XOR r2;
842013e4:	4f 00 69 88 	r4 = r7 XOR r2;
      r7 = r4 AND r7;  
842013e8:	9f 00 96 80 	r7 = r4 AND r7;

842013ec <$M.celt.end_writing_frame.no_msk_up>:
   no_msk_up:
   Null = r6;
842013ec:	0f 00 08 00 	Null = r6 + Null;

842013f0 <$M.celt.end_writing_frame.retry>:
   retry:
   if POS jump end_carry_out;
842013f0:	08 00 50 dd 	if POS jump $M.celt.end_writing_frame.end_carry_out;
      r3 = r7 LSHIFT (-$celt.EC_CODE_SHIFT);
842013f4:	e9 00 59 8d 	r3 = r7 LSHIFT -23;
      call $celt.ec_enc_carry_out;
842013f8:	19 ff f0 e1 	call $celt.ec_enc_carry_out;
      r7 = r7 LSHIFT 8;   // shift 1 byte
842013fc:	08 00 99 8d 	r7 = r7 LSHIFT 8;
      r7 = r7 AND 0x7FFFFFFF;
84201400:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
84201404:	ff ff 99 81 
      r6 = r6 + $celt.EC_SYM_BITS;
84201408:	08 00 88 01 	r6 = r6 + 8;
      jump retry;
8420140c:	f9 ff f0 dd 	jump $M.celt.end_writing_frame.retry;

84201410 <$M.celt.end_writing_frame.end_carry_out>:
   end_carry_out:
#endif //K32

   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
84201410:	a0 01 27 d1 	r0 = M[r5 + 416];
   if NEG r0 = 0;
84201414:	04 00 20 00 	if NEG r0 = Null + Null;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84201418:	b4 01 37 d1 	r1 = M[r5 + 436];
   r1 = r1 OR r0;
8420141c:	00 00 32 87 	r1 = r1 OR r0;
   if Z jump end_last_sym;
84201420:	05 00 00 dd 	if EQ jump $M.celt.end_writing_frame.end_last_sym;
      r3 = 0;
84201424:	00 00 50 01 	r3 = Null + 0;
      call $celt.ec_enc_carry_out;
84201428:	0d ff f0 e1 	call $celt.ec_enc_carry_out;
      r0 = -1;
8420142c:	3f 00 20 e4 	r0 = Null - 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r0;
84201430:	a0 01 27 d5 	M[r5 + 416] = r0;

84201434 <$M.celt.end_writing_frame.end_last_sym>:
   end_last_sym:
   
   r10 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
84201434:	ec 01 c7 d1 	r10 = M[r5 + 492];
   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84201438:	f4 01 27 d1 	r0 = M[r5 + 500];
   r10 = r10 + r0;
8420143c:	00 00 c2 03 	r10 = r10 + r0;
   r0 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84201440:	04 00 27 d1 	r0 = M[r5 + 4];
   r10 = r10 - r0;
84201444:	00 00 c2 23 	r10 = r10 - r0;
   if NEG r10 = 0;
84201448:	04 00 c0 00 	if NEG r10 = Null + Null;

   do lp_pad;
8420144c:	03 00 f0 e5 	do $M.celt.end_writing_frame.lp_pad;
      r1 = 0;
84201450:	00 00 30 01 	r1 = Null + 0;
      call $celt.put1byte;
84201454:	d4 07 f0 e1 	call $celt.put1byte;

84201458 <$M.celt.end_writing_frame.lp_pad>:
   lp_pad:
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT];
84201458:	bc 01 27 d1 	r0 = M[r5 + 444];

   Null = r0 - 8;
8420145c:	08 00 02 21 	Null = r0 - 8;
#ifdef DATAFORMAT_32
   if Z jump update_buffer_addr;
84201460:	09 00 00 dd 	if EQ jump $M.celt.end_writing_frame.update_buffer_addr;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE];
84201464:	b8 01 27 d1 	r0 = M[r5 + 440];
      r2 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84201468:	f0 01 47 d1 	r2 = M[r5 + 496];
      r2 = $celt.BYTE_POS_MAX_VALUE - r2;
8420146c:	03 00 44 65 	r2 = 3 - r2;
      r2 = r2 LSHIFT 3;
84201470:	03 00 44 8d 	r2 = r2 LSHIFT 3;
      r0 = r0 LSHIFT r2;
84201474:	00 00 24 8f 	r0 = r0 LSHIFT r2;
      r1 = M[I1, 0];
84201478:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
      r0 = r0 OR r1;
8420147c:	00 00 23 87 	r0 = r0 OR r1;
      M[I1, 0] = r0;
84201480:	00 a4 00 03 	Null = Null + Null, M[I1,0] = r0;

84201484 <$M.celt.end_writing_frame.update_buffer_addr>:
   update_buffer_addr:
      r0 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
84201484:	a4 00 27 d1 	r0 = M[r5 + 164];
      r4 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84201488:	04 00 67 d1 	r4 = M[r5 + 4];
      r0 = $celt.BYTE_POS_MAX_VALUE - r0;
8420148c:	03 00 22 65 	r0 = 3 - r0;
      r1 = r0 + r4;
84201490:	6f 00 32 00 	r1 = r0 + r4;
      r2 = r1 AND 3; //adjust byte pos based on frame size
84201494:	03 00 43 81 	r2 = r1 AND 0x3;
      r2 = $celt.BYTE_POS_MAX_VALUE - r2;
84201498:	03 00 44 65 	r2 = 3 - r2;
      M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r2;
8420149c:	a4 00 47 d5 	M[r5 + 164] = r2;
      r2 = r1 - 1;
842014a0:	3f 00 43 e4 	r2 = r1 - 1;
      r2 = r1 AND ~3;
842014a4:	ff ff 00 fd 	r2 = r1 AND 0xfffffffc;
842014a8:	fc ff 43 81 
   M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r0;
   r2 = r2 + 1;
   r2 = r2 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
   Words2Addr(r2);
#endif
   M0 = r2;
842014ac:	4f 00 80 50 	M0 = Null + r2;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
842014b0:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
842014b4:	03 00 00 fd 	call (m) 0x3a2b0;
842014b8:	b1 a2 f0 e1 
   push r2;
842014bc:	00 00 40 f3 	push r2;
   pop  B0;
842014c0:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_write_address_and_size;
#endif
   I0 = r0;
842014c4:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
842014c8:	3f 00 c0 50 	L0 = Null + r1;
   r0 = M[I0, M0];
842014cc:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   L0 = 0;
842014d0:	00 00 c0 51 	L0 = Null + 0;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
842014d4:	00 00 2b d1 	r0 = M[r9 + 0];
   r1 = I0;
842014d8:	0f 00 30 44 	r1 = Null + I0;
   call $cbuffer.set_write_address;
842014dc:	03 00 00 fd 	call (m) 0x3a320;
842014e0:	21 a3 f0 e1 
   L0 = 0;
842014e4:	00 00 c0 51 	L0 = Null + 0;
   L1 = 0;   
842014e8:	00 00 d0 51 	L1 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
842014ec:	00 00 00 f3 	push Null;
   pop  B0;
842014f0:	00 00 a6 f3 	pop B0;
   push Null;
842014f4:	00 00 00 f3 	push Null;
   pop B1;
842014f8:	00 00 b6 f3 	pop B1;
#endif


   // pop rLink from stack
   jump $pop_rLink_and_rts;
842014fc:	03 00 00 fd 	jump (m) 0x3b020;
84201500:	21 b0 f0 dd 

84201504 <$celt.transient_analysis>:
84201504:	d8 00 27 d1 	r0 = M[r5 + 216];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_ANALYSIS.PATCH_ID_0,r1)     // celt_patchers
#endif   

   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
   I0 = r0;
84201508:	2f 00 00 50 	I0 = Null + r0;
   r4 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
8420150c:	40 00 67 d1 	r4 = M[r5 + 64];
   r0 =  M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84201510:	44 00 27 d1 	r0 = M[r5 + 68];
   r4 = r4 + r0;
84201514:	00 00 62 03 	r4 = r4 + r0;
   M0 = 1 * ADDR_PER_WORD;
84201518:	04 00 80 51 	M0 = Null + 4;
   r10 = r4 - 1;
8420151c:	3f 00 c6 e4 	r10 = r4 - 1;
   r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];
84201520:	e4 00 37 d1 	r1 = M[r5 + 228];
   I1 = r1 , r0 = M[I0, M0];
84201524:	3f 20 10 50 	I1 = Null + r1, r0 = M[I0,M0];
   r1 = r0;
84201528:	0f 00 32 00 	r1 = r0 + Null;
   r7 = 0;
8420152c:	00 00 90 01 	r7 = Null + 0;
   do abs1_loop;
84201530:	05 00 f0 e5 	do $M.celt.transient_analysis.abs1_loop;
      if NEG r1 = -r1, r0 = M[I0, M0];
84201534:	34 20 30 20 	if NEG r1 = Null - r1, r0 = M[I0,M0];
      Null = r7 - r1;
84201538:	3f 00 09 20 	Null = r7 - r1;
      if NEG r7 = r1;          // r7 = max(abs(PREEMPH_LEFT))
8420153c:	04 00 93 00 	if NEG r7 = r1 + Null;
      r1 = r0, M[I1, M0] = r1; // TRANSIENT_PROC[] = abs(PREEMPH_LEFT[])
84201540:	0f b4 32 00 	r1 = r0 + Null, M[I1,M0] = r1;

84201544 <$M.celt.transient_analysis.abs1_loop>:
   abs1_loop:
   if NEG r1 = -r1;
84201544:	34 00 30 20 	if NEG r1 = Null - r1;
   M[I1, M0] = r1;
84201548:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   r0 = signdet r7;
8420154c:	0f 00 29 d8 	r0 = SIGNDET r7;
   r0 = r0 - $celt.MDCT_headroom_bits;
84201550:	05 00 22 21 	r0 = r0 - 5;
   Null = r7;
84201554:	0f 00 09 00 	Null = r7 + Null;
   if Z r0 = 0;
84201558:	00 00 20 00 	if EQ r0 = Null + Null;
   M[r5 + $celt.enc.MAX_SBAND + 0] = r0;
8420155c:	f8 01 27 d5 	M[r5 + 504] = r0;

   
   Null = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201560:	08 00 07 d1 	Null = M[r5 + 8];
   if Z jump end_rch_proc;
84201564:	14 00 00 dd 	if EQ jump $M.celt.transient_analysis.end_rch_proc;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84201568:	24 01 27 d1 	r0 = M[r5 + 292];
      I0 = r0;      
8420156c:	2f 00 00 50 	I0 = Null + r0;
      r10 = r4, r0 = M[I0, M0];   
84201570:	0f 20 c6 00 	r10 = r4 + Null, r0 = M[I0,M0];
      r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];
84201574:	e4 00 37 d1 	r1 = M[r5 + 228];
      I1 = r1;
84201578:	3f 00 10 50 	I1 = Null + r1;
      r7 = 0;
8420157c:	00 00 90 01 	r7 = Null + 0;
      do abs2_loop;
84201580:	08 00 f0 e5 	do $M.celt.transient_analysis.abs2_loop;
         r0 = r0 + Null, r1 = M[I1, 0];
84201584:	00 34 20 03 	r0 = r0 + Null, r1 = M[I1,0];
         if NEG r0 = -r0;
84201588:	24 00 20 20 	if NEG r0 = Null - r0;
         Null = r7 - r0;
8420158c:	2f 00 09 20 	Null = r7 - r0;
         if NEG r7 = r0;                 // r7 = max(abs(PREEMPH_RIGHT))
84201590:	04 00 92 00 	if NEG r7 = r0 + Null;
         Null = r1 - r0;
84201594:	2f 00 03 20 	Null = r1 - r0;
         if NEG r1 = r0, r0 = M[I0, M0]; // TRANSIENT_PROC[] = max( abs(PREEMPH_LEFT), abs(PREEMPH_RIGHT) )
84201598:	04 20 32 00 	if NEG r1 = r0 + Null, r0 = M[I0,M0];
         M[I1, MK1] = r1;         
8420159c:	00 b5 00 03 	Null = Null + Null, M[I1,4] = r1;

842015a0 <$M.celt.transient_analysis.abs2_loop>:
      abs2_loop:
      r0 = signdet r7;
842015a0:	0f 00 29 d8 	r0 = SIGNDET r7;
      r0 = r0 - $celt.MDCT_headroom_bits;
842015a4:	05 00 22 21 	r0 = r0 - 5;
      Null = r7;
842015a8:	0f 00 09 00 	Null = r7 + Null;
      if Z r0 = 0;
842015ac:	00 00 20 00 	if EQ r0 = Null + Null;
      M[r5 + $celt.enc.MAX_SBAND + ADDR_PER_WORD] = r0;
842015b0:	fc 01 27 d5 	M[r5 + 508] = r0;

842015b4 <$M.celt.transient_analysis.end_rch_proc>:
   end_rch_proc:
   r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];//&$celt.enc.begin;
842015b4:	e4 00 37 d1 	r1 = M[r5 + 228];
   I1 = r1;
842015b8:	3f 00 10 50 	I1 = Null + r1;
   I0 = r1;
842015bc:	3f 00 00 50 	I0 = Null + r1;
   r10 = r4 - 1;
842015c0:	3f 00 c6 e4 	r10 = r4 - 1;
   r1 = 0, r0 = M[I0, M0];
842015c4:	0f 20 30 00 	r1 = Null + Null, r0 = M[I0,M0];
   Null = r1 - r0;
842015c8:	2f 00 03 20 	Null = r1 - r0;
   do max_loop;
842015cc:	03 00 f0 e5 	do $M.celt.transient_analysis.max_loop;
      if NEG r1 = r0, r0 = M[I0, M0];
842015d0:	04 20 32 00 	if NEG r1 = r0 + Null, r0 = M[I0,M0];
      Null = r1 - r0, M[I1, M0] = r1;
842015d4:	2f b4 03 20 	Null = r1 - r0, M[I1,M0] = r1;

842015d8 <$M.celt.transient_analysis.max_loop>:
   max_loop:
   if NEG r1 = r0;
842015d8:	04 00 32 00 	if NEG r1 = r0 + Null;
   M[I1, M0] = r1;
842015dc:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;

   M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = Null;
842015e0:	58 01 07 d5 	M[r5 + 344] = Null;
   r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
842015e4:	58 00 27 d1 	r0 = M[r5 + 88];
   Null = r0 - 2;
842015e8:	cf 00 02 e4 	Null = r0 - 2;
   if NEG rts;
842015ec:	04 00 0d dc 	if NEG rts;

   r2 = r1*0.2(frac);
842015f0:	99 19 00 fd 	r2 = r1 * 0.200000000186264514923095703125 (frac);
842015f4:	9a 99 43 95 
   r6 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];  //&$celt.enc.begin;
842015f8:	e4 00 87 d1 	r6 = M[r5 + 228];
   I0 = r6 + 8 * ADDR_PER_WORD;
842015fc:	20 00 08 51 	I0 = r6 + 32;
   I1 = r6;
84201600:	8f 00 10 50 	I1 = Null + r6;
   r10 = r4 - 16;
84201604:	10 00 c6 21 	r10 = r4 - 16;
   r0 = M[I0, M0];
84201608:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   do search_loop;
8420160c:	03 00 f0 e5 	do $M.celt.transient_analysis.search_loop;
      Null = r0 - r2, r0 = M[I0, M0];
84201610:	4f 20 02 20 	Null = r0 - r2, r0 = M[I0,M0];
      if NEG I1 = I0;
84201614:	04 00 10 58 	if NEG I1 = I0 + Null;

84201618 <$M.celt.transient_analysis.search_loop>:
   search_loop:
   r2 = I1 - r6;
84201618:	8f 00 41 68 	r2 = I1 - r6;
   r2 = r2 - 2 * ADDR_PER_WORD;
8420161c:	08 00 44 21 	r2 = r2 - 8;
   r0 = 0;
84201620:	00 00 20 01 	r0 = Null + 0;
   r3 = r2 - 32 * ADDR_PER_WORD;
84201624:	80 00 54 21 	r3 = r2 - 128;
   if NEG rts;
84201628:	04 00 0d dc 	if NEG rts;
   rMAC = 0;      // r2 = n, r1 = max = begin[len-1]
8420162c:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r1;
84201630:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
   r3 = r2 + r6;
84201634:	8f 00 54 00 	r3 = r2 + r6;
   r0 = M[r3 -1*ADDR_PER_WORD];
84201638:	fc ff 25 d1 	r0 = M[r3 + -4];
   r0 = r0 LSHIFT -1;
8420163c:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
   r0 = r0 + $celt.HALF_Q15_LSB_DIV2;
84201640:	00 40 22 01 	r0 = r0 + 16384;
   Div = rMAC/r0;
84201644:	00 00 12 d9 	Div = rMAC / r0;
   // ratio = ((begin[len - 1]) / (1 + begin[n - 16]));
   r0 = DivResult;  // output format = QX.1, ie a ratio of 2.0 will yield an integer of 4
84201648:	01 00 20 d9 	r0 = DivResult;
   Null = r0 - 10; // 5.0 
8420164c:	0a 00 02 21 	Null = r0 - 10;
   if NEG rts;
84201650:	04 00 0d dc 	if NEG rts;
   r8 = r2;
84201654:	0f 00 a4 00 	r8 = r2 + Null;
   Addr2Words(r2);      
84201658:	fe 00 44 91 	r2 = r2 ASHIFT -2;
   M[r5 + $celt.enc.TRANSIENT_TIME_FIELD] = r2;   
8420165c:	64 01 47 d5 	M[r5 + 356] = r2;
   r1 = 3;
84201660:	03 00 30 01 	r1 = Null + 3;
   Null = r0 - $celt.SQRT_2048_MULT2;
84201664:	5a 00 02 21 	Null = r0 - 90;
   if NEG r1 = 0;
84201668:	04 00 30 00 	if NEG r1 = Null + Null;
   M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD] = r1;
8420166c:	68 01 37 d5 	M[r5 + 360] = r1;
   if Z jump end;
84201670:	1c 00 00 dd 	if EQ jump $M.celt.transient_analysis.end;
   
   r7 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201674:	08 00 97 d1 	r7 = M[r5 + 8];
   r6 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
84201678:	d8 00 87 d1 	r6 = M[r5 + 216];
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_INV_TRANSIENT_WINDOW_TABLE_FIELD];
8420167c:	0c 02 27 d1 	r0 = M[r5 + 524];
   I7 = r0;
84201680:	2f 00 70 50 	I7 = Null + r0;

84201684 <$M.celt.transient_analysis.chan_win_loop>:
#endif // CELT_USE_EXTERNAL_MEMORY   
   chan_win_loop:
#ifdef CELT_USE_EXTERNAL_MEMORY
      I4 = I7;
84201684:	0f 00 47 58 	I4 = I7 + Null;
#else
      I4 = &$celt.inv_transientWindow;
#endif
      I0 = r6 + r8;
84201688:	af 00 08 50 	I0 = r6 + r8;
      I0 = I0 - 16 * ADDR_PER_WORD;
8420168c:	40 00 00 79 	I0 = I0 - 64;
      I1 = I0;
84201690:	0f 00 10 58 	I1 = I0 + Null;
      r10 = 15;
84201694:	0f 00 c0 01 	r10 = Null + 15;
      r0 = M[I0, MK1], r1 = M[I4, MK1];
84201698:	31 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I4,4];
      r3 = r0 * r1 (frac);
8420169c:	3f 00 52 94 	r3 = r0 * r1 (frac);
      do tran_win_loop;
842016a0:	03 00 f0 e5 	do $M.celt.transient_analysis.tran_win_loop;
         r0 = M[I0, MK1], r1 = M[I4, MK1];
842016a4:	31 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I4,4];
         r3 = r0 * r1 (frac), M[I1, M0] = r3;
842016a8:	3f d4 52 94 	r3 = r0 * r1 (frac), M[I1,M0] = r3;

842016ac <$M.celt.transient_analysis.tran_win_loop>:
      tran_win_loop:
      M[I1, M0] = r3;
842016ac:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;
      r1 = 0.125;
842016b0:	00 10 00 fd 	r1 = Null + 268435456;
842016b4:	00 00 30 01 
      r10 = r4 - r2, r0 = M[I0, M0];
842016b8:	4f 20 c6 20 	r10 = r4 - r2, r0 = M[I0,M0];
      r10 = r10 - 1;
842016bc:	3f 00 cc e4 	r10 = r10 - 1;
      do tran_wing_loop;
842016c0:	03 00 f0 e5 	do $M.celt.transient_analysis.tran_wing_loop;
         r3 = r1 * r0 (frac), r0 = M[I0, M0];
842016c4:	2f 20 53 94 	r3 = r1 * r0 (frac), r0 = M[I0,M0];
         M[I1, M0] = r3;
842016c8:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;

842016cc <$M.celt.transient_analysis.tran_wing_loop>:
      tran_wing_loop:
      r3 = r1 * r0 (frac);
842016cc:	2f 00 53 94 	r3 = r1 * r0 (frac);
      M[I1, M0] = r3;
842016d0:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;
      r6 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
842016d4:	24 01 87 d1 	r6 = M[r5 + 292];
      r7 = r7 - 1;
842016d8:	3f 00 99 e4 	r7 = r7 - 1;
   if POS jump chan_win_loop;
842016dc:	ea ff 50 dd 	if POS jump $M.celt.transient_analysis.chan_win_loop;

842016e0 <$M.celt.transient_analysis.end>:
   end:
   r0 = $celt.FLAG_SHORT;
842016e0:	00 08 20 01 	r0 = Null + 2048;
   M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = r0;
842016e4:	58 01 27 d5 	M[r5 + 344] = r0;
   r0 = $celt.FLAG_FOLD;
842016e8:	00 04 20 01 	r0 = Null + 1024;
   M[r5 + $celt.enc.HAS_FOLD_FIELD] = r0;   
842016ec:	60 01 27 d5 	M[r5 + 352] = r0;
   rts;
842016f0:	0f 00 0d dc 	rts;

842016f4 <$celt.mdct_shape>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.MDCT_SHAPE.PATCH_ID_0,r4)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
842016f4:	00 00 d0 f3 	push rLink;
   
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842016f8:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
842016fc:	01 00 62 51 	I6 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84201700:	58 00 27 d1 	r0 = M[r5 + 88];
   M0 = r0;
84201704:	2f 00 80 50 	M0 = Null + r0;
   Words2Addr(r0);
84201708:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
8420170c:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
84201710:	5c 00 27 d1 	r0 = M[r5 + 92];
   I7 = r0;
84201714:	2f 00 70 50 	I7 = Null + r0;
   r4 = M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD];
84201718:	6c 01 67 d1 	r4 = M[r5 + 364];
   r4 = -r4;
8420171c:	6f 00 60 20 	r4 = Null - r4;
   r0 = M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD];
84201720:	70 01 27 d1 	r0 = M[r5 + 368];
   M1 = r0 + 1; //end point
84201724:	01 00 92 51 	M1 = r0 + 1;
   Words2Addr(r0);
84201728:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M2 = r0 + ADDR_PER_WORD;
8420172c:	04 00 a2 51 	M2 = r0 + 4;
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84201730:	cc 00 27 d1 	r0 = M[r5 + 204];
   I3 = r0 + M2; //X
84201734:	af 00 32 54 	I3 = r0 + M2;
   NULL = r8;
84201738:	0f 00 0a 00 	Null = r8 + Null;
   if Z jump setup_done;   
8420173c:	03 00 00 dd 	if EQ jump $M.celt.mdct_shape.chan_shape_loop;
      I3 = r0 + M3;
84201740:	bf 00 32 54 	I3 = r0 + M3;
      M1 = M0 - M1;
84201744:	9f 00 98 7c 	M1 = M0 - M1;

84201748 <$M.celt.mdct_shape.chan_shape_loop>:
   setup_done:   
   chan_shape_loop:
      M2 = M1;
84201748:	0f 00 a9 58 	M2 = M1 + Null;
      r0 = M2;
8420174c:	af 00 20 44 	r0 = Null + M2;

84201750 <$M.celt.mdct_shape.block_loop>:
      block_loop: 
         r10 = I7 - 1;
84201750:	01 00 c7 69 	r10 = I7 - 1;
         Words2Addr(r0);
84201754:	02 00 22 91 	r0 = r0 ASHIFT 2;
         I4 = I3 - r0;
84201758:	2f 00 43 78 	I4 = I3 - r0;
         I2 = I4;
8420175c:	0f 00 24 58 	I2 = I4 + Null;
         r0 = M[I2, M3];
84201760:	00 2b 00 02 	Null = Null + Null, r0 = M[I2,M3];
         do shift_loop;
84201764:	03 00 f0 e5 	do $M.celt.mdct_shape.shift_loop;
            r1 = r0 ASHIFT r4, r0 = M[I2, M3];
84201768:	6f 2b 32 90 	r1 = r0 ASHIFT r4, r0 = M[I2,M3];
            M[I4, M3] = r1;
8420176c:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;

84201770 <$M.celt.mdct_shape.shift_loop>:
         shift_loop:
         r1 = r0 ASHIFT r4; 
84201770:	6f 00 32 90 	r1 = r0 ASHIFT r4;
         M[I4, M3] = r1;
84201774:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;
         M2 = M2 - 1;
84201778:	01 00 aa 79 	M2 = M2 - 1;
	 r0 = M2;
8420177c:	af 00 20 44 	r0 = Null + M2;
      if NZ jump block_loop;
84201780:	f4 ff 10 dd 	if NE jump $M.celt.mdct_shape.block_loop;
      r0 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84201784:	44 00 27 d1 	r0 = M[r5 + 68];
      Words2Addr(r0);
84201788:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I3 = I3 + r0;
8420178c:	00 00 32 5b 	I3 = I3 + r0;
      I6 = I6 - 1;
84201790:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_shape_loop;
84201794:	ed ff 10 dd 	if NE jump $M.celt.mdct_shape.chan_shape_loop;
   call $celt.renormalise_bands;
84201798:	cb 02 f0 e1 	call $celt.renormalise_bands;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420179c:	03 00 00 fd 	jump (m) 0x3b020;
842017a0:	21 b0 f0 dd 

842017a4 <$celt.transient_block_process>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_BLOCK_PROCESS.PATCH_ID_0,r2)     // celt_patchers
#endif 
   
   // push rLink onto stack
    push rlink;
842017a4:	00 00 d0 f3 	push rLink;
    r2 = 0;  // 
842017a8:	00 00 40 01 	r2 = Null + 0;
    r3 = 1;  //
842017ac:	2f 00 50 e4 	r3 = Null + 1;
    Null = M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD];
842017b0:	68 01 07 d1 	Null = M[r5 + 360];
    if NZ jump  set_weight_pos;
842017b4:	29 00 10 dd 	if NE jump $M.celt.transient_block_process.set_weight_pos;
    r4 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
842017b8:	cc 00 67 d1 	r4 = M[r5 + 204];
    I2 = r4;
842017bc:	6f 00 20 50 	I2 = Null + r4;
    r6 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
842017c0:	58 00 87 d1 	r6 = M[r5 + 88];
    M0 = r6;
842017c4:	8f 00 80 50 	M0 = Null + r6;
    Words2Addr(r6);
842017c8:	02 00 88 91 	r6 = r6 ASHIFT 2;
    M3 = r6;
842017cc:	8f 00 b0 50 	M3 = Null + r6;
    Addr2Words(r6);
842017d0:	fe 00 88 91 	r6 = r6 ASHIFT -2;
    M2 = 1;
842017d4:	01 00 a0 51 	M2 = Null + 1;
    r7 = 1.0; //sum(m)
842017d8:	ff 7f 00 fd 	r7 = Null + 2147483647;
842017dc:	ff ff 90 01 
    r1 = 1.0/64;    
842017e0:	00 02 00 fd 	r1 = Null + 33554432;
842017e4:	00 00 30 01 

842017e8 <$M.celt.transient_block_process.block_loop>:
    block_loop:
       r10 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
842017e8:	5c 00 c7 d1 	r10 = M[r5 + 92];
       r10 = r10 - M2, r0 = M[I2, M3];
842017ec:	00 2b ca 66 	r10 = r10 - M2, r0 = M[I2,M3];
       rMAC = 0;
842017f0:	00 00 10 01 	rMAC = Null + 0;
       do calc_abssum_loop;
842017f4:	04 00 f0 e5 	do $M.celt.transient_block_process.calc_abssum_loop;
          Null = r0;
842017f8:	0f 00 02 00 	Null = r0 + Null;
          if NEG r0 = -r0;
842017fc:	24 00 20 20 	if NEG r0 = Null - r0;
          rMAC = rMAC + r0*r1, r0 = M[I2, M3];
84201800:	3f 2b 12 ac 	rMAC = rMAC + r0 * r1 (SS), r0 = M[I2,M3];

84201804 <$M.celt.transient_block_process.calc_abssum_loop>:
       calc_abssum_loop:
       Null = r0;
84201804:	0f 00 02 00 	Null = r0 + Null;
       if NEG r0 = -r0;
84201808:	24 00 20 20 	if NEG r0 = Null - r0;
       rMAC = rMAC + r0*r1, r0 = M[I2, M3];
8420180c:	3f 2b 12 ac 	rMAC = rMAC + r0 * r1 (SS), r0 = M[I2,M3];
       r4 = r4 + ADDR_PER_WORD;
84201810:	bf 00 66 e4 	r4 = r4 + 4;
       I2 = r4;
84201814:	6f 00 20 50 	I2 = Null + r4;
       r8 = r7 ASHIFT 3;
84201818:	03 00 a9 91 	r8 = r7 ASHIFT 3;
       Null = rMAC - r8;
8420181c:	af 00 01 20 	Null = rMAC - r8;
       if LE jump check_lower_w;
84201820:	04 00 d0 dd 	if LE jump $M.celt.transient_block_process.check_lower_w;
          r2 = 2;
84201824:	af 00 40 e4 	r2 = Null + 2;
          r3 = M0 - r6;
84201828:	8f 00 58 68 	r3 = M0 - r6;
          jump end;
8420182c:	08 00 f0 dd 	jump $M.celt.transient_block_process.end;

84201830 <$M.celt.transient_block_process.check_lower_w>:
       check_lower_w:
       Null = r2 - 2;
84201830:	cf 00 04 e4 	Null = r2 - 2;
       if POS jump end;
84201834:	06 00 50 dd 	if POS jump $M.celt.transient_block_process.end;
       r8 = r7 ASHIFT 1;
84201838:	01 00 a9 91 	r8 = r7 ASHIFT 1;
       Null = rMAC - r8;
8420183c:	af 00 01 20 	Null = rMAC - r8;
       if LE jump end;
84201840:	03 00 d0 dd 	if LE jump $M.celt.transient_block_process.end;
          r2 = 1;
84201844:	2f 00 40 e4 	r2 = Null + 1;
          r3 = M0 - r6;        
84201848:	8f 00 58 68 	r3 = M0 - r6;

8420184c <$M.celt.transient_block_process.end>:
    end:
    r7 = rMAC;
8420184c:	0f 00 91 00 	r7 = rMAC + Null;
    r6 = r6 - 1;
84201850:	3f 00 88 e4 	r6 = r6 - 1;
    if NZ jump block_loop;
84201854:	e5 ff 10 dd 	if NE jump $M.celt.transient_block_process.block_loop;

84201858 <$M.celt.transient_block_process.set_weight_pos>:
    set_weight_pos:
    r8 = $celt.CELT_ENCODER;
84201858:	2f 00 a0 e4 	r8 = Null + 1;
    r3 = r3 - 1;
8420185c:	3f 00 55 e4 	r3 = r3 - 1;
    M[r5 + $celt.enc.MDCT_WEIGHT_POS_FIELD] = r3;
84201860:	70 01 57 d5 	M[r5 + 368] = r3;
    M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD] = r2;
84201864:	6c 01 47 d5 	M[r5 + 364] = r2;
    if NZ call  $celt.mdct_shape;
84201868:	a3 ff 10 e1 	if NE call $celt.mdct_shape;
    

   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420186c:	03 00 00 fd 	jump (m) 0x3b020;
84201870:	21 b0 f0 dd 

84201874 <$celt.quant_bands>:
84201874:	00 00 d0 f3 	push rLink;
   .CONST STACK_USED 3*ADDR_PER_WORD;

   // push rLink onto stack
   push rlink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>;
84201878:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED;
8420187c:	0c 00 03 f1 	SP = SP + 12;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84201880:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84201884:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84201888:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
8420188c:	0f 00 7b 58 	I7 = M3 + Null;
   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84201890:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
84201894:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84201898:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
8420189c:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
842018a0:	04 00 4c f1 	M[FP + 0x4] = r2;
   r1 = 0;
842018a4:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
842018a8:	08 00 3c f1 	M[FP + 0x8] = r1;

   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
842018ac:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
842018b0:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
842018b4:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
842018b8:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
842018bc:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842018c0:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
842018c4:	2f 00 20 50 	I2 = Null + r0;

842018c8 <$M.celt.quant_bands.quant_bands_main_loop>:
   quant_bands_main_loop:
      // get bit used so far
      r4 = $celt.BITRES;
842018c8:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
842018cc:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0;
842018d0:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
842018d4:	08 00 38 f1 	r1 = M[FP + 0x8];
      r2 = I7 - M3;
842018d8:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
842018dc:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
842018e0:	08 00 3c f1 	M[FP + 0x8] = r1;
      r1 = r1 - r0;
842018e4:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
842018e8:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
842018ec:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
842018f0:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
842018f4:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
842018f8:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
842018fc:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84201900:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
84201904:	05 00 40 dd 	if NEG jump $M.celt.quant_bands.chk_2;
         r1 = r1 -1;
84201908:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
8420190c:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84201910:	ab aa 33 95 
         jump end_cur_calc;
84201914:	04 00 f0 dd 	jump $M.celt.quant_bands.end_cur_calc;

84201918 <$M.celt.quant_bands.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84201918:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
8420191c:	02 00 10 dd 	if NE jump $M.celt.quant_bands.end_cur_calc;
         r1 = r1 ASHIFT -1;
84201920:	ff 00 33 91 	r1 = r1 ASHIFT -1;

84201924 <$M.celt.quant_bands.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
84201924:	00 00 35 9b 	r1 = r1 * r3 (int);

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84201928:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
8420192c:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84201930:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
84201934:	08 00 28 f1 	r0 = M[FP + 0x8];
      r3 = M[r3];
84201938:	00 00 50 d3 	r3 = M[r3 + Null];
      push r3;
8420193c:	00 00 50 f3 	push r3;
      r3 = r0 + r3;
84201940:	5f 00 52 00 	r3 = r0 + r3;
      M[FP + BAL] = r3;
84201944:	08 00 5c f1 	M[FP + 0x8] = r3;
      pop r3;
84201948:	00 00 54 f3 	pop r3;
      r1 = r1 + r3;
8420194c:	00 00 35 03 	r1 = r1 + r3;
      call $celt.bits2pulses;
84201950:	41 02 f0 e1 	call $celt.bits2pulses;
      Words2Addr(r0);
84201954:	02 00 22 91 	r0 = r0 ASHIFT 2;
      //r0 = n
      r2 = M[r4 + r0];
84201958:	2f 00 46 d0 	r2 = M[r4 + r0];
      I5 = I5 - r2;
8420195c:	00 00 54 7b 	I5 = I5 - r2;

84201960 <$M.celt.quant_bands.loop_rem_bits>:
      loop_rem_bits:
         Null = I5;
84201960:	00 00 05 47 	Null = Null + I5;
         if POS jump end_loop_rem_bits;
84201964:	08 00 50 dd 	if POS jump $M.celt.quant_bands.end_loop_rem_bits;
         Null = r0 - Null;
84201968:	0f 00 02 20 	Null = r0 - Null;
         if LE jump end_loop_rem_bits;
8420196c:	06 00 d0 dd 	if LE jump $M.celt.quant_bands.end_loop_rem_bits;
            I5 = I5 + r2;
84201970:	00 00 54 5b 	I5 = I5 + r2;
            r0 = r0 - ADDR_PER_WORD;
84201974:	df 00 22 e4 	r0 = r0 - 4;
            r2 = M[r4 + r0];
84201978:	2f 00 46 d0 	r2 = M[r4 + r0];
            I5 = I5 - r2;
8420197c:	00 00 54 7b 	I5 = I5 - r2;
         jump loop_rem_bits;
84201980:	f8 ff f0 dd 	jump $M.celt.quant_bands.loop_rem_bits;

84201984 <$M.celt.quant_bands.end_loop_rem_bits>:
      end_loop_rem_bits:

      // save some registers into stack

      push r5;
84201984:	00 00 70 f3 	push r5;
      pushm<I2, I5, I6, I7, M3>;
84201988:	e4 08 01 f1 	pushm <I2, I5, I6, I7, M3>;

      r2 = M[FP + CUR_B];
8420198c:	04 00 48 f1 	r2 = M[FP + 0x4];
      r1 = M[I2, MK1];
84201990:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, -MK1];
84201994:	00 5b 00 03 	Null = Null + Null, r3 = M[I2,-4];
      r3 = r3 - r1;
84201998:	00 00 53 23 	r3 = r3 - r1;
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
8420199c:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
842019a0:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
842019a4:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses (AU)
      // r1 = start bin no (AU)
      // r3 = band width
      // r2 = nr of Blocks
      Addr2Words(r0);
842019a8:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      r4 = r0 - Null;
842019ac:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
842019b0:	07 00 d0 dd 	if LE jump $M.celt.quant_bands.intra_act;
         //calc spread
         M0 = r2;
842019b4:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
842019b8:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
842019bc:	80 00 88 7c 	if EQ M0 = M0 - M0;
         //call  $celt.alg_unquant;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
842019c0:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
842019c4:	0f 00 02 e0 	call r0;
         jump end_act;
842019c8:	05 00 f0 dd 	jump $M.celt.quant_bands.end_act;

842019cc <$M.celt.quant_bands.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
842019cc:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
842019d0:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
842019d4:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
842019d8:	5b 02 f0 e1 	call $celt.intra_fold;

842019dc <$M.celt.quant_bands.end_act>:
      end_act:

      // restore trashed register
       popm<I2, I5, I6, I7, M3>;
842019dc:	e4 08 05 f1 	popm <I2, I5, I6, I7, M3>;
       pop r5;
842019e0:	00 00 74 f3 	pop r5;

      // get start and end of band (again!)
      r1 = M[I2, MK1];
842019e4:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, 0];
842019e8:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];

      // calc norm for next folded band
      // calc only when needed!
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842019ec:	48 00 27 d1 	r0 = M[r5 + 72];
      Words2Addr(r0);
842019f0:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - M3;
842019f4:	00 00 2b 67 	r0 = r0 - M3;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
842019f8:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
842019fc:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
84201a00:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
84201a04:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r3 - r1;
84201a08:	3f 00 c5 20 	r10 = r3 - r1;
      r10 = r10 - 1;
84201a0c:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
84201a10:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
84201a14:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84201a18:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84201a1c:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
84201a20:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
84201a24:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c TODO:
84201a28:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
84201a2c:	03 00 f0 e5 	do $M.celt.quant_bands.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
84201a30:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
84201a34:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

84201a38 <$M.celt.quant_bands.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
84201a38:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
84201a3c:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      M3 = M3 - ADDR_PER_WORD;
84201a40:	04 00 bb 79 	M3 = M3 - 4;
   if NZ jump quant_bands_main_loop;
84201a44:	a1 ff 10 dd 	if NE jump $M.celt.quant_bands.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
84201a48:	f4 ff 03 f1 	SP = SP + -12;
   popm<FP>;
84201a4c:	00 40 06 f1 	popm <FP>;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201a50:	03 00 00 fd 	jump (m) 0x3b020;
84201a54:	21 b0 f0 dd 

84201a58 <$celt.unquant_bands_stereo>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_BANDS_STEREO.PATCH_ID_0,r3)     // celt_patchers
#endif 

   r0 = $celt.CELT_DECODER;
84201a58:	00 00 20 01 	r0 = Null + 0;
   jump set_codec;
84201a5c:	02 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_codec;

84201a60 <$celt.quant_bands_stereo>:
   
   // -- entry point for quant (encoder)
   $celt.quant_bands_stereo:
   r0 = $celt.CELT_ENCODER;
84201a60:	2f 00 20 e4 	r0 = Null + 1;

84201a64 <$M.celt.unquant_bands_stereo.set_codec>:
   .CONST CODEC            22*ADDR_PER_WORD;
   .CONST STACK_USED       23*ADDR_PER_WORD;
   

   // push rLink onto stack
   push rlink;
84201a64:	00 00 d0 f3 	push rLink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>; 
84201a68:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED; 
84201a6c:	5c 00 03 f1 	SP = SP + 92;
   
   M[FP + CODEC] = r0;
84201a70:	58 00 2c f1 	M[FP + 0x58] = r0;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84201a74:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84201a78:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84201a7c:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
84201a80:	0f 00 7b 58 	I7 = M3 + Null;

   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84201a84:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
84201a88:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84201a8c:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
84201a90:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
84201a94:	4c 00 4c f1 	M[FP + 0x4c] = r2;
   r1 = 0;
84201a98:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
84201a9c:	50 00 3c f1 	M[FP + 0x50] = r1;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84201aa0:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
84201aa4:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
84201aa8:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84201aac:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
84201ab0:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84201ab4:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
84201ab8:	2f 00 20 50 	I2 = Null + r0;

84201abc <$M.celt.unquant_bands_stereo.quant_bands_main_loop>:


quant_bands_main_loop:

      // get bit used so far
      r4 = $celt.BITRES;
84201abc:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84201ac0:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0; 
84201ac4:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
84201ac8:	50 00 38 f1 	r1 = M[FP + 0x50];
      r2 = I7 - M3;
84201acc:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
84201ad0:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
84201ad4:	50 00 3c f1 	M[FP + 0x50] = r1;
      r1 = r1 - r0;
84201ad8:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
84201adc:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
84201ae0:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
84201ae4:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
84201ae8:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
84201aec:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
84201af0:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84201af4:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
84201af8:	05 00 40 dd 	if NEG jump $M.celt.unquant_bands_stereo.chk_2;
         r1 = r1 -1;
84201afc:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
84201b00:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84201b04:	ab aa 33 95 
         jump end_cur_calc;
84201b08:	04 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_cur_calc;

84201b0c <$M.celt.unquant_bands_stereo.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84201b0c:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
84201b10:	02 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_cur_calc;
         r1 = r1 ASHIFT -1;
84201b14:	ff 00 33 91 	r1 = r1 ASHIFT -1;

84201b18 <$M.celt.unquant_bands_stereo.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
84201b18:	00 00 35 9b 	r1 = r1 * r3 (int);

      r0 = M[I2, MK1];
84201b1c:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
      M[FP + S_BAND] = r0;
84201b20:	20 00 2c f1 	M[FP + 0x20] = r0;
      r3 = M[I2, 0];
84201b24:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];
      r0 = r3 - r0;
84201b28:	2f 00 25 20 	r0 = r3 - r0;
      rMAC = 0;
84201b2c:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r0;
84201b30:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
      M[FP + N_BAND] = r0;
84201b34:	1c 00 2c f1 	M[FP + 0x1c] = r0;

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84201b38:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
84201b3c:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84201b40:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
84201b44:	50 00 28 f1 	r0 = M[FP + 0x50];
      r3 = M[r3];       // r3 = pulses[I7-M3]
84201b48:	00 00 50 d3 	r3 = M[r3 + Null];
      r0 = r0 + r3;     // r0 = r0 + pulses[I7-M3]
84201b4c:	00 00 25 03 	r0 = r0 + r3;
      M[FP + BAL] = r0;
84201b50:	50 00 2c f1 	M[FP + 0x50] = r0;

      r8 = I5 + 1;
84201b54:	01 00 a5 49 	r8 = I5 + 1;
      r1 = r1 + r3;
84201b58:	00 00 35 03 	r1 = r1 + r3;
      if NEG r1 = 0;
84201b5c:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r8 - r1;
84201b60:	3f 00 0a 20 	Null = r8 - r1;
      if POS r8 = r1;
84201b64:	05 00 a3 00 	if POS r8 = r1 + Null;
      M[FP + VB] = r8;
84201b68:	38 00 ac f1 	M[FP + 0x38] = r8;

      r0 = $celt.BITRES;
84201b6c:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84201b70:	b9 05 f0 e1 	call $celt.log2_frac;
      r0 = $celt.QTHETA_OFFSET - r0;
84201b74:	28 00 22 65 	r0 = 40 - r0;
      r1 = M[FP + N_BAND];
84201b78:	1c 00 38 f1 	r1 = M[FP + 0x1c];
      r2 = r1 - 1;
84201b7c:	3f 00 43 e4 	r2 = r1 - 1;
      r1 = r2 + r2;
84201b80:	4f 00 34 00 	r1 = r2 + r2;
      r1 = r1 * r0(int);
84201b84:	00 00 32 9b 	r1 = r1 * r0 (int);
      r1 = r8 - r1;
84201b88:	3f 00 3a 20 	r1 = r8 - r1;
      if NEG r1 = 0;
84201b8c:	04 00 30 00 	if NEG r1 = Null + Null;

      r2 = r2 LSHIFT 5;
84201b90:	05 00 44 8d 	r2 = r2 LSHIFT 5;
      rMAC = 0;
84201b94:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84201b98:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      Div = rMAC / r2;
84201b9c:	00 00 14 d9 	Div = rMAC / r2;
      r7 = r8 LSHIFT (-$celt.BITRES);
84201ba0:	fc 00 9a 8d 	r7 = r8 LSHIFT -4;
      r7 = r7 - 1;
84201ba4:	3f 00 99 e4 	r7 = r7 - 1;
      if NEG r7 = 0;
84201ba8:	04 00 90 00 	if NEG r7 = Null + Null;
      r0 = DivResult;
84201bac:	01 00 20 d9 	r0 = DivResult;
      Null = r0 - r7;
84201bb0:	9f 00 02 20 	Null = r0 - r7;
      if POS r0 = r7;
84201bb4:	05 00 29 00 	if POS r0 = r7 + Null;
      r1 = r0 - 14;
84201bb8:	0e 00 32 21 	r1 = r0 - 14;
      if POS r0 = r0 - r1;
84201bbc:	35 00 22 20 	if POS r0 = r0 - r1;
      M[FP + QB] = r0;
84201bc0:	54 00 2c f1 	M[FP + 0x54] = r0;
      r1 = 1 LSHIFT r0;
84201bc4:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
      r1 = r1 + 1;
84201bc8:	2f 00 33 e4 	r1 = r1 + 1;
      rMAC = 0;
84201bcc:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84201bd0:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES;
84201bd4:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84201bd8:	9f 05 f0 e1 	call $celt.log2_frac;
      M[FP + QALLOC] = r0;
84201bdc:	24 00 2c f1 	M[FP + 0x24] = r0;

      // -- save some registers

      // to guaranteen we will always have the same push sequence for different chips, avoid using "pushm" here
      // I5, I6, I7, I2, M3, r5
      r3 = I5;
84201be0:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
84201be4:	04 00 5c f1 	M[FP + 0x4] = r3;
      r3 = I6;
84201be8:	6f 00 50 44 	r3 = Null + I6;
      M[FP + TOTOAL_BITS] = r3;
84201bec:	08 00 5c f1 	M[FP + 0x8] = r3;
      r3 = I7;
84201bf0:	7f 00 50 44 	r3 = Null + I7;
      M[FP + NB_EBAND] = r3;
84201bf4:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r3 = I2;
84201bf8:	2f 00 50 44 	r3 = Null + I2;
      M[FP + ADDR_EBAND] = r3;
84201bfc:	10 00 5c f1 	M[FP + 0x10] = r3;
      r3 = M3;
84201c00:	bf 00 50 44 	r3 = Null + M3;
      M[FP + NB_EBAND_RM] = r3;
84201c04:	14 00 5c f1 	M[FP + 0x14] = r3;
      M[FP + CODEC_STRUC] = r5;
84201c08:	18 00 7c f1 	M[FP + 0x18] = r5;

      // -- stereo processing required for encode
      Null = M[FP + CODEC];
84201c0c:	58 00 08 f1 	Null = M[FP + 0x58];
      if Z jump is_dec1;
84201c10:	88 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_dec1;

84201c14 <$M.celt.unquant_bands_stereo.is_enc1>:
      is_enc1:
         Null = M[FP + QB];
84201c14:	54 00 08 f1 	Null = M[FP + 0x54];
         if NZ jump end_calc_st_coeff;
84201c18:	2a 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;

            // -- calc mid/side coeffs
            r2 = I7 - M3;
84201c1c:	bf 00 47 6c 	r2 = I7 - M3;
            r2 = r2 + r2;
84201c20:	00 00 44 03 	r2 = r2 + r2;
            r0 = M[r5 + $celt.enc.BANDE_FIELD];
84201c24:	d0 00 27 d1 	r0 = M[r5 + 208];
            I4 = r0 + r2;
84201c28:	4f 00 42 50 	I4 = r0 + r2;
            r3 = M[I4, MK1];
84201c2c:	51 00 00 03 	Null = Null + Null, r3 = M[I4,4];
            r4 = M[I4, MK1];
84201c30:	61 00 00 03 	Null = Null + Null, r4 = M[I4,4];

            I4 = I4 + ($celt.MAX_BANDS*2)*ADDR_PER_WORD;
84201c34:	c8 00 44 59 	I4 = I4 + 200;
            r0 = M[I4, MK1];
84201c38:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
            r1 = M[I4, MK1];
84201c3c:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];
            r2 = r4 - r1;
84201c40:	3f 00 46 20 	r2 = r4 - r1;
            if POS r2 = 0;
84201c44:	05 00 40 00 	if POS r2 = Null + Null;
            r1 = r1 - r4;
84201c48:	00 00 36 23 	r1 = r1 - r4;
            if POS r1 = 0;
84201c4c:	05 00 30 00 	if POS r1 = Null + Null;
            r0 = r0 ASHIFT r1;
84201c50:	00 00 23 93 	r0 = r0 ASHIFT r1;
            r3 = r3 ASHIFT r2;
84201c54:	00 00 54 93 	r3 = r3 ASHIFT r2;
            push r0;
84201c58:	00 00 20 f3 	push r0;
            push r3;
84201c5c:	00 00 50 f3 	push r3;
            rMAC = r0 * r0;
84201c60:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
            rMAC = rMAC + r3 * r3;
84201c64:	5f 00 15 ac 	rMAC = rMAC + r3 * r3 (SS);
            r0 = rMAC;
84201c68:	0f 00 21 00 	r0 = rMAC + Null;
            $celt.sqrt
84201c6c:	01 10 01 f1 	pushm <I0, L0>;
84201c70:	00 00 c0 51 	L0 = Null + 0;
84201c74:	00 00 a2 f3 	push B0;
84201c78:	00 00 00 f3 	push Null;
84201c7c:	00 00 a6 f3 	pop B0;
84201c80:	07 00 00 fd 	call 0x74370;
84201c84:	70 43 f0 e1 
84201c88:	00 00 a6 f3 	pop B0;
84201c8c:	01 10 05 f1 	popm <I0, L0>;
            pop r4;
84201c90:	00 00 64 f3 	pop r4;
            pop r2;
84201c94:	00 00 44 f3 	pop r2;
            r3 = r1;
84201c98:	0f 00 53 00 	r3 = r1 + Null;
            if Z jump end_calc_st_coeff;
84201c9c:	09 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;
            rMAC = r2 ASHIFT -1;
84201ca0:	ff 00 e4 91 	rMAC = r2 ASHIFT -1 (MI);
            Div = rMAC / r3;
84201ca4:	00 00 15 d9 	Div = rMAC / r3;
            r0 = DivResult;
84201ca8:	01 00 20 d9 	r0 = DivResult;
            rMAC = r4 ASHIFT -1;
84201cac:	ff 00 e6 91 	rMAC = r4 ASHIFT -1 (MI);
            Div = rMAC / r3;
84201cb0:	00 00 15 d9 	Div = rMAC / r3;
            r1 = DivResult;
84201cb4:	01 00 30 d9 	r1 = DivResult;
            r1 = -r1;
84201cb8:	3f 00 30 20 	r1 = Null - r1;
            jump st_mix_enc;
84201cbc:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.st_mix_enc;

84201cc0 <$M.celt.unquant_bands_stereo.end_calc_st_coeff>:
         end_calc_st_coeff:
         r0 = -0.707106781186548;
84201cc0:	7d a5 00 fd 	r0 = Null + -1518500250;
84201cc4:	66 86 20 01 
         r1 = 0.707106781186548;
84201cc8:	82 5a 00 fd 	r1 = Null + 1518500250;
84201ccc:	9a 79 30 01 

84201cd0 <$M.celt.unquant_bands_stereo.st_mix_enc>:
         st_mix_enc:

         // -- ms stereo per band
         r3 = M[FP + S_BAND];
84201cd0:	20 00 58 f1 	r3 = M[FP + 0x20];
         Words2Addr(r3);
84201cd4:	02 00 55 91 	r3 = r3 ASHIFT 2;
         r10 = M[FP + N_BAND];
84201cd8:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
         r10 = r10 - 1;
84201cdc:	3f 00 cc e4 	r10 = r10 - 1;
         r2 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84201ce0:	cc 00 47 d1 	r2 = M[r5 + 204];
         I3  = r3 + r2;
84201ce4:	4f 00 35 50 	I3 = r3 + r2;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84201ce8:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84201cec:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I4 = I3 + r4;
84201cf0:	6f 00 43 58 	I4 = I3 + r4;
         I6 = I3;
84201cf4:	0f 00 63 58 	I6 = I3 + Null;
         I7 = I4;
84201cf8:	0f 00 74 58 	I7 = I4 + Null;
         r2 = M[I3, MK1], r3 = M[I4, MK1];
84201cfc:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
         r0 = r0 * 0.707106781186548;
84201d00:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (SS);
84201d04:	9a 79 22 cd 
         r1 = r1 * 0.707106781186548;
84201d08:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (SS);
84201d0c:	9a 79 33 cd 

         rMAC = r3 * r1;
84201d10:	3f 00 15 cc 	rMAC = r3 * r1 (SS);
         do mid_side_loop0;
84201d14:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop0;
            rMAC = rMAC - r2 * r0;
84201d18:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
            rMAC = r3 * r1, M[I6, MK1] = rMAC;
84201d1c:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
            rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
84201d20:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
            rMAC = r3 * r1, M[I7, MK1] = rMAC;
84201d24:	9d 00 53 cf 	rMAC = r3 * r1 (SS), M[I7,4] = rMAC;

84201d28 <$M.celt.unquant_bands_stereo.mid_side_loop0>:
         mid_side_loop0:
         rMAC = rMAC - r2 * r0;
84201d28:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
84201d2c:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0;
84201d30:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
         M[I7, MK1] = rMAC;
84201d34:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

         // -- renormalise left band
         r3= M[FP + N_BAND];
84201d38:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
84201d3c:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
84201d40:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
84201d44:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84201d48:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
84201d4c:	2f 00 53 50 	I5 = r1 + r0;
         M0 = 1;
84201d50:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
84201d54:	ff 7f 00 fd 	r7 = Null + 2147483647;
84201d58:	ff ff 90 01 
         call $celt.renormalise_vector;
84201d5c:	9e 01 f0 e1 	call $celt.renormalise_vector;
         push r1;
84201d60:	00 00 30 f3 	push r1;

         // -- renormalise right band
         r3 = M[FP + N_BAND];
84201d64:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
84201d68:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
84201d6c:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
84201d70:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84201d74:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
84201d78:	2f 00 53 50 	I5 = r1 + r0;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84201d7c:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84201d80:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
84201d84:	00 00 56 5b 	I5 = I5 + r4;
         M0 = 1;
84201d88:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
84201d8c:	ff 7f 00 fd 	r7 = Null + 2147483647;
84201d90:	ff ff 90 01 
         call $celt.renormalise_vector;
84201d94:	90 01 f0 e1 	call $celt.renormalise_vector;

         // -- calc atan(E_L/E_R)
         r6 = r1;
84201d98:	0f 00 83 00 	r6 = r1 + Null;
         pop r1;
84201d9c:	00 00 34 f3 	pop r1;
         r0 = M[FP + QB];
84201da0:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84201da4:	25 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         push r5;
84201da8:	00 00 70 f3 	push r5;

         // some optimisation
         r5 = 0;
84201dac:	00 00 70 01 	r5 = Null + 0;
         NULL = r1 OR r6;
84201db0:	8f 00 03 84 	Null = r1 OR r6;
         if Z jump calc_lr_ratio;
84201db4:	08 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         r5 = 0.25;
84201db8:	00 20 00 fd 	r5 = Null + 536870912;
84201dbc:	00 00 70 01 
         Null = r1 - r6;
84201dc0:	8f 00 03 20 	Null = r1 - r6;
         if Z jump calc_lr_ratio;
84201dc4:	04 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         // now calc E_L/E_R
         r5 = r1;
84201dc8:	0f 00 73 00 	r5 = r1 + Null;
         call $math.atan;
84201dcc:	07 00 00 fd 	call 0x74698;
84201dd0:	98 46 f0 e1 

84201dd4 <$M.celt.unquant_bands_stereo.calc_lr_ratio>:
         calc_lr_ratio:
            r3 = r5 * 0.003906251396735(frac);
84201dd4:	80 00 00 fd 	r3 = r5 * 0.0039062513969838619232177734375 (frac);
84201dd8:	03 00 57 95 
         pop r5;
84201ddc:	00 00 74 f3 	pop r5;
         r0 = M[FP + QB];
84201de0:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84201de4:	15 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         r1 = r0 - 14;
84201de8:	0e 00 32 21 	r1 = r0 - 14;
         r2 = -r1;
84201dec:	3f 00 40 20 	r2 = Null - r1;
         r1 = 1.0 ASHIFT r1;
84201df0:	ff 7f 00 fd 	r1 = 0x7fffffff ASHIFT r1;
84201df4:	ff ff 33 ed 
#ifdef K32
#ifdef K32_BITEXACT
         r1 = r1 ASHIFT -8;
84201df8:	f8 00 33 91 	r1 = r1 ASHIFT -8;
#endif	 
#endif
         r3 = r3 * r1(frac);
84201dfc:	00 00 53 97 	r3 = r3 * r1 (frac);
         r2 = r3 ASHIFT r2;
84201e00:	4f 00 45 90 	r2 = r3 ASHIFT r2;
#ifdef K32         
#ifndef K32_BITEXACT
         r2 = r2 LSHIFT -8; 
#endif	 
#endif                      
         M[FP + ITHETA] = r2; // SGTBD: ITHETA big difference between ARCH3 and ARCH4
84201e04:	34 00 4c f1 	M[FP + 0x34] = r2;
         r0 = 1 ASHIFT r0;
84201e08:	01 00 22 ed 	r0 = 0x1 ASHIFT r0;
         r0 = r0 + 1;         
84201e0c:	2f 00 22 e4 	r0 = r0 + 1;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
84201e10:	cc 01 27 d5 	M[r5 + 460] = r0;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*MK1] = Null;
84201e14:	d0 01 07 d5 	M[r5 + 464] = Null;
#ifdef K32         
#ifndef K32_BITEXACT
         r3 = r3 LSHIFT -8; // .fl is a 24-bit integer
#endif	 
#endif                  
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r3;
84201e18:	d4 01 57 d5 	M[r5 + 468] = r3;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*MK1] = Null;
84201e1c:	d8 01 07 d5 	M[r5 + 472] = Null;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
84201e20:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
84201e24:	0f 00 04 e0 	call r2;
         r0 = M[FP + ITHETA];
84201e28:	34 00 28 f1 	r0 = M[FP + 0x34];
         jump test_itheta;
84201e2c:	14 00 f0 dd 	jump $M.celt.unquant_bands_stereo.test_itheta;

84201e30 <$M.celt.unquant_bands_stereo.is_dec1>:
      is_dec1:
      r0 = M[FP + QB];
84201e30:	54 00 28 f1 	r0 = M[FP + 0x54];
      if NZ jump nzqb_dec;
84201e34:	07 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.nzqb_dec;

84201e38 <$M.celt.unquant_bands_stereo.qb_z>:
      qb_z:
         r0 = 0;
84201e38:	00 00 20 01 	r0 = Null + 0;
         M[FP + ITHETA] = r0;
84201e3c:	34 00 2c f1 	M[FP + 0x34] = r0;

84201e40 <$M.celt.unquant_bands_stereo.is_ztheta>:
      is_ztheta:
         r0 = 32767;     //mid
84201e40:	ff 7f 20 01 	r0 = Null + 32767;
         r1 = 0;         //side
84201e44:	00 00 30 01 	r1 = Null + 0;
         r2 = -10000;    //delta
84201e48:	f0 d8 40 01 	r2 = Null + -10000;
      jump set_st;
84201e4c:	12 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_st;

84201e50 <$M.celt.unquant_bands_stereo.nzqb_dec>:
      nzqb_dec:
         r0 = M[FP + QB];
84201e50:	54 00 28 f1 	r0 = M[FP + 0x54];
         r1 = 14 - r0;
84201e54:	0e 00 32 65 	r1 = 14 - r0;
         push r1;
84201e58:	00 00 30 f3 	push r1;
         r1 = 1 LSHIFT r0;
84201e5c:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
         r0 = r1 + 1;
84201e60:	2f 00 23 e4 	r0 = r1 + 1;
         r1 = 0;
84201e64:	00 00 30 01 	r1 = Null + 0;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
84201e68:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
84201e6c:	0f 00 04 e0 	call r2;
         pop r1;
84201e70:	00 00 34 f3 	pop r1;
         r0 = r0 LSHIFT r1;
84201e74:	00 00 23 8f 	r0 = r0 LSHIFT r1;
         M[FP + ITHETA]  = r0;
84201e78:	34 00 2c f1 	M[FP + 0x34] = r0;

84201e7c <$M.celt.unquant_bands_stereo.test_itheta>:
         test_itheta:
         if Z jump is_ztheta;
84201e7c:	f1 ff 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_ztheta;
         Null = r0 - 16384;
84201e80:	00 40 02 21 	Null = r0 - 16384;
         if NZ jump calc_ims;
84201e84:	08 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.calc_ims;
             r0 = 0;     //mid
84201e88:	00 00 20 01 	r0 = Null + 0;
             r1 = 32767; //side
84201e8c:	ff 7f 30 01 	r1 = Null + 32767;
             r2 = 10000; //delta
84201e90:	10 27 40 01 	r2 = Null + 10000;

84201e94 <$M.celt.unquant_bands_stereo.set_st>:
          set_st:
             M[FP + IMID] = r0;
84201e94:	28 00 2c f1 	M[FP + 0x28] = r0;
             M[FP + ISIDE] = r1;
84201e98:	2c 00 3c f1 	M[FP + 0x2c] = r1;
             M[FP + DELTA] = r2;
84201e9c:	30 00 4c f1 	M[FP + 0x30] = r2;
         jump end_ims;
84201ea0:	17 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_ims;

84201ea4 <$M.celt.unquant_bands_stereo.calc_ims>:
         calc_ims:
         call $celt.bitexact_cos;
84201ea4:	25 05 f0 e1 	call $celt.bitexact_cos;
         M[FP + IMID] = r2;
84201ea8:	28 00 4c f1 	M[FP + 0x28] = r2;
         rMAC = 0;
84201eac:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84201eb0:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84201eb4:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
84201eb8:	e7 04 f0 e1 	call $celt.log2_frac;
         push r0;
84201ebc:	00 00 20 f3 	push r0;

         r0 = M[FP + ITHETA];
84201ec0:	34 00 28 f1 	r0 = M[FP + 0x34];
         r0 = 16384 - r0;
84201ec4:	00 40 22 65 	r0 = 16384 - r0;
         call $celt.bitexact_cos;
84201ec8:	1c 05 f0 e1 	call $celt.bitexact_cos;
         M[FP + ISIDE] = r2;
84201ecc:	2c 00 4c f1 	M[FP + 0x2c] = r2;
         rMAC = 0;
84201ed0:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84201ed4:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84201ed8:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
84201edc:	de 04 f0 e1 	call $celt.log2_frac;
         pop r1;
84201ee0:	00 00 34 f3 	pop r1;
         r0 = r0 - r1;
84201ee4:	00 00 23 23 	r0 = r0 - r1;
         r1 = M[FP + N_BAND];
84201ee8:	1c 00 38 f1 	r1 = M[FP + 0x1c];
         r1 = r1 - 1;
84201eec:	3f 00 33 e4 	r1 = r1 - 1;
         r0 = r0*r1(int);
84201ef0:	00 00 23 9b 	r0 = r0 * r1 (int);
         r0 = r0 ASHIFT -2;
84201ef4:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         M[FP + DELTA] = r0;
84201ef8:	30 00 2c f1 	M[FP + 0x30] = r0;

84201efc <$M.celt.unquant_bands_stereo.end_ims>:
      end_ims:

      // restore trashed registers
      // retrieve the values in I6, I7, M3
      r3 = M[FP + TOTOAL_BITS];
84201efc:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
84201f00:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84201f04:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
84201f08:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
84201f0c:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
84201f10:	5f 00 b0 50 	M3 = Null + r3;

      // -- calc pulses allocated to L and R
      r0 = M[FP + VB];
84201f14:	38 00 28 f1 	r0 = M[FP + 0x38];
      r4 = M[FP + QALLOC];
84201f18:	24 00 68 f1 	r4 = M[FP + 0x24];
      r3 = M[FP + DELTA];
84201f1c:	30 00 58 f1 	r3 = M[FP + 0x30];
      r2 = r0 - r4;
84201f20:	6f 00 42 20 	r2 = r0 - r4;
      r1 = r4 ASHIFT -1;
84201f24:	ff 00 36 91 	r1 = r4 ASHIFT -1;
      r1 = r0 - r1;
84201f28:	3f 00 32 20 	r1 = r0 - r1;
      r1 = r1 - r3;
84201f2c:	00 00 35 23 	r1 = r1 - r3;
      r1 = r1 ASHIFT -1;
84201f30:	ff 00 33 91 	r1 = r1 ASHIFT -1;
      if NEG r1 = 0;
84201f34:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r1 - r2;
84201f38:	4f 00 03 20 	Null = r1 - r2;
      if POS r1 = r2;
84201f3c:	05 00 34 00 	if POS r1 = r2 + Null;
      M[FP + MBITS] = r1;
84201f40:	44 00 3c f1 	M[FP + 0x44] = r1;
      r2 = r2 - r1;
84201f44:	00 00 43 23 	r2 = r2 - r1;
      M[FP + SBITS] = r2;
84201f48:	48 00 4c f1 	M[FP + 0x48] = r2;
      r2 = I7 - M3;
84201f4c:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84201f50:	c1 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q1] = r0;
84201f54:	3c 00 2c f1 	M[FP + 0x3c] = r0;
      r1 = M[FP + SBITS];
84201f58:	48 00 38 f1 	r1 = M[FP + 0x48];
      r2 = I7 - M3;
84201f5c:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84201f60:	bd 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q2] = r0;               //q2=r0
84201f64:	40 00 2c f1 	M[FP + 0x40] = r0;
      r2 = M[FP + Q1];               //q1=r2
84201f68:	3c 00 48 f1 	r2 = M[FP + 0x3c];
      Words2Addr(r0);
84201f6c:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r1 = M[r4 + r0];          //curbits=r3
84201f70:	2f 00 36 d0 	r1 = M[r4 + r0];
      Addr2Words(r0);
84201f74:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      // restore I5
      r3 = M[FP + RM_BITS];
84201f78:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
84201f7c:	5f 00 50 50 	I5 = Null + r3;

      Words2Addr(r2);
84201f80:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r3 = M[r4 + r2];
84201f84:	4f 00 56 d0 	r3 = M[r4 + r2];
      Addr2Words(r2);
84201f88:	fe 00 44 91 	r2 = r2 ASHIFT -2;
      r3 = r3 + r1;
84201f8c:	00 00 53 03 	r3 = r3 + r1;
      r1 = M[FP + QALLOC];
84201f90:	24 00 38 f1 	r1 = M[FP + 0x24];
      r3 = r3 + r1;
84201f94:	00 00 53 03 	r3 = r3 + r1;

84201f98 <$M.celt.unquant_bands_stereo.rem_loop_start>:
      rem_loop_start:
      I5 = I5 - r3;
84201f98:	00 00 55 7b 	I5 = I5 - r3;
      if POS jump end_rem_loop;
84201f9c:	14 00 50 dd 	if POS jump $M.celt.unquant_bands_stereo.end_rem_loop;
         Null = r0 + r2;
84201fa0:	4f 00 02 00 	Null = r0 + r2;
         if LE jump end_rem_loop;
84201fa4:	12 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.end_rem_loop;
         I5 = I5 + r3;
84201fa8:	00 00 55 5b 	I5 = I5 + r3;
         r3 = 1;
84201fac:	2f 00 50 e4 	r3 = Null + 1;
         Null = r2 - r0;  //q1-q2
84201fb0:	2f 00 04 20 	Null = r2 - r0;
         if LE r3 = 0;    //r3 = q>q2
84201fb4:	0d 00 50 00 	if LE r3 = Null + Null;
         r1 = r3 XOR 1;   //r1 = q1<=q2
84201fb8:	01 00 35 89 	r1 = r3 XOR 0x1;
         r2 = r2 - r3;    //q1=q1 - q1>q2
84201fbc:	00 00 45 23 	r2 = r2 - r3;
         r0 = r0 - r1;    //q2=q2 - q1<=q2
84201fc0:	00 00 23 23 	r0 = r0 - r1;
         Words2Addr(r0);
84201fc4:	02 00 22 91 	r0 = r0 ASHIFT 2;
         Words2Addr(r2);
84201fc8:	02 00 44 91 	r2 = r2 ASHIFT 2;
         r3 = M[r4 + r0];
84201fcc:	2f 00 56 d0 	r3 = M[r4 + r0];
         r1 = M[r4 + r2];
84201fd0:	4f 00 36 d0 	r1 = M[r4 + r2];
         Addr2Words(r0);
84201fd4:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         Addr2Words(r2);
84201fd8:	fe 00 44 91 	r2 = r2 ASHIFT -2;
         r3 = r3 + r1;
84201fdc:	00 00 53 03 	r3 = r3 + r1;
         r1 = M[FP + QALLOC];
84201fe0:	24 00 38 f1 	r1 = M[FP + 0x24];
         r3 = r3 + r1;
84201fe4:	00 00 53 03 	r3 = r3 + r1;
         jump rem_loop_start;
84201fe8:	ec ff f0 dd 	jump $M.celt.unquant_bands_stereo.rem_loop_start;

84201fec <$M.celt.unquant_bands_stereo.end_rem_loop>:
      end_rem_loop:
      M[FP + Q2] = r0;
84201fec:	40 00 2c f1 	M[FP + 0x40] = r0;
      r0 = r2;
84201ff0:	0f 00 24 00 	r0 = r2 + Null;
      // push I5
      r3 = I5;
84201ff4:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
84201ff8:	04 00 5c f1 	M[FP + 0x4] = r3;

      // save some registers into stack
      r2 = M[FP + CUR_B];
84201ffc:	4c 00 48 f1 	r2 = M[FP + 0x4c];
      r1 = M[FP + S_BAND];
84202000:	20 00 38 f1 	r1 = M[FP + 0x20];
      r3 = M[FP + N_BAND];
84202004:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202008:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
8420200c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
84202010:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses
      // r1 = start bin no
      // r3 = band width
      // r2 = nr of Blocks
      r4 = r0 - Null;
84202014:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
84202018:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.intra_act;
         //calc spread
         M0 = r2;
8420201c:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84202020:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
84202024:	80 00 88 7c 	if EQ M0 = M0 - M0;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84202028:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
8420202c:	0f 00 02 e0 	call r0;
         jump end_act;
84202030:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act;

84202034 <$M.celt.unquant_bands_stereo.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
84202034:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
84202038:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
8420203c:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
84202040:	c1 00 f0 e1 	call $celt.intra_fold;

84202044 <$M.celt.unquant_bands_stereo.end_act>:
      end_act:

      // restore I5, I6, I7, M3, r5
      r3 = M[FP + RM_BITS];
84202044:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
84202048:	5f 00 50 50 	I5 = Null + r3;
      r3 = M[FP + TOTOAL_BITS];
8420204c:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
84202050:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84202054:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
84202058:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
8420205c:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
84202060:	5f 00 b0 50 	M3 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
84202064:	18 00 78 f1 	r5 = M[FP + 0x18];

84202068 <$M.celt.unquant_bands_stereo.second_ch>:

      second_ch:
         r0 = M[FP + Q2];
84202068:	40 00 28 f1 	r0 = M[FP + 0x40];
         // save I5, I6, I7, M3, r5 into stack
         r3 = I5;
8420206c:	5f 00 50 44 	r3 = Null + I5;
         M[FP + RM_BITS] = r3;
84202070:	04 00 5c f1 	M[FP + 0x4] = r3;
         r3 = I6;
84202074:	6f 00 50 44 	r3 = Null + I6;
         M[FP + TOTOAL_BITS] = r3;
84202078:	08 00 5c f1 	M[FP + 0x8] = r3;
         r3 = I7;
8420207c:	7f 00 50 44 	r3 = Null + I7;
         M[FP + NB_EBAND] = r3;
84202080:	0c 00 5c f1 	M[FP + 0xc] = r3;
         r3 = M3;
84202084:	bf 00 50 44 	r3 = Null + M3;
         M[FP + NB_EBAND_RM] = r3;
84202088:	14 00 5c f1 	M[FP + 0x14] = r3;
         M[FP + CODEC_STRUC] = r5;
8420208c:	18 00 7c f1 	M[FP + 0x18] = r5;

         r2 = M[FP + CUR_B];
84202090:	4c 00 48 f1 	r2 = M[FP + 0x4c];
         r1 = M[FP + S_BAND];
84202094:	20 00 38 f1 	r1 = M[FP + 0x20];
         r3 = M[FP + N_BAND];
84202098:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
8420209c:	cc 00 67 d1 	r4 = M[r5 + 204];
         Words2Addr(r1);
842020a0:	02 00 33 91 	r1 = r1 ASHIFT 2;
         I5 = r4 + r1;//X+eBands[i]
842020a4:	3f 00 56 50 	I5 = r4 + r1;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
842020a8:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
842020ac:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
842020b0:	00 00 56 5b 	I5 = I5 + r4;
         // I5 = start of band
         // r0 = number of pulses
         // r1 = start bin no (AU)
         // r3 = band width
         // r2 = nr of Blocks
         r4 = r0 - Null;
842020b4:	0f 00 62 20 	r4 = r0 - Null;
         if LE jump zeroside;
842020b8:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.zeroside;
            //calc spread
            M0 = r2;
842020bc:	4f 00 80 50 	M0 = Null + r2;
            Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
842020c0:	60 01 07 d1 	Null = M[r5 + 352];
            if Z M0 = M0 - M0;
842020c4:	80 00 88 7c 	if EQ M0 = M0 - M0;
            //call  $celt.alg_unquant;
            r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
842020c8:	34 00 27 d1 	r0 = M[r5 + 52];
            call r0;
842020cc:	0f 00 02 e0 	call r0;
            jump end_act2;
842020d0:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act2;

842020d4 <$M.celt.unquant_bands_stereo.zeroside>:
         zeroside:
         r10 = r3;
842020d4:	0f 00 c5 00 	r10 = r3 + Null;
         r0 = 0;
842020d8:	00 00 20 01 	r0 = Null + 0;
         do zers_loop;
842020dc:	02 00 f0 e5 	do $M.celt.unquant_bands_stereo.end_act2;
            M[I5, MK1] = r0;
842020e0:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

842020e4 <$M.celt.unquant_bands_stereo.end_act2>:
         zers_loop:

      end_act2:

      // restore I5, r5
      r3 = M[FP + RM_BITS];
842020e4:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
842020e8:	5f 00 50 50 	I5 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
842020ec:	18 00 78 f1 	r5 = M[FP + 0x18];

      // get start and end of band (again!)
      r1 = M[FP + S_BAND];
842020f0:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
842020f4:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      // calc norm for next folded band
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842020f8:	48 00 27 d1 	r0 = M[r5 + 72];
      r2 = M[FP + NB_EBAND_RM];  // M3
842020fc:	14 00 48 f1 	r2 = M[FP + 0x14];
      Words2Addr(r0);
84202100:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - r2;
84202104:	00 00 24 23 	r0 = r0 - r2;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
84202108:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
8420210c:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
84202110:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
84202114:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r10 - 1;
84202118:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
8420211c:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
84202120:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84202124:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202128:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
8420212c:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
84202130:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c
84202134:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
84202138:	03 00 f0 e5 	do $M.celt.unquant_bands_stereo.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
8420213c:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
84202140:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

84202144 <$M.celt.unquant_bands_stereo.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
84202144:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
84202148:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      r1 = M[FP + S_BAND];
8420214c:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
84202150:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      r10 = r10 - 1;
84202154:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202158:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
8420215c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84202160:	2f 00 33 50 	I3 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84202164:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
84202168:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I4 = I3 + r4;
8420216c:	6f 00 43 58 	I4 = I3 + r4;
      I6 = I3;
84202170:	0f 00 63 58 	I6 = I3 + Null;
      I7 = I4;
84202174:	0f 00 74 58 	I7 = I4 + Null;
      r0 = M[FP + IMID];
84202178:	28 00 28 f1 	r0 = M[FP + 0x28];
      r1 = M[FP + ISIDE];
8420217c:	2c 00 38 f1 	r1 = M[FP + 0x2c];
      r0 = r0 ASHIFT (DAWTH-16);
84202180:	10 00 22 91 	r0 = r0 ASHIFT 16;
      r1 = r1 ASHIFT (DAWTH-16);
84202184:	10 00 33 91 	r1 = r1 ASHIFT 16;
      r0 = r0 * 0.707106781186548 (frac);
84202188:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (frac);
8420218c:	9a 79 22 95 
      r1 = r1 * 0.707106781186548 (frac);
84202190:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (frac);
84202194:	9a 79 33 95 
      r2 = M[I3, MK1], r3 = M[I4, MK1];
84202198:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
      rMAC = r2 * r0;
8420219c:	2f 00 14 cc 	rMAC = r2 * r0 (SS);
      do mid_side_loop;
842021a0:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop;
         rMAC = rMAC - r3 * r1;
842021a4:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
842021a8:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
842021ac:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
         rMAC = r2 * r0, M[I7, MK1] = rMAC;
842021b0:	9d 00 42 cf 	rMAC = r2 * r0 (SS), M[I7,4] = rMAC;

842021b4 <$M.celt.unquant_bands_stereo.mid_side_loop>:
      mid_side_loop:
      rMAC = rMAC - r3 * r1;
842021b4:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
      rMAC = r3 * r1, M[I6, MK1] = rMAC;
842021b8:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC + r2 * r0;
842021bc:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
      M[I7, MK1] = rMAC;
842021c0:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
842021c4:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
842021c8:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
842021cc:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842021d0:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
842021d4:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
842021d8:	2f 00 53 50 	I5 = r1 + r0;
      M0 = 1;
842021dc:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
842021e0:	ff 7f 00 fd 	r7 = Null + 2147483647;
842021e4:	ff ff 90 01 
      call $celt.renormalise_vector;
842021e8:	7b 00 f0 e1 	call $celt.renormalise_vector;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
842021ec:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
842021f0:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
842021f4:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842021f8:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
842021fc:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
84202200:	2f 00 53 50 	I5 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84202204:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
84202208:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I5 = I5 + r4;
8420220c:	00 00 56 5b 	I5 = I5 + r4;
      M0 = 1;
84202210:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
84202214:	ff 7f 00 fd 	r7 = Null + 2147483647;
84202218:	ff ff 90 01 
      call $celt.renormalise_vector;
8420221c:	6e 00 f0 e1 	call $celt.renormalise_vector;

      // pop I6, I7, I2, M3
      r3 = M[FP + TOTOAL_BITS];
84202220:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
84202224:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84202228:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
8420222c:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + ADDR_EBAND];
84202230:	10 00 58 f1 	r3 = M[FP + 0x10];
      I2 = r3;
84202234:	5f 00 20 50 	I2 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
84202238:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3 - ADDR_PER_WORD;
8420223c:	04 00 b5 71 	M3 = r3 - 4;

   if NZ jump quant_bands_main_loop;
84202240:	1f fe 10 dd 	if NE jump $M.celt.unquant_bands_stereo.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
84202244:	a4 ff 03 f1 	SP = SP + -92;
   popm<FP>;
84202248:	00 40 06 f1 	popm <FP>;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420224c:	03 00 00 fd 	jump (m) 0x3b020;
84202250:	21 b0 f0 dd 

84202254 <$celt.bits2pulses>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITS2PULSES.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   r4 = M[r5 + $celt.dec.MODE_BITS_VECTORS_ADDR_FIELD];
84202254:	70 00 67 d1 	r4 = M[r5 + 112];
   r0 = M[r4 + r2]; // AU units
84202258:	4f 00 26 d0 	r0 = M[r4 + r2];
   r4 = r4 + r0;
8420225c:	00 00 62 03 	r4 = r4 + r0;
   r10 = $celt.MAX_PSEUDOLOG;
84202260:	06 00 c0 01 	r10 = Null + 6;
   r6 = 0; //lo
84202264:	00 00 80 01 	r6 = Null + 0;
   r7 = $celt.MAX_PSEUDO - 1;
84202268:	27 00 90 01 	r7 = Null + 39;
   do find_lo_hi;
8420226c:	0a 00 f0 e5 	do $M.celt.bits2pulses.find_lo_hi;
      r0 = r6 + r7;
84202270:	9f 00 28 00 	r0 = r6 + r7;
      r0 = r0 LSHIFT -1;
84202274:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
      Words2Addr(r0);
84202278:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r2 = M[r4 + r0];
8420227c:	2f 00 46 d0 	r2 = M[r4 + r0];
      Addr2Words(r0);
84202280:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      Null = r2 - r1;
84202284:	3f 00 04 20 	Null = r2 - r1;
      if POS r7 = r0;
84202288:	05 00 92 00 	if POS r7 = r0 + Null;
      Null = r2 - r1;
8420228c:	3f 00 04 20 	Null = r2 - r1;
      if NEG r6 = r0;
84202290:	04 00 82 00 	if NEG r6 = r0 + Null;

84202294 <$M.celt.bits2pulses.find_lo_hi>:
   find_lo_hi:

   Words2Addr(r6);
84202294:	02 00 88 91 	r6 = r6 ASHIFT 2;
   Words2Addr(r7);
84202298:	02 00 99 91 	r7 = r7 ASHIFT 2;
   r2 = M[r4+r6];
8420229c:	8f 00 46 d0 	r2 = M[r4 + r6];
   r0 = M[r4+r7];
842022a0:	9f 00 26 d0 	r0 = M[r4 + r7];
   Addr2Words(r6);
842022a4:	fe 00 88 91 	r6 = r6 ASHIFT -2;
   Addr2Words(r7);
842022a8:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   r2 = r2+r0;
842022ac:	00 00 42 03 	r2 = r2 + r0;
   r2 = r2 - r1;
842022b0:	00 00 43 23 	r2 = r2 - r1;
   r0 = r6;
842022b4:	0f 00 28 00 	r0 = r6 + Null;
   r2 = r2 - r1;
842022b8:	00 00 43 23 	r2 = r2 - r1;
   if NEG r0 = r7;
842022bc:	04 00 29 00 	if NEG r0 = r7 + Null;
   rts;
842022c0:	0f 00 0d dc 	rts;

842022c4 <$celt.renormalise_bands>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_BANDS.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842022c4:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842022c8:	48 00 27 d1 	r0 = M[r5 + 72];
   I7 = r0;
842022cc:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842022d0:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
842022d4:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842022d8:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
842022dc:	01 00 62 51 	I6 = r0 + 1;
   r7 = 1.0;
842022e0:	ff 7f 00 fd 	r7 = Null + 2147483647;
842022e4:	ff ff 90 01 
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842022e8:	cc 00 27 d1 	r0 = M[r5 + 204];
   I5 = r0;
842022ec:	2f 00 50 50 	I5 = Null + r0;

842022f0 <$M.celt.renormalise_bands.chan_renorm_loop>:
   chan_renorm_loop:
      M2 = I7;
842022f0:	0f 00 a7 58 	M2 = I7 + Null;

842022f4 <$M.celt.renormalise_bands.band_norm_loop>:
      band_norm_loop:
         r0 = M[I3, MK1];
842022f4:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
         r1 = M[I3, 0];
842022f8:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
         r6 = r1 - r0;
842022fc:	2f 00 83 20 	r6 = r1 - r0;
         M3 = r6;
84202300:	8f 00 b0 50 	M3 = Null + r6;
         Words2Addr(r6);
84202304:	02 00 88 91 	r6 = r6 ASHIFT 2;
         M0 = 1;
84202308:	01 00 80 51 	M0 = Null + 1;
         call $celt.renormalise_vector;
8420230c:	32 00 f0 e1 	call $celt.renormalise_vector;
         I5 = I5 + r6;
84202310:	00 00 58 5b 	I5 = I5 + r6;
         M2 = M2 -1;
84202314:	01 00 aa 79 	M2 = M2 - 1;
      if NZ jump band_norm_loop;
84202318:	f7 ff 10 dd 	if NE jump $M.celt.renormalise_bands.band_norm_loop;
      r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
8420231c:	60 00 27 d1 	r0 = M[r5 + 96];
      r1 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84202320:	44 00 37 d1 	r1 = M[r5 + 68];
      I3 = r0;
84202324:	2f 00 30 50 	I3 = Null + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202328:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
8420232c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r0 + r1;
84202330:	3f 00 52 50 	I5 = r0 + r1;
      I6 = I6 - 1;
84202334:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_renorm_loop;
84202338:	ee ff 10 dd 	if NE jump $M.celt.renormalise_bands.chan_renorm_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420233c:	03 00 00 fd 	jump (m) 0x3b020;
84202340:	21 b0 f0 dd 

84202344 <$celt.intra_fold>:
84202344:	00 00 d0 f3 	push rLink;
#endif
        
   push rlink;   
   //for this app B = 1 or 2 , //TODO: add support of 3 and 4 short blocks
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD];
84202348:	20 02 67 d1 	r4 = M[r5 + 544];
   r4 = r4 - MK1;
8420234c:	df 00 66 e4 	r4 = r4 - 4;
#else
   .VAR inv2[] = 1.0, 1.0/2+(1.0e-7), 1.0/3+(1.0e-7), 1.0/4+(1.0e-7), 1.0/5+(1.0e-7), 1.0/6+(1.0e-7), 1.0/7+(1.0e-7), 1.0/8+(1.0e-7);
#endif
   r0 = r2 + 1;
84202350:	2f 00 24 e4 	r0 = r2 + 1;
   r0 = r0 LSHIFT -1;
84202354:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
   r0 = r0 + r1;
84202358:	00 00 23 03 	r0 = r0 + r1;
   Words2Addr(r2);
8420235c:	02 00 44 91 	r2 = r2 ASHIFT 2;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r2 + r4];
84202360:	6f 00 64 d0 	r4 = M[r2 + r4];
#else
   r4 = M[r2 + (inv2-MK1)];
#endif
   Addr2Words(r2);
84202364:	fe 00 44 91 	r2 = r2 ASHIFT -2;
   r0 = r0 * r4 (frac);
84202368:	00 00 26 97 	r0 = r0 * r4 (frac);
   r0 = r0 - 1;                  // nb=num_blocks=r2, sb=start_bin=r1, bw=width of band=r3
8420236c:	3f 00 22 e4 	r0 = r0 - 1;
   r0 = r0 * r2 (int);           // r0 = ( ( (nb+1)*2+sb )*inv2[nb] - 1) * nb
84202370:	00 00 24 9b 	r0 = r0 * r2 (int);
   r4 = r1 - r0;
84202374:	2f 00 63 20 	r4 = r1 - r0;
   I6 = I5;
84202378:	0f 00 65 58 	I6 = I5 + Null;
   r0 = r4 + r3;
8420237c:	5f 00 26 00 	r0 = r4 + r3;
   Words2Addr(r4);
84202380:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I2 = I3 + r4; //y
84202384:	6f 00 23 58 	I2 = I3 + r4;
   Null = r0 - r1;
84202388:	3f 00 02 20 	Null = r0 - r1;
   if GT jump set_z;
8420238c:	07 00 c0 dd 	if GT jump $M.celt.intra_fold.set_z;
   r10 = r3 - 1;
84202390:	3f 00 c5 e4 	r10 = r3 - 1;
   
   // fold previous band into current band
   r0 = M[I2, MK1];
84202394:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   do fold_loop;
84202398:	02 00 f0 e5 	do $M.celt.intra_fold.fold_loop;
      r0 = M[I2, MK1], M[I6, MK1] = r0;
8420239c:	a9 29 00 03 	Null = Null + Null, r0 = M[I2,4], M[I6,4] = r0;

842023a0 <$M.celt.intra_fold.fold_loop>:
   fold_loop:
   M[I6, MK1] = r0;
842023a0:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;
   jump end_fold;
842023a4:	05 00 f0 dd 	jump $M.celt.intra_fold.end_fold;

842023a8 <$M.celt.intra_fold.set_z>:
   
   // zero the band
   set_z:
   r10 = r3;
842023a8:	0f 00 c5 00 	r10 = r3 + Null;
   r0 = 0;
842023ac:	00 00 20 01 	r0 = Null + 0;
   do z_loop;
842023b0:	02 00 f0 e5 	do $M.celt.intra_fold.end_fold;
      M[I6, MK1] = r0;
842023b4:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

842023b8 <$M.celt.intra_fold.end_fold>:
   z_loop: 
   end_fold:
   
   // folding is done, now renormalise to band energy
   M3 = r3;
842023b8:	5f 00 b0 50 	M3 = Null + r3;
   M0 = 1;
842023bc:	01 00 80 51 	M0 = Null + 1;
   r7 = 1.0;
842023c0:	ff 7f 00 fd 	r7 = Null + 2147483647;
842023c4:	ff ff 90 01 
   call $celt.renormalise_vector;
842023c8:	03 00 f0 e1 	call $celt.renormalise_vector;
   jump $pop_rLink_and_rts;
842023cc:	03 00 00 fd 	jump (m) 0x3b020;
842023d0:	21 b0 f0 dd 

842023d4 <$celt.renormalise_vector>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_VECTOR.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   push rlink;
842023d4:	00 00 d0 f3 	push rLink;
   rMAC = 0;  //TODO:check if rMAC0 = 1 can be enough
842023d8:	00 00 10 01 	rMAC = Null + 0;
#ifdef K32
   r0 = M0;
842023dc:	8f 00 20 44 	r0 = Null + M0;
   Words2Addr(r0);
842023e0:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842023e4:	2f 00 80 50 	M0 = Null + r0;
#endif
   r0 = 1;
842023e8:	2f 00 20 e4 	r0 = Null + 1;
   rMAC0 = r0;
842023ec:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r10 = M3 - 1;
842023f0:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
842023f4:	0f 00 25 58 	I2 = I5 + Null;
   r0 = M[I2, M0];
842023f8:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   do calc_e_lp;
842023fc:	02 00 f0 e5 	do $M.celt.renormalise_vector.calc_e_lp;
      rMAC = rMAC + r0 * r0, r0 = M[I2, M0];      
84202400:	2f 28 12 ac 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I2,M0];

84202404 <$M.celt.renormalise_vector.calc_e_lp>:
   calc_e_lp:
   rMAC = rMAC + r0 * r0;
84202404:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);
   r8 = signdet rMAC;
84202408:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND (-2);
8420240c:	ff ff 00 fd 	r8 = r8 AND 0xfffffffe;
84202410:	fe ff aa 81 
   r8 = r8 - 2;
84202414:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
84202418:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
8420241c:	01 10 01 f1 	pushm <I0, L0>;
84202420:	00 00 c0 51 	L0 = Null + 0;
84202424:	00 00 a2 f3 	push B0;
84202428:	00 00 00 f3 	push Null;
8420242c:	00 00 a6 f3 	pop B0;
84202430:	07 00 00 fd 	call 0x74370;
84202434:	70 43 f0 e1 
84202438:	00 00 a6 f3 	pop B0;
8420243c:	01 10 05 f1 	popm <I0, L0>;
   push r1;
84202440:	00 00 30 f3 	push r1;
   r4 = 1.0;
84202444:	ff 7f 00 fd 	r4 = Null + 2147483647;
84202448:	ff ff 60 01 
   Null = r1 - 0.2;
8420244c:	99 19 00 fd 	Null = r1 - 429496730;
84202450:	9a 99 03 21 
   if NEG jump too_small;
84202454:	05 00 40 dd 	if NEG jump $M.celt.renormalise_vector.too_small;
      rMAC = 0.125;
84202458:	00 10 00 fd 	rMAC = Null + 268435456;
8420245c:	00 00 10 01 
      Div = rMAC / r1;
84202460:	00 00 13 d9 	Div = rMAC / r1;
      r4 = DivResult;
84202464:	01 00 60 d9 	r4 = DivResult;

84202468 <$M.celt.renormalise_vector.too_small>:
   too_small:
   r1 = r8 + 2;
84202468:	af 00 3a e4 	r1 = r8 + 2;
   r0 = r1 ASHIFT -1;
8420246c:	ff 00 23 91 	r0 = r1 ASHIFT -1;
   r8 = 1 - r0;
84202470:	01 00 a2 65 	r8 = 1 - r0;
   r1 = r4 * r7 (frac);
84202474:	9f 00 36 94 	r1 = r4 * r7 (frac);
   r10 = M3 - 1;
84202478:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
8420247c:	0f 00 25 58 	I2 = I5 + Null;
   I4 = I5, r4 = M[I2, M0];
84202480:	0f 68 45 58 	I4 = I5 + Null, r4 = M[I2,M0];
   rMAC = r4*r1;
84202484:	3f 00 16 cc 	rMAC = r4 * r1 (SS);
   do re_norm_lp;
84202488:	03 00 f0 e5 	do $M.celt.renormalise_vector.re_norm_lp;
      rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2, M0];
8420248c:	00 68 12 92 	rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2,M0];
      rMAC = r4*r1, M[I4, M0] = rMAC;
84202490:	90 00 63 ce 	rMAC = r4 * r1 (SS), M[I4,M0] = rMAC;

84202494 <$M.celt.renormalise_vector.re_norm_lp>:
   re_norm_lp:
   rMAC = rMAC ASHIFT r0 (56bit);
84202494:	00 00 12 93 	rMAC = rMAC ASHIFT r0 (56bit);
   M[I4, M0] = rMAC;
84202498:	90 00 00 02 	Null = Null + Null, M[I4,M0] = rMAC;
   pop r1;
8420249c:	00 00 34 f3 	pop r1;
   r1 = r1 ASHIFT r8;
842024a0:	00 00 3a 93 	r1 = r1 ASHIFT r8;
   jump $pop_rLink_and_rts;
842024a4:	03 00 00 fd 	jump (m) 0x3b020;
842024a8:	21 b0 f0 dd 

842024ac <$celt.normalise_residual>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.NORMALISE_RESIDUAL.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
842024ac:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842024b0:	04 00 03 f1 	SP = SP + 4;
   M[FP + TEMP] = r3;
842024b4:	08 00 5c f1 	M[FP + 0x8] = r3;
   r8 = signdet rMAC;
842024b8:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND 0xFE;
842024bc:	fe 00 aa 81 	r8 = r8 AND 0xfe;
   r8 = r8 - 2;
842024c0:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
842024c4:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
842024c8:	01 10 01 f1 	pushm <I0, L0>;
842024cc:	00 00 c0 51 	L0 = Null + 0;
842024d0:	00 00 a2 f3 	push B0;
842024d4:	00 00 00 f3 	push Null;
842024d8:	00 00 a6 f3 	pop B0;
842024dc:	07 00 00 fd 	call 0x74370;
842024e0:	70 43 f0 e1 
842024e4:	00 00 a6 f3 	pop B0;
842024e8:	01 10 05 f1 	popm <I0, L0>;
   r0 = 1.0;
842024ec:	ff 7f 00 fd 	r0 = Null + 2147483647;
842024f0:	ff ff 20 01 
   Null = r1 - 0.2;
842024f4:	99 19 00 fd 	Null = r1 - 429496730;
842024f8:	9a 99 03 21 
   if NEG jump too_small;
842024fc:	05 00 40 dd 	if NEG jump $M.celt.normalise_residual.too_small;
      rMAC = 0.125;
84202500:	00 10 00 fd 	rMAC = Null + 268435456;
84202504:	00 00 10 01 
      Div = rMAC / r1;
84202508:	00 00 13 d9 	Div = rMAC / r1;
      r0 = DivResult;
8420250c:	01 00 20 d9 	r0 = DivResult;

84202510 <$M.celt.normalise_residual.too_small>:
   too_small:
   r8 = r8 + 2;
84202510:	af 00 aa e4 	r8 = r8 + 2;
   r8 = r8 ASHIFT -1;
84202514:	ff 00 aa 91 	r8 = r8 ASHIFT -1;
   // r8 = shift
   // r0 = gain
   r3 = M[FP + TEMP];
84202518:	08 00 58 f1 	r3 = M[FP + 0x8];
   r10 = r3 -1;
8420251c:	3f 00 c5 e4 	r10 = r3 - 1;
   I3 = I7;
84202520:	0f 00 37 58 	I3 = I7 + Null;
   r1 = M[I3, MK1];
84202524:	00 3d 00 03 	Null = Null + Null, r1 = M[I3,4];
   rMAC = r1 * r0;
84202528:	2f 00 13 cc 	rMAC = r1 * r0 (SS);
   do normalise_residual_loop;
8420252c:	03 00 f0 e5 	do $M.celt.normalise_residual.normalise_residual_loop;
      rMAC = rMAC ASHIFT r8 (56bit),  r1 = M[I3, M0];     
84202530:	00 3c 1a 92 	rMAC = rMAC ASHIFT r8 (56bit), r1 = M[I3,M0];
      rMAC = r1 * r0, M[I5, MK1] = rMAC;
84202534:	95 00 32 cf 	rMAC = r1 * r0 (SS), M[I5,4] = rMAC;

84202538 <$M.celt.normalise_residual.normalise_residual_loop>:
   normalise_residual_loop:
   rMAC = rMAC ASHIFT r8 (56bit);
84202538:	00 00 1a 93 	rMAC = rMAC ASHIFT r8 (56bit);
   M[I5, MK1] = rMAC;     
8420253c:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
   SP = SP - STACK_FRAME_SIZE;
84202540:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84202544:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202548:	0f 00 0d dc 	rts;

8420254c <$celt.exp_rotation>:
#endif
   
   //TODO: can devision, sin and cos calling be opimised?
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
8420254c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202550:	0c 00 03 f1 	SP = SP + 12;

   M[FP + TEMP + 0] = r3;
84202554:	08 00 5c f1 	M[FP + 0x8] = r3;

   r0 = r6 LSHIFT 3;
84202558:	03 00 28 8d 	r0 = r6 LSHIFT 3;
   Null = r3 - r0;
8420255c:	2f 00 05 20 	Null = r3 - r0;
   if LE jump no_strike_update;
84202560:	06 00 d0 dd 	if LE jump $M.celt.exp_rotation.no_strike_update;
      rMAC = 0;
84202564:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r3;
84202568:	00 05 e5 8d 	rMAC0 = r3 LSHIFT 0;
      Div = rMAC / r0;
8420256c:	00 00 12 d9 	Div = rMAC / r0;
      r0 = DivResult;
84202570:	01 00 20 d9 	r0 = DivResult;
      r6 = r6 * r0 (int);
84202574:	00 00 82 9b 	r6 = r6 * r0 (int);

84202578 <$M.celt.exp_rotation.no_strike_update>:
   no_strike_update:
   // calc gain
   rMAC = r3;           
84202578:	0f 00 15 00 	rMAC = r3 + Null;
   r0 = r4 * 6 (int);   
8420257c:	06 00 26 99 	r0 = r4 * 6 (int);
   r0 = r0 + r3;       
84202580:	00 00 25 03 	r0 = r0 + r3;
   r0 = r0 + 3;         
84202584:	03 00 22 01 	r0 = r0 + 3;
   r0 = r0 + r0;        
84202588:	00 00 22 03 	r0 = r0 + r0;
   Div = rMAC/r0;       
8420258c:	00 00 12 d9 	Div = rMAC / r0;
   r0 = DivResult;      
84202590:	01 00 20 d9 	r0 = DivResult;
   r0 = r0 * r0 (frac); 
84202594:	00 00 22 97 	r0 = r0 * r0 (frac);
   r0 = r0 * 0.25(frac); 
84202598:	00 20 22 95 	r0 = r0 * 0.25 (frac);
   r0 = 0.5 - r0;       
8420259c:	00 40 00 fd 	r0 = 1073741824 - r0;
842025a0:	00 00 22 65 
   push I0;
842025a4:	00 00 01 f3 	push I0;
   push L0;
842025a8:	00 00 c1 f3 	push L0;
   L0 = 0;
842025ac:	00 00 c0 51 	L0 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push B0;
842025b0:	00 00 a2 f3 	push B0;
   push Null;
842025b4:	00 00 00 f3 	push Null;
   pop B0;
842025b8:	00 00 a6 f3 	pop B0;
#endif
   call $math.sin;
842025bc:	07 00 00 fd 	call 0x74280;
842025c0:	80 42 f0 e1 
   r8 = r1;            
842025c4:	0f 00 a3 00 	r8 = r1 + Null;
   r0 = 0.5 - r0;
842025c8:	00 40 00 fd 	r0 = 1073741824 - r0;
842025cc:	00 00 22 65 
   call $math.sin;
842025d0:	07 00 00 fd 	call 0x74280;
842025d4:	80 42 f0 e1 
   //r8 = sin
   //r1 = cos
#ifdef BASE_REGISTER_MODE
   pop B0;
842025d8:	00 00 a6 f3 	pop B0;
#endif
   pop L0;
842025dc:	00 00 c5 f3 	pop L0;
   pop I0;
842025e0:	00 00 05 f3 	pop I0;
   Null = r7;
842025e4:	0f 00 09 00 	Null = r7 + Null;
   if NEG r8 = -r8;
842025e8:	a4 00 a0 20 	if NEG r8 = Null - r8;
 
   // 1st rotation loop
   r10 = M[FP + TEMP + 0];
842025ec:	08 00 c8 f1 	r10 = M[FP + 0x8];
   r10 = r10 - r6;
842025f0:	00 00 c8 23 	r10 = r10 - r6;
   if LE jump end_rot_loop1;
842025f4:	0c 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop1;
   I3 = I5;
842025f8:	0f 00 35 58 	I3 = I5 + Null;
   Words2Addr(r6);
842025fc:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
84202600:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp1;
84202604:	07 00 f0 e5 	do $M.celt.exp_rotation.exp_rot_lp1;
      r2 = M[I6, 0]; 
84202608:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
8420260c:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
84202610:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, MK1] = rMAC; 
84202614:	99 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC - r8*r2;
84202618:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, MK1] = rMAC;//, r2 = M[I6, 0];
8420261c:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

84202620 <$M.celt.exp_rotation.exp_rot_lp1>:
   exp_rot_lp1:
   Addr2Words(r6);
84202620:	fe 00 88 91 	r6 = r6 ASHIFT -2;

84202624 <$M.celt.exp_rotation.end_rot_loop1>:
   end_rot_loop1:
   
   // 2nd rotation loop
   r0 = M[FP + TEMP + 0];
84202624:	08 00 28 f1 	r0 = M[FP + 0x8];
   r2 = r6 + r6;
84202628:	8f 00 48 00 	r2 = r6 + r6;
   r10 = r0 - r2;
8420262c:	4f 00 c2 20 	r10 = r0 - r2;
   if LE jump end_rot_loop2;
84202630:	0d 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop2;
   r3 = r10 - 1;
84202634:	3f 00 5c e4 	r3 = r10 - 1;
   Words2Addr(r3);
84202638:	02 00 55 91 	r3 = r3 ASHIFT 2;
   I3 = I5 + r3;
8420263c:	5f 00 35 58 	I3 = I5 + r3;
   Words2Addr(r6);
84202640:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
84202644:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp2;
84202648:	07 00 f0 e5 	do $M.celt.exp_rotation.end_rot_loop2;
      r2 = M[I6, 0];
8420264c:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
84202650:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
84202654:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, -MK1] = rMAC;
84202658:	9b 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,-4] = rMAC;
      rMAC = rMAC - r8*r2;
8420265c:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, -MK1] = rMAC;//, r2 = M[I6, 0];
84202660:	00 9f 00 03 	Null = Null + Null, M[I3,-4] = rMAC;

84202664 <$M.celt.exp_rotation.end_rot_loop2>:
   exp_rot_lp2:
   end_rot_loop2:
   SP = SP - STACK_FRAME_SIZE;
84202664:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84202668:	01 20 04 f1 	popm <FP, rLink>;
   rts;
8420266c:	0f 00 0d dc 	rts;

84202670 <$celt.alg_quant>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALG_QUANT.PATCH_ID_0,r7)     // celt_patchers
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     10*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202670:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202674:	28 00 03 f1 	SP = SP + 40;
   // 0 -> nrof pulses
   // 1 -> input buffer
   // 2 -> spread (int)
   // 3 -> nrof inputs
   // 4 -> 1/N    (FRAC)
   $celt.get_pulses(r4, r1, get_pulses_lbl1)
84202678:	fd 00 36 8d 	r1 = r4 LSHIFT -3;
8420267c:	05 00 00 dd 	if EQ jump $M.celt.alg_quant.get_pulses_lbl1;
84202680:	3f 00 33 e4 	r1 = r1 - 1;
84202684:	07 00 66 81 	r4 = r4 AND 0x7;
84202688:	08 00 66 01 	r4 = r4 + 8;
8420268c:	00 00 63 8f 	r4 = r4 LSHIFT r1;

84202690 <$M.celt.alg_quant.get_pulses_lbl1>:
   
   rMAC = 1;
84202690:	2f 00 10 e4 	rMAC = Null + 1;
   r0 = r3 LSHIFT 15;
84202694:	0f 00 25 8d 	r0 = r3 LSHIFT 15;
   Div = rMAC /r0;
84202698:	00 00 12 d9 	Div = rMAC / r0;
   
   // rotation if required
   M[FP + TEMP + 0*ADDR_PER_WORD] = r4;
8420269c:	08 00 6c f1 	M[FP + 0x8] = r4;
   r0 = I5;
842026a0:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + 1*ADDR_PER_WORD] = r0;
842026a4:	0c 00 2c f1 	M[FP + 0xc] = r0;
   r6 = M0;
842026a8:	8f 00 80 44 	r6 = Null + M0;
   M[FP + TEMP + 3*ADDR_PER_WORD] = r3;
842026ac:	14 00 5c f1 	M[FP + 0x14] = r3;
   r7 = 1;
842026b0:	2f 00 90 e4 	r7 = Null + 1;
   r0 = DivResult;
842026b4:	01 00 20 d9 	r0 = DivResult;
   M[FP + TEMP + 4*ADDR_PER_WORD] = r0;
842026b8:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 2*ADDR_PER_WORD] = r6;
842026bc:	10 00 8c f1 	M[FP + 0x10] = r6;
   if NZ call $celt.exp_rotation;
842026c0:	a3 ff 10 e1 	if NE call $celt.exp_rotation;
   r2 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
842026c4:	c4 00 47 d1 	r2 = M[r5 + 196];
   I6 = r2;
842026c8:	4f 00 60 50 	I6 = Null + r2;
   r2 = 0;
842026cc:	00 00 40 01 	r2 = Null + 0;
   M0 = ADDR_PER_WORD;
842026d0:	04 00 80 51 	M0 = Null + 4;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
842026d4:	0c 00 28 f1 	r0 = M[FP + 0xc];
   r10 = M[FP + TEMP + 3*ADDR_PER_WORD];
842026d8:	14 00 c8 f1 	r10 = M[FP + 0x14];
   I3 = r0;
842026dc:	2f 00 30 50 	I3 = Null + r0;
   r10 = r10 - 1, r0 = M[I3, M0];
842026e0:	3f 2c cc e4 	r10 = r10 - 1, r0 = M[I3,M0];
#ifdef K32
   r0 = r0 ASHIFT -8;
842026e4:	f8 00 22 91 	r0 = r0 ASHIFT -8;
#endif
   r3 = 0.00390625/2;//??4096; //0.00390625;
842026e8:	40 00 00 fd 	r3 = Null + 4194304;
842026ec:	00 00 50 01 
   r1 = M[r5 + $celt.enc.ABS_NORM_FIELD]; 
842026f0:	28 01 37 d1 	r1 = M[r5 + 296];
   I2 = r1;
842026f4:	3f 00 20 50 	I2 = Null + r1;
   r1 = r0*r3(frac);
842026f8:	5f 00 32 94 	r1 = r0 * r3 (frac);
   do abs_norm_loop;
842026fc:	05 00 f0 e5 	do $M.celt.alg_quant.abs_norm_loop;
      if NEG r1 = -r1, r0 = M[I3, M0];
84202700:	34 2c 30 20 	if NEG r1 = Null - r1, r0 = M[I3,M0];
#ifdef K32
   r0 = r0 ASHIFT -8;
84202704:	f8 00 22 91 	r0 = r0 ASHIFT -8;
#endif
      r1 = r0*r3(frac), M[I2, M0] = r1;      
84202708:	5f b8 32 94 	r1 = r0 * r3 (frac), M[I2,M0] = r1;
      M[I6, M0] = r2;
8420270c:	c8 00 00 02 	Null = Null + Null, M[I6,M0] = r2;

84202710 <$M.celt.alg_quant.abs_norm_loop>:
   abs_norm_loop:
   if NEG r1 = -r1;
84202710:	34 00 30 20 	if NEG r1 = Null - r1;
   M[I2, M0] = r1;      
84202714:	00 b8 00 02 	Null = Null + Null, M[I2,M0] = r1;
   M[I6, M0] = r2;
84202718:	c8 00 00 02 	Null = Null + Null, M[I6,M0] = r2;
   
   r0 = M[FP + TEMP + 0*ADDR_PER_WORD];
8420271c:	08 00 28 f1 	r0 = M[FP + 0x8];
   M2 = r0;
84202720:	2f 00 a0 50 	M2 = Null + r0;
   r10 = M[FP + TEMP + 3*ADDR_PER_WORD];
84202724:	14 00 c8 f1 	r10 = M[FP + 0x14];
   M3 = r10;
84202728:	cf 00 b0 50 	M3 = Null + r10;

#ifndef K32
   r7 = 0;
   r8 = 0;
#else
   rMAC = 0;
8420272c:	00 00 10 01 	rMAC = Null + 0;
   rMACB = 0;
84202730:	00 00 f0 01 	rMACB = Null + 0;
#endif

   r2 = r10 LSHIFT -1;
84202734:	ff 00 4c 8d 	r2 = r10 LSHIFT -1;
   Null = r0 - r2;
84202738:	4f 00 02 20 	Null = r0 - r2;
   if LE jump end_presearch;
8420273c:	23 00 d0 dd 	if LE jump $M.celt.alg_quant.end_presearch;
      r3 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84202740:	28 01 57 d1 	r3 = M[r5 + 296];
      I6 = r3;
84202744:	5f 00 60 50 	I6 = Null + r3;
      r10 = r10 - 1;
84202748:	3f 00 cc e4 	r10 = r10 - 1;
      r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
8420274c:	08 00 68 f1 	r4 = M[FP + 0x8];
      r0 = r0-r0, r1 = M[I6, M0];
84202750:	38 00 22 22 	r0 = r0 - r0, r1 = M[I6,M0];
      do calc_sum_lp;
84202754:	02 00 f0 e5 	do $M.celt.alg_quant.calc_sum_lp;
         r0 = r0 + r1, r1 = M[I6, M0];
84202758:	38 00 23 02 	r0 = r0 + r1, r1 = M[I6,M0];

8420275c <$M.celt.alg_quant.calc_sum_lp>:
      calc_sum_lp:
      I6 = r3;
8420275c:	5f 00 60 50 	I6 = Null + r3;
      r0 = r0 + r1; // SGTBD: r0 differs by 1 after this line. this causes diferences downstream
84202760:	00 00 23 03 	r0 = r0 + r1;
      NULL = r0 - M3; 
84202764:	bf 00 02 64 	Null = r0 - M3;
      if POS jump calc_inv;
84202768:	08 00 50 dd 	if POS jump $M.celt.alg_quant.calc_inv;
          // empty or nearly empty band
          r0 = 1<<20;
8420276c:	10 00 00 fd 	r0 = Null + 1048576;
84202770:	00 00 20 01 
          r1 = 0, M[I6, M0] = r0;
84202774:	a8 00 33 22 	r1 = r1 - r1, M[I6,M0] = r0;
          r10 = M3 - 1;
84202778:	01 00 cb 69 	r10 = M3 - 1;
          do force_clear_band;
8420277c:	02 00 f0 e5 	do $M.celt.alg_quant.force_clear_band;
             M[I6, M0] = r1;
84202780:	b8 00 00 02 	Null = Null + Null, M[I6,M0] = r1;

84202784 <$M.celt.alg_quant.force_clear_band>:
          force_clear_band:
          I6 = r3;
84202784:	5f 00 60 50 	I6 = Null + r3;

84202788 <$M.celt.alg_quant.calc_inv>:
      calc_inv:
      r2 = r4 - 1;
84202788:	3f 00 46 e4 	r2 = r4 - 1;
      //rMAC = r2 LSHIFT 6;
      rMAC = r2 LSHIFT 5;//??3;
8420278c:	05 00 e4 8d 	rMAC = r2 LSHIFT 5 (MI);
      Div = rMAC /r0;
84202790:	00 00 12 d9 	Div = rMAC / r0;
      r10 = M3;
84202794:	bf 00 c0 44 	r10 = Null + M3;
#ifdef K32
      rMAC = 0;
84202798:	00 00 10 01 	rMAC = Null + 0;
      rMACB = 0;
8420279c:	00 00 f0 01 	rMACB = Null + 0;
#endif
      r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
842027a0:	c4 00 27 d1 	r0 = M[r5 + 196];
      I3 = r0;      
842027a4:	2f 00 30 50 	I3 = Null + r0;
      r6 = DivResult;
842027a8:	01 00 80 d9 	r6 = DivResult;
      do rcp_loop;
842027ac:	07 00 f0 e5 	do $M.celt.alg_quant.end_presearch;
         r0 = M[I6, M0];
842027b0:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
         r1 = r0 * r6 (frac);
842027b4:	8f 00 32 94 	r1 = r0 * r6 (frac);
         r2 = r1 * r1 (int), M[I3, M0] = r1;
         r7 = r7 + r2;
         r2 = r1 * r0(int)(sat);
         r8 = r8 + r2;
#else
         r1 = r1 LSHIFT -6;
842027b8:	fa 00 33 8d 	r1 = r1 LSHIFT -6;
         rMAC = rMAC + r1*r1, M[I3, M0] = r1;
842027bc:	3f bc 13 ac 	rMAC = rMAC + r1 * r1 (SS), M[I3,M0] = r1;
         rMACB = rMACB + r1*r0;
842027c0:	2f 00 03 ac 	rMACB = rMACB + r1 * r0 (SS);
#endif
         M2 = M2 - r1;
842027c4:	00 00 a3 7b 	M2 = M2 - r1;

842027c8 <$M.celt.alg_quant.end_presearch>:
      rcp_loop:
   end_presearch:
#ifdef K32 
   r7 = rMAC ASHIFT 31;
842027c8:	1f 00 91 91 	r7 = rMAC ASHIFT 31;
   r8 = rMACB ASHIFT 31;
842027cc:	1f 00 af 91 	r8 = rMACB ASHIFT 31;

842027d0 <$M.celt.alg_quant.fine_loop>:
   // r6 = best_num (unused)
   // r4 = best_den (unused)
   // M0 = 1 (AU)
   // M1 = best_id (unused)
   fine_loop:
      r0 = M2;
842027d0:	af 00 20 44 	r0 = Null + M2;
      if LE jump end_fine_loop;
842027d4:	31 00 d0 dd 	if LE jump $M.celt.alg_quant.end_fine_loop;
      
      r4 = 0;
842027d8:	00 00 60 01 	r4 = Null + 0;
#ifndef K32      
      r6 = -1.0;
#else
      r6 = -1.0 / 256;
842027dc:	80 ff 00 fd 	r6 = Null + -8388608;
842027e0:	00 00 80 01 
#endif
      r1 = M[FP + TEMP + 4*ADDR_PER_WORD];
842027e4:	18 00 38 f1 	r1 = M[FP + 0x18];
#ifdef K32
      r1 = r1 LSHIFT -8;
842027e8:	f8 00 33 8d 	r1 = r1 LSHIFT -8;
#endif
      r1 = r1 * r0 (int);
842027ec:	00 00 32 9b 	r1 = r1 * r0 (int);
      r1 = r1 LSHIFT -9;
842027f0:	f7 00 33 8d 	r1 = r1 LSHIFT -9;
      if Z r1 = 1;
842027f4:	20 00 30 e4 	if EQ r1 = Null + 1;
      M1 = 0;
842027f8:	00 00 90 51 	M1 = Null + 0;
      r10 = M3;
842027fc:	bf 00 c0 44 	r10 = Null + M3;
      r0 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84202800:	28 01 27 d1 	r0 = M[r5 + 296];
      I6 = r0;
84202804:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84202808:	c4 00 27 d1 	r0 = M[r5 + 196];
      I3 = r0; 
8420280c:	2f 00 30 50 	I3 = Null + r0;
      r0 = r1 * r1 (int);
84202810:	3f 00 23 98 	r0 = r1 * r1 (int);
      r7 = r7 + r0, r0 = M[I6, M0];
84202814:	28 00 92 02 	r7 = r7 + r0, r0 = M[I6,M0];
      push r5;
84202818:	00 00 70 f3 	push r5;
      r5 = r1 * 2(int);
8420281c:	02 00 73 99 	r5 = r1 * 2 (int);
      r0 = r0 * r1(int);
84202820:	00 00 23 9b 	r0 = r0 * r1 (int);
      do search_fine_loop;
84202824:	0d 00 f0 e5 	do $M.celt.alg_quant.search_fine_loop;
         r3 = r8 + r0, r0 = M[I3, M0];
84202828:	2f 2c 5a 00 	r3 = r8 + r0, r0 = M[I3,M0];
         r0 = r0 * r5(int);
8420282c:	00 00 27 9b 	r0 = r0 * r5 (int);
         r2 = r7 + r0;
84202830:	2f 00 49 00 	r2 = r7 + r0;
         rMAC = r3 * r3;
84202834:	5f 00 15 cc 	rMAC = r3 * r3 (SS);
#ifndef K32
   r3 = rMAC ASHIFT 6;
#else
   r3 = rMAC ASHIFT 14;
84202838:	0e 00 51 91 	r3 = rMAC ASHIFT 14;
#endif
         rMAC = r3*r4;
8420283c:	6f 00 15 cc 	rMAC = r3 * r4 (SS);
         rMAC = rMAC - r6 * r2, r0 = M[I6, M0];
84202840:	28 00 84 be 	rMAC = rMAC - r6 * r2 (SS), r0 = M[I6,M0];
         if LE jump b_loop;
84202844:	04 00 d0 dd 	if LE jump $M.celt.alg_quant.b_loop;
            r4 = r2;
84202848:	0f 00 64 00 	r4 = r2 + Null;
            r6 = r3;
8420284c:	0f 00 85 00 	r6 = r3 + Null;
            M1 = M3 - r10;
84202850:	cf 00 9b 78 	M1 = M3 - r10;

84202854 <$M.celt.alg_quant.b_loop>:
         b_loop:
         r0 = r0 * r1(int);
84202854:	00 00 23 9b 	r0 = r0 * r1 (int);

84202858 <$M.celt.alg_quant.search_fine_loop>:
      search_fine_loop:
      pop r5;
84202858:	00 00 74 f3 	pop r5;

      r0 = M1;
8420285c:	9f 00 20 44 	r0 = Null + M1;
      Words2Addr(r0);
84202860:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r2 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84202864:	28 01 47 d1 	r2 = M[r5 + 296];
      r3 = M[r0 + r2];
84202868:	4f 00 52 d0 	r3 = M[r0 + r2];
      r3 = r1 * r3 (int);
8420286c:	5f 00 53 98 	r3 = r1 * r3 (int);
      r8 = r8 + r3;      
84202870:	00 00 a5 03 	r8 = r8 + r3;
      r2 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84202874:	c4 00 47 d1 	r2 = M[r5 + 196];
      r3 = M[r0 + r2];
84202878:	4f 00 52 d0 	r3 = M[r0 + r2];
      rMAC = r1 * r3 (int);
8420287c:	5f 00 13 98 	rMAC = r1 * r3 (int);
      r7 = r7 + rMAC;
84202880:	00 00 91 03 	r7 = r7 + rMAC;
      r7 = r7 + rMAC;
84202884:	00 00 91 03 	r7 = r7 + rMAC;
      r3 = r3 + r1;
84202888:	00 00 53 03 	r3 = r3 + r1;
      M[r0 + r2] = r3;
8420288c:	4f 00 52 d4 	M[r0 + r2] = r3;
            
   M2 = M2 - r1;
84202890:	00 00 a3 7b 	M2 = M2 - r1;
   jump fine_loop;  
84202894:	cf ff f0 dd 	jump $M.celt.alg_quant.fine_loop;

84202898 <$M.celt.alg_quant.end_fine_loop>:
   end_fine_loop:
   r7 = r7 + r7;
84202898:	00 00 99 03 	r7 = r7 + r7;
   M[FP + TEMP + 6*ADDR_PER_WORD] = r7;
8420289c:	20 00 9c f1 	M[FP + 0x20] = r7;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
842028a0:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
842028a4:	2f 00 50 50 	I5 = Null + r0;
   I6 = I5;
842028a8:	0f 00 65 58 	I6 = I5 + Null;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
842028ac:	c4 00 27 d1 	r0 = M[r5 + 196];
   I2 = r0;
842028b0:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2;
842028b4:	0f 00 32 58 	I3 = I2 + Null;
   r10 = M3 - 2;
842028b8:	02 00 cb 69 	r10 = M3 - 2;
   r0 = M[I6, M0];
842028bc:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
   r0 = r0, r1 = M[I2, M0];
842028c0:	00 38 20 02 	r0 = r0 + Null, r1 = M[I2,M0];
   if NEG r1 = -r1;
842028c4:	34 00 30 20 	if NEG r1 = Null - r1;
   r0 = M[I6, M0];
842028c8:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
   do ap_sign_loop;
842028cc:	05 00 f0 e5 	do $M.celt.alg_quant.ap_sign_loop;
      r2 = r1, r1 = M[I2, M0];
842028d0:	0f 38 43 00 	r2 = r1 + Null, r1 = M[I2,M0];
      r0 = r0 + Null;
842028d4:	00 00 20 03 	r0 = r0 + Null;
      if NEG r1 = -r1, M[I3, M0] = r2;      
842028d8:	34 cc 30 20 	if NEG r1 = Null - r1, M[I3,M0] = r2;
       r0 = M[I6, M0];
842028dc:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];

842028e0 <$M.celt.alg_quant.ap_sign_loop>:
   ap_sign_loop:
   r2 = r1, r1 = M[I2, M0];
842028e0:	0f 38 43 00 	r2 = r1 + Null, r1 = M[I2,M0];
   r0 = r0 + Null;
842028e4:	00 00 20 03 	r0 = r0 + Null;
   if NEG r1 = -r1, M[I3, M0] = r2; 
842028e8:	34 cc 30 20 	if NEG r1 = Null - r1, M[I3,M0] = r2;
   M[I3, M0] = r1;
842028ec:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
842028f0:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
842028f4:	2f 00 70 50 	I7 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
842028f8:	14 00 58 f1 	r3 = M[FP + 0x14];
   r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
842028fc:	08 00 68 f1 	r4 = M[FP + 0x8];
   call $celt.encode_pulses;
84202900:	57 04 f0 e1 	call $celt.encode_pulses;
   
   // normalise residual
   r0 = M[FP + TEMP + 6*ADDR_PER_WORD];
84202904:	20 00 28 f1 	r0 = M[FP + 0x20];
   rMAC = 0;
84202908:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r0;
8420290c:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
84202910:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84202914:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84202918:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
8420291c:	2f 00 70 50 	I7 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
84202920:	14 00 58 f1 	r3 = M[FP + 0x14];
   call $celt.normalise_residual;
84202924:	e2 fe f0 e1 	call $celt.normalise_residual;
   Null = M[FP + TEMP + 0*ADDR_PER_WORD];
84202928:	08 00 08 f1 	Null = M[FP + 0x8];
   if Z jump exit;
8420292c:	08 00 00 dd 	if EQ jump $M.celt.alg_quant.exit;
   
   // rotation if required
   r6 = M[FP + TEMP + 2*ADDR_PER_WORD];
84202930:	10 00 88 f1 	r6 = M[FP + 0x10];
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
84202934:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84202938:	2f 00 50 50 	I5 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
8420293c:	14 00 58 f1 	r3 = M[FP + 0x14];
   r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
84202940:	08 00 68 f1 	r4 = M[FP + 0x8];
   r7 = -1;
84202944:	3f 00 90 e4 	r7 = Null - 1;
   call $celt.exp_rotation;
84202948:	01 ff f0 e1 	call $celt.exp_rotation;

8420294c <$M.celt.alg_quant.exit>:
exit: 
   SP = SP - STACK_FRAME_SIZE;
8420294c:	d8 ff 03 f1 	SP = SP + -40;
   popm <FP,rLink>;
84202950:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202954:	0f 00 0d dc 	rts;

84202958 <$celt.window_reshuffle>:
84202958:	40 00 97 d1 	r7 = M[r5 + 64];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.WINDOW_RESHUFFLE.PATCH_ID_0,r2)     // celt_patchers
#endif

   r7 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];   //OV
   r7 = r7 LSHIFT -1;                           //OV/2
8420295c:	ff 00 99 8d 	r7 = r7 LSHIFT -1;
   Words2Addr(r7);
84202960:	02 00 99 91 	r7 = r7 ASHIFT 2;
   Words2Addr(r8);
84202964:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I0 = r7 + I0;
84202968:	0f 00 09 54 	I0 = r7 + I0;
   I3 = I0 - ADDR_PER_WORD;                                 
8420296c:	04 00 30 79 	I3 = I0 - 4;
   I1 = I3 + r8;                               
84202970:	af 00 13 58 	I1 = I3 + r8;
   I2 = I0 + r8;                                
84202974:	af 00 20 58 	I2 = I0 + r8;
   r0 = M[r5 + $celt.enc.MODE_WINDOW_ADDR_FIELD];   
84202978:	68 00 27 d1 	r0 = M[r5 + 104];
   I4 = r0 + r7;                               
8420297c:	9f 00 42 50 	I4 = r0 + r7;
   I5 = I4 - ADDR_PER_WORD;                                
84202980:	04 00 54 79 	I5 = I4 - 4;
   Addr2Words(r7);
84202984:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   M0 = 2 * ADDR_PER_WORD;
84202988:	08 00 80 51 	M0 = Null + 8;
   M1 = -2 * ADDR_PER_WORD;
8420298c:	f8 ff 90 51 	M1 = Null + -8;
   M2 = 1 * ADDR_PER_WORD;
84202990:	04 00 a0 51 	M2 = Null + 4;
   M3 = 1;
84202994:	01 00 b0 51 	M3 = Null + 1;
   r10 = r7 LSHIFT -1;
84202998:	ff 00 c9 8d 	r10 = r7 LSHIFT -1;
   r10 = r10 - M3, r0 = M[I4, M0], r2 = M[I1, M1];  
8420299c:	20 45 cb 66 	r10 = r10 - M3, r2 = M[I1,M1], r0 = M[I4,M0];
   rMAC = r0 * r2, r2 = M[I2, M0];
842029a0:	4f 48 12 cc 	rMAC = r0 * r2 (SS), r2 = M[I2,M0];
   r1 = M[I5, M1];
842029a4:	35 00 00 02 	Null = Null + Null, r1 = M[I5,M1];
   do window_rs1_loop;
842029a8:	06 00 f0 e5 	do $M.celt.window_reshuffle.window_rs1_loop;
      rMAC = rMAC + r1*r2, r2 = M[I0, M0];
842029ac:	4f 40 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I0,M0];
      rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
842029b0:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
      rMAC = rMAC - r1*r2,  r0 = M[I4, M0], r2 = M[I1, M1];
842029b4:	20 45 34 be 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I1,M1], r0 = M[I4,M0];
      rMAC = r0*r2, M[I7, M2] = rMAC, r2 = M[I2, M0];
842029b8:	9e 48 24 ce 	rMAC = r0 * r2 (SS), r2 = M[I2,M0], M[I7,M2] = rMAC;
      r1 = M[I5, M1];
842029bc:	35 00 00 02 	Null = Null + Null, r1 = M[I5,M1];

842029c0 <$M.celt.window_reshuffle.window_rs1_loop>:
   window_rs1_loop:

   rMAC = rMAC + r1*r2, r2 = M[I0, M0];
842029c0:	4f 40 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I0,M0];
   rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
842029c4:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
   rMAC = rMAC - r1*r2;
842029c8:	4f 00 13 bc 	rMAC = rMAC - r1 * r2 (SS);
   M[I7, M2] = rMAC;   
842029cc:	9e 00 00 02 	Null = Null + Null, M[I7,M2] = rMAC;

   Addr2Words(r8);
842029d0:	fe 00 aa 91 	r8 = r8 ASHIFT -2;
   r10 = r8 LSHIFT -1;
842029d4:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
   r10 = r10 - r7;
842029d8:	00 00 c9 23 	r10 = r10 - r7;
   if LE jump end_flat_copy;
842029dc:	07 00 d0 dd 	if LE jump $M.celt.window_reshuffle.end_flat_copy;
   r10 = r10 - M3, r0 = M[I0, M0];
842029e0:	00 20 cb 66 	r10 = r10 - M3, r0 = M[I0,M0];
   do flat_copy_loop;
842029e4:	03 00 f0 e5 	do $M.celt.window_reshuffle.flat_copy_loop;
      r1 = M[I1, M1], M[I7, M2] = r0;
842029e8:	ae 35 00 02 	Null = Null + Null, r1 = M[I1,M1], M[I7,M2] = r0;
      r0 = M[I0, M0], M[I6, M2] = r1;
842029ec:	ba 20 00 02 	Null = Null + Null, r0 = M[I0,M0], M[I6,M2] = r1;

842029f0 <$M.celt.window_reshuffle.flat_copy_loop>:
   flat_copy_loop:
   r1 = M[I1, M1], M[I7, M2] = r0;
842029f0:	ae 35 00 02 	Null = Null + Null, r1 = M[I1,M1], M[I7,M2] = r0;
   M[I6, M2] = r1;   
842029f4:	ba 00 00 02 	Null = Null + Null, M[I6,M2] = r1;

842029f8 <$M.celt.window_reshuffle.end_flat_copy>:
   end_flat_copy:

   r0 = M[r5 + $celt.enc.MODE_WINDOW_ADDR_FIELD];   
842029f8:	68 00 27 d1 	r0 = M[r5 + 104];
   I4 = r0;                               //w1
842029fc:	2f 00 40 50 	I4 = Null + r0;
   Words2Addr(r7);
84202a00:	02 00 99 91 	r7 = r7 ASHIFT 2;
   I5 = I4 + r7;                          //w2
84202a04:	9f 00 54 58 	I5 = I4 + r7;
   I5 = I5 + r7;
84202a08:	00 00 59 5b 	I5 = I5 + r7;
   I5 = I5 - ADDR_PER_WORD;
84202a0c:	04 00 55 79 	I5 = I5 - 4;
   Addr2Words(r7);
84202a10:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   r10 = r7 LSHIFT -1;
84202a14:	ff 00 c9 8d 	r10 = r7 LSHIFT -1;
   Words2Addr(r8);
84202a18:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I2 = I0 - r8;                                 //xp2[-N2]
84202a1c:	af 00 20 78 	I2 = I0 - r8;
   I3 = I1 + r8;                                //xp1[N2]   
84202a20:	af 00 31 58 	I3 = I1 + r8;
   
   r10 = r10 - M3, r0 = M[I5, M1], r2 = M[I1, M1];  
84202a24:	25 45 cb 66 	r10 = r10 - M3, r2 = M[I1,M1], r0 = M[I5,M1];
   rMAC = r0 * r2, r2 = M[I2, M0];
84202a28:	4f 48 12 cc 	rMAC = r0 * r2 (SS), r2 = M[I2,M0];
   r1 = M[I4, M0];
84202a2c:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];
   do window_rs2_loop;
84202a30:	06 00 f0 e5 	do $M.celt.window_reshuffle.window_rs2_loop;
      rMAC = rMAC - r1*r2, r2 = M[I0, M0];
84202a34:	4f 40 13 bc 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I0,M0];
      rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
84202a38:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
      rMAC = rMAC + r1*r2,  r0 = M[I5, M1], r2 = M[I1, M1];
84202a3c:	25 45 34 ae 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I1,M1], r0 = M[I5,M1];
      rMAC = r0*r2, M[I7, M2] = rMAC, r2 = M[I2, M0];
84202a40:	9e 48 24 ce 	rMAC = r0 * r2 (SS), r2 = M[I2,M0], M[I7,M2] = rMAC;
      r1 = M[I4, M0];
84202a44:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];

84202a48 <$M.celt.window_reshuffle.window_rs2_loop>:
   window_rs2_loop:
   rMAC = rMAC - r1*r2, r2 = M[I0, M0];
84202a48:	4f 40 13 bc 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I0,M0];
   rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
84202a4c:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
   rMAC = rMAC + r1*r2, r2 = M[I1, M1];
84202a50:	4f 45 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I1,M1];
   M[I7, M2] = rMAC;   
84202a54:	9e 00 00 02 	Null = Null + Null, M[I7,M2] = rMAC;

   // pop rLink from stack
   rts;
84202a58:	0f 00 0d dc 	rts;

84202a5c <$_celt_setup_thread_offload>:
84202a5c:	00 00 d0 f3 	push rLink;
$_celt_setup_thread_offload:
$celt_dec.setup_thread_offload:

   push rLink;
 
   r0 = &$fft.twiddle_real_address;
84202a60:	7c 02 20 01 	r0 = Null + 636;
   call $_thread_offload_update_p1_dm_location;
84202a64:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84202a68:	5d 4f f0 e1 

   r0 = &$fft.twiddle_imag_address;
84202a6c:	80 02 20 01 	r0 = Null + 640;
   call $_thread_offload_update_p1_dm_location;
84202a70:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84202a74:	5d 4f f0 e1 

   r0 = &$math.fft_twiddle.twiddle_size;
84202a78:	84 02 20 01 	r0 = Null + 644;
   call $_thread_offload_update_p1_dm_location;
84202a7c:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84202a80:	5d 4f f0 e1 

   r0 = &$math.fft_twiddle.twiddle_user;
84202a84:	88 02 20 01 	r0 = Null + 648;
   call $_thread_offload_update_p1_dm_location;
84202a88:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84202a8c:	5d 4f f0 e1 

   pop rLink;
84202a90:	00 00 d4 f3 	pop rLink;
   rts;
84202a94:	0f 00 0d dc 	rts;

84202a98 <$celt.compute_band_energies>:
84202a98:	00 00 d0 f3 	push rLink;
   
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.COMPUTE_BAND_ENERGIES.PATCH_ID_0,r1)     // celt_patchers
#endif

   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84202a9c:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84202aa0:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.MODE_EBANDS_ADDR_FIELD];
84202aa4:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84202aa8:	2f 00 30 50 	I3 = Null + r0;
   I6 = r2;
84202aac:	4f 00 60 50 	I6 = Null + r2;

84202ab0 <$M.celt.compute_band_energies.calc_bande_loop>:
   calc_bande_loop:
      r6 = 1;
84202ab0:	2f 00 80 e4 	r6 = Null + 1;
      r0 = M[I3, MK1];
84202ab4:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      r1 = M[I3, 0];
84202ab8:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
      r10 = r1 - r0;
84202abc:	2f 00 c3 20 	r10 = r1 - r0;
      r10 = r10 - 1;
84202ac0:	3f 00 cc e4 	r10 = r10 - 1;
      rMAC = 0, r0 = M[I2, MK1];
84202ac4:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
      do calc_en_loop;
84202ac8:	02 00 f0 e5 	do $M.celt.compute_band_energies.calc_en_loop;
         rMAC = rMAC + r0*r0, r0 = M[I2, MK1];
84202acc:	00 29 22 af 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I2,4];

84202ad0 <$M.celt.compute_band_energies.calc_en_loop>:
      calc_en_loop:
      rMAC = rMAC + r0*r0;
84202ad0:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);
      if Z rMAC = rMAC + r6*r6;
84202ad4:	80 00 18 ac 	if EQ rMAC = rMAC + r6 * r6 (SS);
      r8 = signdet rMAC;
84202ad8:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
      r8 = r8 AND $celt.BANDS_PROC_LSB_FLAG;
84202adc:	ff ff 00 fd 	r8 = r8 AND 0xfffffffe;
84202ae0:	fe ff aa 81 
      rMAC = rMAC ASHIFT r8 (56bit);
84202ae4:	00 00 1a 93 	rMAC = rMAC ASHIFT r8 (56bit);
      push I3;
84202ae8:	00 00 31 f3 	push I3;
      call $math.sqrt48;
84202aec:	07 00 00 fd 	call 0x743c8;
84202af0:	c8 43 f0 e1 
      pop I3;
84202af4:	00 00 35 f3 	pop I3;
      r1 = r8 * (-0.5)(frac);
84202af8:	00 c0 3a 95 	r1 = r8 * -0.5 (frac);
      M[I1, MK1] = r0;            //gain
84202afc:	00 a5 00 03 	Null = Null + Null, M[I1,4] = r0;
      r1 = r1 - I6;
84202b00:	00 00 36 67 	r1 = r1 - I6;
      M[I1, 0] = r1;            //shift
84202b04:	00 b4 00 03 	Null = Null + Null, M[I1,0] = r1;
      rMAC = r0;
84202b08:	0f 00 12 00 	rMAC = r0 + Null;
      call $math.log2_table;
84202b0c:	07 00 00 fd 	call 0x745ac;
84202b10:	ac 45 f0 e1 
      r1 = M[I1, MK1];
84202b14:	00 35 00 03 	Null = Null + Null, r1 = M[I1,4];
      r1 = r1 + 13;   //adjust scale 
84202b18:	0d 00 33 01 	r1 = r1 + 13;
      r1 = r1 ASHIFT (DAWTH - 8);       
84202b1c:	18 00 33 91 	r1 = r1 ASHIFT 24;
      r0 = r0 + r1;
84202b20:	00 00 23 03 	r0 = r0 + r1;
      M[I5, MK1] = r0;
84202b24:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;
      M3 = M3 - 1;
84202b28:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_bande_loop;
84202b2c:	e1 ff 10 dd 	if NE jump $M.celt.compute_band_energies.calc_bande_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202b30:	03 00 00 fd 	jump (m) 0x3b020;
84202b34:	21 b0 f0 dd 

84202b38 <$celt.normalise_bands>:
.MODULE $M.celt.normalise_bands;
   .CODESEGMENT CELT_NORMALISE_BANDS_PM;
   .DATASEGMENT DM;
   $celt.normalise_bands:
   // push rLink onto stack
   push rlink;
84202b38:	00 00 d0 f3 	push rLink;

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.NORMALISE_BANDS.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84202b3c:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84202b40:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.MODE_EBANDS_ADDR_FIELD];
84202b44:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84202b48:	2f 00 30 50 	I3 = Null + r0;
   I6 = r2;
84202b4c:	4f 00 60 50 	I6 = Null + r2;

84202b50 <$M.celt.normalise_bands.norm_bands_loop>:
   norm_bands_loop:
      r0 = M[I3, MK1];
84202b50:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      r1 = M[I3, 0];
84202b54:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
      r10 = r1 - r0;
84202b58:	2f 00 c3 20 	r10 = r1 - r0;
      r10 = r10 - 1;
84202b5c:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[I1, MK1];   //gain
84202b60:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
      r1 = M[I1, MK1];   //shift
84202b64:	00 35 00 03 	Null = Null + Null, r1 = M[I1,4];
      r1 = r1 + I6;
84202b68:	00 00 36 47 	r1 = r1 + I6;
      r1 = 1 - r1;
84202b6c:	01 00 33 65 	r1 = 1 - r1;
      rMAC = 0.125;
84202b70:	00 10 00 fd 	rMAC = Null + 268435456;
84202b74:	00 00 10 01 
      Div = rMAC/ r0;
84202b78:	00 00 12 d9 	Div = rMAC / r0;
      r0 = DivResult;
84202b7c:	01 00 20 d9 	r0 = DivResult;
      r2 = M[I2, MK1];
84202b80:	00 49 00 03 	Null = Null + Null, r2 = M[I2,4];
      rMAC = r2 * r0;
84202b84:	2f 00 14 cc 	rMAC = r2 * r0 (SS);
      do normalize_band_loop;
84202b88:	03 00 f0 e5 	do $M.celt.normalise_bands.normalize_band_loop;
         rMAC = rMAC ASHIFT r1 (56bit), r2 = M[I2, MK1];
84202b8c:	00 49 13 93 	rMAC = rMAC ASHIFT r1 (56bit), r2 = M[I2,4];
         rMAC = r2 * r0, M[I5, MK1] = rMAC;         
84202b90:	95 00 42 cf 	rMAC = r2 * r0 (SS), M[I5,4] = rMAC;

84202b94 <$M.celt.normalise_bands.normalize_band_loop>:
      normalize_band_loop:
      rMAC = rMAC ASHIFT r1 (56bit);
84202b94:	00 00 13 93 	rMAC = rMAC ASHIFT r1 (56bit);
      M[I5, MK1] = rMAC; 
84202b98:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
   M3 = M3 - 1;
84202b9c:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump norm_bands_loop; 
84202ba0:	ec ff 10 dd 	if NE jump $M.celt.normalise_bands.norm_bands_loop;
   r0 = M[I3, MK1];
84202ba4:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
   r1 = M[I3, 0];
84202ba8:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
   r10 = r1 - r0;
84202bac:	2f 00 c3 20 	r10 = r1 - r0;
   r0 = 0;
84202bb0:	00 00 20 01 	r0 = Null + 0;
   do zero_last_band;
84202bb4:	02 00 f0 e5 	do $M.celt.normalise_bands.zero_last_band;
       M[I5, MK1] = r0;
84202bb8:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

84202bbc <$M.celt.normalise_bands.zero_last_band>:
   zero_last_band:
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202bbc:	03 00 00 fd 	jump (m) 0x3b020;
84202bc0:	21 b0 f0 dd 

84202bc4 <$celt.bands_process>:
.MODULE $M.celt.bands_process;
   .CODESEGMENT CELT_BAND_PROCESS_PM;
   .DATASEGMENT DM;
   $celt.bands_process:
   // push rLink onto stack
   push rlink;
84202bc4:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BANDS_PROCESS.PATCH_ID_0,r2)     // celt_patchers
#endif
   
   // -- compute band energies (left channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 0 * ADDR_PER_WORD];
84202bc8:	f8 01 47 d1 	r2 = M[r5 + 504];
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
84202bcc:	14 01 27 d1 	r0 = M[r5 + 276];
   I2 = r0;
84202bd0:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84202bd4:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0;
84202bd8:	2f 00 10 50 	I1 = Null + r0;
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
84202bdc:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0;
84202be0:	2f 00 50 50 	I5 = Null + r0;
   call $celt.compute_band_energies;
84202be4:	ad ff f0 e1 	call $celt.compute_band_energies;

   // -- nomalise bands (left channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 0 * ADDR_PER_WORD];
84202be8:	f8 01 47 d1 	r2 = M[r5 + 504];
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
84202bec:	14 01 27 d1 	r0 = M[r5 + 276];
   I2 = r0;
84202bf0:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84202bf4:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0;
84202bf8:	2f 00 10 50 	I1 = Null + r0;
   r0 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
84202bfc:	cc 00 27 d1 	r0 = M[r5 + 204];
   I5 = r0;
84202c00:	2f 00 50 50 	I5 = Null + r0;
   call $celt.normalise_bands;
84202c04:	cd ff f0 e1 	call $celt.normalise_bands;
   
   // -- return if it's mono encoding
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84202c08:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z  jump $pop_rLink_and_rts;
84202c0c:	03 00 00 fd 	if EQ jump (m) 0x3b020;
84202c10:	21 b0 00 dd 
   
   // -- compute band energies (right channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 1 * ADDR_PER_WORD];
84202c14:	fc 01 47 d1 	r2 = M[r5 + 508];
   r0 = M[r5 + $celt.enc.FREQ2_FIELD];
84202c18:	18 01 27 d1 	r0 = M[r5 + 280];
   I2 = r0;
84202c1c:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84202c20:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0 + ($celt.MAX_BANDSx2 * MK1);
84202c24:	c8 00 12 51 	I1 = r0 + 200;
   
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
84202c28:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0 + ($celt.MAX_BANDS * MK1);
84202c2c:	64 00 52 51 	I5 = r0 + 100;
   call $celt.compute_band_energies;
84202c30:	9a ff f0 e1 	call $celt.compute_band_energies;

   // -- normalise bands (right channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 1 * ADDR_PER_WORD];
84202c34:	fc 01 47 d1 	r2 = M[r5 + 508];
   r0 = M[r5 + $celt.enc.FREQ2_FIELD];
84202c38:	18 01 27 d1 	r0 = M[r5 + 280];
   I2 = r0;
84202c3c:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84202c40:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0 + ($celt.MAX_BANDSx2 * MK1);
84202c44:	c8 00 12 51 	I1 = r0 + 200;
   
   r0 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
84202c48:	cc 00 27 d1 	r0 = M[r5 + 204];
   r1 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84202c4c:	44 00 37 d1 	r1 = M[r5 + 68];
   Words2Addr(r1);
84202c50:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I5 = r0 + r1;
84202c54:	3f 00 52 50 	I5 = r0 + r1;
   call $celt.normalise_bands;
84202c58:	b8 ff f0 e1 	call $celt.normalise_bands;
      
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202c5c:	03 00 00 fd 	jump (m) 0x3b020;
84202c60:	21 b0 f0 dd 

84202c64 <$celt.compute_allocation>:
84202c64:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.COMPUTE_ALLOCATION.PATCH_ID_0,r4)     // celt_patchers
#endif

   // see how many bits used so far
   r4 = 0;
84202c68:	00 00 60 01 	r4 = Null + 0;
   r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84202c6c:	30 00 27 d1 	r0 = M[r5 + 48];
   call r0;
84202c70:	0f 00 02 e0 	call r0;

   // calc bits available
   r3 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84202c74:	04 00 57 d1 	r3 = M[r5 + 4];
   r3 = r3 * 8 (int);
84202c78:	08 00 55 99 	r3 = r3 * 8 (int);
   r3 = r3 - r0;
84202c7c:	00 00 52 23 	r3 = r3 - r0;
   r3 = r3 - 1;
84202c80:	3f 00 55 e4 	r3 = r3 - 1;
   r3 = r3 LSHIFT $celt.BITRES;
84202c84:	04 00 55 8d 	r3 = r3 LSHIFT 4;
   // init:  r6 = lo, r7 = hi
   r6 = 0;
84202c88:	00 00 80 01 	r6 = Null + 0;
   r7 = M[r5 + $celt.dec.MODE_NB_ALLOC_VECTORS_FIELD];
84202c8c:	54 00 97 d1 	r7 = M[r5 + 84];
   r7 = r7 - 1;   
84202c90:	3f 00 99 e4 	r7 = r7 - 1;

84202c94 <$M.celt.compute_allocation.find_lo_hi_loop>:
   find_lo_hi_loop:
   r0 = r7 - r6;
84202c94:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
84202c98:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump end_bits_loop;
84202c9c:	16 00 00 dd 	if EQ jump $M.celt.compute_allocation.end_bits_loop;
      r4 = r6 + r7;
84202ca0:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
84202ca4:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202ca8:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = r10*r4(int);
84202cac:	6f 00 2c 98 	r0 = r10 * r4 (int);
      Words2Addr(r0);
84202cb0:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r10 = r10 - 1;
84202cb4:	3f 00 cc e4 	r10 = r10 - 1;
      r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
84202cb8:	64 00 37 d1 	r1 = M[r5 + 100];
      I6 = r1 + r0;
84202cbc:	2f 00 63 50 	I6 = r1 + r0;
      r1 = r1 - r1, r0 = M[I6, MK1];      
84202cc0:	29 00 33 23 	r1 = r1 - r1, r0 = M[I6,4];
      do bits1_loop;
84202cc4:	02 00 f0 e5 	do $M.celt.compute_allocation.bits1_loop;
         r1 = r1 + r0, r0 = M[I6, MK1];
84202cc8:	29 00 32 03 	r1 = r1 + r0, r0 = M[I6,4];

84202ccc <$M.celt.compute_allocation.bits1_loop>:
      bits1_loop:
      r1 = r1 + r0;
84202ccc:	00 00 32 03 	r1 = r1 + r0;
      r2 = (1<<$celt.BITRES);
84202cd0:	10 00 40 01 	r2 = Null + 16;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84202cd4:	08 00 27 d1 	r0 = M[r5 + 8];
      if NZ r2 = r2 + r2;
84202cd8:	41 00 44 00 	if NE r2 = r2 + r2;
      r1 = r1 * r2 (int);
84202cdc:	00 00 34 9b 	r1 = r1 * r2 (int);
      Null = r1 - r3;
84202ce0:	5f 00 03 20 	Null = r1 - r3;
      if GT r7 = r4;
84202ce4:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r1 - r3;
84202ce8:	5f 00 03 20 	Null = r1 - r3;
      if LE r6 = r4;
84202cec:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_lo_hi_loop;
84202cf0:	e9 ff f0 dd 	jump $M.celt.compute_allocation.find_lo_hi_loop;

84202cf4 <$M.celt.compute_allocation.end_bits_loop>:
   end_bits_loop:
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202cf4:	48 00 c7 d1 	r10 = M[r5 + 72];
   r0 = r6*r10(int);
84202cf8:	cf 00 28 98 	r0 = r6 * r10 (int);
   Words2Addr(r0);
84202cfc:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
84202d00:	64 00 37 d1 	r1 = M[r5 + 100];
   I5 = r0 + r1;
84202d04:	3f 00 52 50 	I5 = r0 + r1;
   r0 = r7*r10(int);
84202d08:	cf 00 29 98 	r0 = r7 * r10 (int);
   Words2Addr(r0);
84202d0c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   I6 = r0 + r1;
84202d10:	3f 00 62 50 	I6 = r0 + r1;
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
84202d14:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
84202d18:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
84202d1c:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
84202d20:	2f 00 30 50 	I3 = Null + r0;
   r2 = 1;
84202d24:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84202d28:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ r2 = r2 + r2;
84202d2c:	41 00 44 00 	if NE r2 = r2 + r2;
   r10 = r10 - 1;
84202d30:	3f 00 cc e4 	r10 = r10 - 1;
   r1 = M[I6, MK1];
84202d34:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r1 = r1 * r2(int), r0 = M[I5, MK1];
84202d38:	25 00 34 9b 	r1 = r1 * r2 (int), r0 = M[I5,4];
   do bits_loop;
84202d3c:	03 00 f0 e5 	do $M.celt.compute_allocation.bits_loop;
      r0 = r0 * r2(int), r1= M[I6, MK1], M[I3, MK1] = r1;
84202d40:	39 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1, r1 = M[I6,4];
      r1 = r1 * r2(int), r0= M[I5, MK1], M[I2, MK1] = r0;
84202d44:	25 a9 34 9b 	r1 = r1 * r2 (int), M[I2,4] = r0, r0 = M[I5,4];

84202d48 <$M.celt.compute_allocation.bits_loop>:
   bits_loop:
   r0 = r0 * r2(int), M[I3, MK1] = r1;
84202d48:	00 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1;
   M[I2, MK1] = r0;
84202d4c:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;
   
   call  $celt.interp_bits2pulses;
84202d50:	03 00 f0 e1 	call $celt.interp_bits2pulses;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202d54:	03 00 00 fd 	jump (m) 0x3b020;
84202d58:	21 b0 f0 dd 

84202d5c <$celt.interp_bits2pulses>:
   .CODESEGMENT CELT_INTERP_BITS2PULSES_PM;
   .DATASEGMENT DM;
   
   $celt.interp_bits2pulses:
   // push rLink onto stack
   push rlink;
84202d5c:	00 00 d0 f3 	push rLink;

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.INTERP_BITS2PULSES.PATCH_ID_0,r6)     // celt_patchers
#endif
   
   r6 = 0;
84202d60:	00 00 80 01 	r6 = Null + 0;
   r7 = 1<<$celt.BITRES;
84202d64:	10 00 90 01 	r7 = Null + 16;
   M0 = ADDR_PER_WORD;
84202d68:	04 00 80 51 	M0 = Null + 4;

84202d6c <$M.celt.interp_bits2pulses.find_hi_lo_loop>:
   find_hi_lo_loop:
   r0 = r7 - r6;
84202d6c:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
84202d70:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump find_hi_lo_loop_end;
84202d74:	17 00 00 dd 	if EQ jump $M.celt.interp_bits2pulses.find_hi_lo_loop_end;
      r4 = r6 + r7;
84202d78:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
84202d7c:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202d80:	48 00 c7 d1 	r10 = M[r5 + 72];
      r10 = r10 - 1;
84202d84:	3f 00 cc e4 	r10 = r10 - 1;
      r2 = 1<<$celt.BITRES;
84202d88:	10 00 40 01 	r2 = Null + 16;
      r2 = r2 - r4;
84202d8c:	00 00 46 23 	r2 = r2 - r4;
      r0 = M[r5 + $celt.dec.BITS1_FIELD];
84202d90:	bc 00 27 d1 	r0 = M[r5 + 188];
      I2 = r0;
84202d94:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.dec.BITS2_FIELD];
84202d98:	c0 00 27 d1 	r0 = M[r5 + 192];
      I3 = r0;
84202d9c:	2f 00 30 50 	I3 = Null + r0;
      rMAC = 0, r0 = M[I2, MK1];
84202da0:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
      rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
84202da4:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];
      do avg_loop1;
84202da8:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop1;
         rMAC = rMAC + r0*r4, r0 = M[I2, MK1];
84202dac:	00 29 26 af 	rMAC = rMAC + r0 * r4 (SS), r0 = M[I2,4];
         rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
84202db0:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];

84202db4 <$M.celt.interp_bits2pulses.avg_loop1>:
      avg_loop1:
      rMAC = rMAC + r0*r4;
84202db4:	6f 00 12 ac 	rMAC = rMAC + r0 * r4 (SS);
      r0 = rMAC LSHIFT (DAWTH-1);
84202db8:	1f 00 21 8d 	r0 = rMAC LSHIFT 31;
      Null = r0 - r3;
84202dbc:	5f 00 02 20 	Null = r0 - r3;
      if GT r7 = r4;
84202dc0:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r0 - r3;
84202dc4:	5f 00 02 20 	Null = r0 - r3;
      if LE r6 = r4;
84202dc8:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_hi_lo_loop;
84202dcc:	e8 ff f0 dd 	jump $M.celt.interp_bits2pulses.find_hi_lo_loop;

84202dd0 <$M.celt.interp_bits2pulses.find_hi_lo_loop_end>:
   
   find_hi_lo_loop_end:
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
84202dd0:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
84202dd4:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
84202dd8:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
84202ddc:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202de0:	04 01 27 d1 	r0 = M[r5 + 260];
   I4 = r0;
84202de4:	2f 00 40 50 	I4 = Null + r0;
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202de8:	48 00 c7 d1 	r10 = M[r5 + 72];
   r2 = 1<<$celt.BITRES;
84202dec:	10 00 40 01 	r2 = Null + 16;
   r2 = r2 - r6;
84202df0:	00 00 48 23 	r2 = r2 - r6;
   rMAC = 0, r0 = M[I2, MK1];
84202df4:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
   do avg_loop2;
84202df8:	05 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop2;
      r0 = r0*r2 (int), r1 = M[I3, MK1];
84202dfc:	00 3d 24 9b 	r0 = r0 * r2 (int), r1 = M[I3,4];
      r1 = r1 * r6 (int);
84202e00:	00 00 38 9b 	r1 = r1 * r6 (int);
      r4 = r1 + r0, r0 = M[I2, M0];
84202e04:	2f 28 63 00 	r4 = r1 + r0, r0 = M[I2,M0];
      rMAC = rMAC + r4, M[I4, MK1] = r4;
84202e08:	e1 00 16 03 	rMAC = rMAC + r4, M[I4,4] = r4;

84202e0c <$M.celt.interp_bits2pulses.avg_loop2>:
   avg_loop2:   
   
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202e0c:	48 00 c7 d1 	r10 = M[r5 + 72];
   rMAC = r3 - rMAC;
84202e10:	1f 00 15 20 	rMAC = r3 - rMAC;
   rMAC0 = rMAC1;
84202e14:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = Null(ZP);
84202e18:	00 04 e0 8d 	rMAC12 = Null LSHIFT 0;
   Div = rMAC/r10;
84202e1c:	00 00 1c d9 	Div = rMAC / r10;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202e20:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
84202e24:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2;
84202e28:	0f 00 32 58 	I3 = I2 + Null;
   r0 = M[I2, M0];   
84202e2c:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   r2 = DivResult;
84202e30:	01 00 40 d9 	r2 = DivResult;
   do add_per_band_loop;
84202e34:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_per_band_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84202e38:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84202e3c:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84202e40 <$M.celt.interp_bits2pulses.add_per_band_loop>:
   add_per_band_loop:
   
   r10 = DivRemainder;
84202e40:	02 00 c0 d9 	r10 = DivRemainder;
   r2 = 1;
84202e44:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202e48:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
84202e4c:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2, r0 = M[I2, M0];   
84202e50:	0f 28 32 58 	I3 = I2 + Null, r0 = M[I2,M0];
   do add_reamin_loop;
84202e54:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_reamin_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84202e58:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84202e5c:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84202e60 <$M.celt.interp_bits2pulses.add_reamin_loop>:
   add_reamin_loop:  
   
   r3 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202e60:	48 00 57 d1 	r3 = M[r5 + 72];
   Words2Addr(r3);
84202e64:	02 00 55 91 	r3 = r3 ASHIFT 2;
   M3 = r3;
84202e68:	5f 00 b0 50 	M3 = Null + r3;
   M1 = 0;
84202e6c:	00 00 90 51 	M1 = Null + 0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84202e70:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84202e74:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202e78:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;        
84202e7c:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84202e80:	08 01 27 d1 	r0 = M[r5 + 264];
   I6 = r0;     
84202e84:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_PRIORITY_FIELD];
84202e88:	0c 01 27 d1 	r0 = M[r5 + 268];
   I7 = r0;  //fine-pr
84202e8c:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[I3, MK1];   //ebands[j];
84202e90:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
   r1 = M[I3, 0];   
84202e94:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];

84202e98 <$M.celt.interp_bits2pulses.loop_calc_bits>:
   //N=r1
   loop_calc_bits:
      r1 = r1 - r0; 
84202e98:	00 00 32 23 	r1 = r1 - r0;
      push r1;         //save r1
84202e9c:	00 00 30 f3 	push r1;
      rMAC = 0;        //rMAC=N
84202ea0:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84202ea4:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES; 
84202ea8:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;       
84202eac:	ea 00 f0 e1 	call $celt.log2_frac;
      r3 = $celt.FINE_OFFSET - r0; 
84202eb0:	32 00 52 65 	r3 = 50 - r0;
      //offset = r3
      pop r1;
84202eb4:	00 00 34 f3 	pop r1;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD]; 
84202eb8:	08 00 27 d1 	r0 = M[r5 + 8];
      r4 = r0*r1(int);                            
84202ebc:	3f 00 62 98 	r4 = r0 * r1 (int);
      r4 = r4 + r1;                               
84202ec0:	00 00 63 03 	r4 = r4 + r1;
      r2 = r4 + r0;                               
84202ec4:	2f 00 46 00 	r2 = r4 + r0;
      r2 = r2 LSHIFT $celt.BITRES;                
84202ec8:	04 00 44 8d 	r2 = r2 LSHIFT 4;
      r4 = r4 *r3(int), r1 = M[I2, 0];            
84202ecc:	00 38 65 9b 	r4 = r4 * r3 (int), r1 = M[I2,0];
      r4 = r1 - r4;                               
84202ed0:	6f 00 63 20 	r4 = r1 - r4;
      r1 = r0 LSHIFT $celt.BITRES;                
84202ed4:	04 00 32 8d 	r1 = r0 LSHIFT 4;
      r4 = r4 - r1;                               
84202ed8:	00 00 63 23 	r4 = r4 - r1;
      if NEG r4 = 0; 
84202edc:	04 00 60 00 	if NEG r4 = Null + Null;
      //r4 = offset
      r1 = r2 + r2;                               
84202ee0:	4f 00 34 00 	r1 = r2 + r2;
      r6 = r4 + r4;                               
84202ee4:	6f 00 86 00 	r6 = r4 + r4;
      r6 = r6 + r2;                               
84202ee8:	00 00 84 03 	r6 = r6 + r2;
      rMAC = 0;
84202eec:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r6;
84202ef0:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
      Div = rMAC / r1; 
84202ef4:	00 00 13 d9 	Div = rMAC / r1;
      r6 = DivResult;                             
84202ef8:	01 00 80 d9 	r6 = DivResult;
      r3 = r6 * r2 (int);                         
84202efc:	4f 00 58 98 	r3 = r6 * r2 (int);
      r1 = 1;
84202f00:	2f 00 30 e4 	r1 = Null + 1;
      Null = r3 - r4;
84202f04:	6f 00 05 20 	Null = r3 - r4;
      if NEG r1 = r1 - r1, r3 = M[I2, M1];
84202f08:	34 59 33 20 	if NEG r1 = r1 - r1, r3 = M[I2,M1];
      //r1 = fine-p
      r2 = r6 LSHIFT r0; //r7=eb(j)*C
84202f0c:	2f 00 48 8c 	r2 = r6 LSHIFT r0;
      r4 = r3 LSHIFT (-$celt.BITRES);
84202f10:	fc 00 65 8d 	r4 = r3 LSHIFT -4;
      Null = r2 - r4;                     
84202f14:	6f 00 04 20 	Null = r2 - r4;
      if GT r2 = r4;
84202f18:	0c 00 46 00 	if GT r2 = r4 + Null;
      r6 = -r0;
84202f1c:	2f 00 80 20 	r6 = Null - r0;
      r2 = r2 LSHIFT r6, M[I7, MK1] = r1; 
84202f20:	bd 00 48 8f 	r2 = r2 LSHIFT r6, M[I7,4] = r1;
      r7 = r2 - 7;
84202f24:	07 00 94 21 	r7 = r2 - 7;
      if POS r2 = r2 - r7;
84202f28:	95 00 44 20 	if POS r2 = r2 - r7;
      r0 = r0 + $celt.BITRES;
84202f2c:	bf 00 22 e4 	r0 = r0 + 4;
      r2 = r2 LSHIFT r0, M[I6, MK1] = r2;
84202f30:	c9 00 42 8f 	r2 = r2 LSHIFT r0, M[I6,4] = r2;
      r3 = r3 - r2, r0 = M[I3, MK1];
84202f34:	00 2d 54 23 	r3 = r3 - r2, r0 = M[I3,4];
      if NEG r3 = r3 - r3, r1 = M[I3, M1];
84202f38:	54 3d 55 20 	if NEG r3 = r3 - r3, r1 = M[I3,M1];
      M3 = M3 - M0, M[I2, MK1] = r3;
84202f3c:	00 d9 b8 7f 	M3 = M3 - M0, M[I2,4] = r3;
   if NZ jump   loop_calc_bits;    
84202f40:	d6 ff 10 dd 	if NE jump $M.celt.interp_bits2pulses.loop_calc_bits;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202f44:	03 00 00 fd 	jump (m) 0x3b020;
84202f48:	21 b0 f0 dd 

84202f4c <$celt.alloc_state_mem>:
84202f4c:	19 00 20 01 	r0 = Null + 25;
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_STATE_MEM.PATCH_ID_0,r1)     // celt_patchers
#endif   

   // -- get data object
   r0 = $celt.MAX_BANDS;
   r1 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];   
84202f50:	40 00 37 d1 	r1 = M[r5 + 64];
   r2 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84202f54:	08 00 47 d1 	r2 = M[r5 + 8];
   r2 = r2 + 1;
84202f58:	2f 00 44 e4 	r2 = r2 + 1;
   r3 = r0 + r1;
84202f5c:	3f 00 52 00 	r3 = r0 + r1;
   r3 = r3 * r2 (int);
84202f60:	00 00 54 9b 	r3 = r3 * r2 (int);
   Null = r7 - r3;
84202f64:	5f 00 09 20 	Null = r7 - r3;
   if NEG call $error;
84202f68:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84202f6c:	3f ac 40 e1 
   M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD] = r8;
84202f70:	8c 00 a7 d5 	M[r5 + 140] = r8;
   Words2Addr(r0);
84202f74:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r8 = r8 + r0;
84202f78:	00 00 a2 03 	r8 = r8 + r0;
   if NZ r8 = r8 + r0;
84202f7c:	21 00 aa 00 	if NE r8 = r8 + r0;
   M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD] = r8;
84202f80:	94 00 a7 d5 	M[r5 + 148] = r8;
   Words2Addr(r1);
84202f84:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;   
84202f88:	00 00 a3 03 	r8 = r8 + r1;
   M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD] = r8;   
84202f8c:	98 00 a7 d5 	M[r5 + 152] = r8;

   rts;
84202f90:	0f 00 0d dc 	rts;

84202f94 <$celt.alloc_scratch_mem>:
  
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_SCRATCH_MEM.PATCH_ID_0,r6)     // celt_patchers
#endif
  
   I0 = r5 + $celt.dec.DM1_SCRATCH_FIELDS_OFFSET ;
84202f94:	bc 00 07 51 	I0 = r5 + 188;
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
84202f98:	0e 00 c0 01 	r10 = Null + 14;
   I4 = r1;
84202f9c:	3f 00 40 50 	I4 = Null + r1;
   do copy_dm1_loop;
84202fa0:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm1_loop;
      r0 = M[I4, MK1];
84202fa4:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84202fa8:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r2;
84202fac:	00 00 24 03 	r0 = r0 + r2;
      M[I0, MK1] = r0;
84202fb0:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84202fb4 <$M.celt.alloc_scratch_mem.copy_dm1_loop>:
   copy_dm1_loop:
   
   I0 = r5 + $celt.dec.DM2_SCRATCH_FIELDS_OFFSET ;
84202fb4:	04 01 07 51 	I0 = r5 + 260;
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
84202fb8:	0d 00 c0 01 	r10 = Null + 13;
   I4 = r3;
84202fbc:	5f 00 40 50 	I4 = Null + r3;
   do copy_dm2_loop;
84202fc0:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm2_loop;
      r0 = M[I4, MK1];
84202fc4:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84202fc8:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r4;
84202fcc:	00 00 26 03 	r0 = r0 + r4;
      M[I0, MK1] = r0;
84202fd0:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84202fd4 <$M.celt.alloc_scratch_mem.copy_dm2_loop>:
   copy_dm2_loop:
   rts;
84202fd4:	0f 00 0d dc 	rts;

84202fd8 <$celt.encode_flags>:
84202fd8:	00 00 d0 f3 	push rLink;
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_FLAGS.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
    push rlink;
   r0 = M[r5 + $celt.enc.INTRA_ENER_FIELD];
84202fdc:	54 01 27 d1 	r0 = M[r5 + 340];
   r1 = M[r5 + $celt.enc.HAS_PITCH_FIELD];
84202fe0:	5c 01 37 d1 	r1 = M[r5 + 348];
   r0 = r0 OR r1;
84202fe4:	00 00 23 87 	r0 = r0 OR r1;
   r1 = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
84202fe8:	58 01 37 d1 	r1 = M[r5 + 344];
   r0 = r0 OR r1;
84202fec:	00 00 23 87 	r0 = r0 OR r1;
   r1 = M[r5 + $celt.enc.HAS_FOLD_FIELD];
84202ff0:	60 01 37 d1 	r1 = M[r5 + 352];
   r0 = r0 OR r1;
84202ff4:	00 00 23 87 	r0 = r0 OR r1;
   // verify it is a valid flag
   r10 = 8;
84202ff8:	08 00 c0 01 	r10 = Null + 8;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.enc.PTR_FLAGLIST_TABLE_FIELD];
84202ffc:	10 02 37 d1 	r1 = M[r5 + 528];
   I2 = r1;
84203000:	3f 00 20 50 	I2 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.flaglist;
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = M[I2, MK1];
84203004:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
   r2 = r1 AND $celt.FLAG_MASK;
84203008:	00 3c 43 81 	r2 = r1 AND 0x3c00;
   do ver_on_list_loop;
8420300c:	04 00 f0 e5 	do $M.celt.encode_flags.ver_on_list_loop;
      r2 = r2 - r0, r1 = M[I2, MK1];
84203010:	00 39 42 23 	r2 = r2 - r0, r1 = M[I2,4];
      if Z jump break_ver_lp;
84203014:	05 00 00 dd 	if EQ jump $M.celt.encode_flags.break_ver_lp;
      r2 = r1 AND $celt.FLAG_MASK;
84203018:	00 3c 43 81 	r2 = r1 AND 0x3c00;

8420301c <$M.celt.encode_flags.ver_on_list_loop>:
   ver_on_list_loop:
      // flag not found in the list
      // return error
      r0 = 1;
8420301c:	2f 00 20 e4 	r0 = Null + 1;
      jump $pop_rLink_and_rts;
84203020:	03 00 00 fd 	jump (m) 0x3b020;
84203024:	21 b0 f0 dd 

84203028 <$M.celt.encode_flags.break_ver_lp>:
   break_ver_lp:
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.enc.PTR_FLAGLIST_TABLE_FIELD];
84203028:	10 02 37 d1 	r1 = M[r5 + 528];
   r0 = I2-r1;
8420302c:	3f 00 22 68 	r0 = I2 - r1;
#else // CELT_USE_EXTERNAL_MEMORY
   r0 = I2-(&$celt.flaglist);
#endif // CELT_USE_EXTERNAL_MEMORY
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*ADDR_PER_WORD] = Null;
84203030:	d8 01 07 d5 	M[r5 + 472] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*ADDR_PER_WORD] = Null;
84203034:	d0 01 07 d5 	M[r5 + 464] = Null;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = r1 - 2*ADDR_PER_WORD;
84203038:	08 00 33 21 	r1 = r1 - 8;
   r1 = M[r1 + r0];
8420303c:	00 00 32 d3 	r1 = M[r1 + r0];
#else // CELT_USE_EXTERNAL_MEMORY
   r1 = M[(&$celt.flaglist-2 * ADDR_PER_WORD + r0];   
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = r1 AND 0xF;
84203040:	0f 00 33 81 	r1 = r1 AND 0xf;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
84203044:	d4 01 37 d5 	M[r5 + 468] = r1;
   r1 = 3;
84203048:	03 00 30 01 	r1 = Null + 3;
   Addr2Words(r0);
8420304c:	fe 00 22 91 	r0 = r0 ASHIFT -2;
   r0 = r0 LSHIFT -2;
84203050:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   if NZ r0 = r0 XOR r1;
84203054:	31 00 22 88 	if NE r0 = r0 XOR r1;
   r0 = 4 LSHIFT r0;
84203058:	04 00 22 e9 	r0 = 0x4 LSHIFT r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
8420305c:	cc 01 27 d5 	M[r5 + 460] = r0;
   call $celt.ec_enc_uint;   
84203060:	a8 f8 f0 e1 	call $celt.ec_enc_uint;
   

   Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
84203064:	58 01 07 d1 	Null = M[r5 + 344];
   if Z jump end;
84203068:	20 00 00 dd 	if EQ jump $M.celt.encode_flags.end;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*ADDR_PER_WORD] = Null;
8420306c:	d0 01 07 d5 	M[r5 + 464] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*ADDR_PER_WORD] = Null;
84203070:	d8 01 07 d5 	M[r5 + 472] = Null;
   r0 = M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD];
84203074:	68 01 27 d1 	r0 = M[r5 + 360];
   if Z jump no_transient_shift;
84203078:	0d 00 00 dd 	if EQ jump $M.celt.encode_flags.no_transient_shift;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
8420307c:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = 4;
84203080:	bf 00 20 e4 	r0 = Null + 4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
84203084:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
84203088:	9e f8 f0 e1 	call $celt.ec_enc_uint;
      r0 = M[r5 + $celt.enc.TRANSIENT_TIME_FIELD];
8420308c:	64 01 27 d1 	r0 = M[r5 + 356];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
84203090:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84203094:	40 00 27 d1 	r0 = M[r5 + 64];
      r1 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84203098:	44 00 37 d1 	r1 = M[r5 + 68];
      r0 = r0 + r1;
8420309c:	00 00 23 03 	r0 = r0 + r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
842030a0:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
842030a4:	97 f8 f0 e1 	call $celt.ec_enc_uint;
      jump end;      
842030a8:	10 00 f0 dd 	jump $M.celt.encode_flags.end;

842030ac <$M.celt.encode_flags.no_transient_shift>:
   no_transient_shift:
      r0 = M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD];
842030ac:	6c 01 27 d1 	r0 = M[r5 + 364];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
842030b0:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = 4;
842030b4:	bf 00 20 e4 	r0 = Null + 4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
842030b8:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
842030bc:	91 f8 f0 e1 	call $celt.ec_enc_uint;
      r0 = M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD];
842030c0:	6c 01 27 d1 	r0 = M[r5 + 364];
      if Z jump end;
842030c4:	09 00 00 dd 	if EQ jump $M.celt.encode_flags.end;
      r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
842030c8:	58 00 27 d1 	r0 = M[r5 + 88];
      Null = r0 - 3;
842030cc:	03 00 02 21 	Null = r0 - 3;
      if NEG jump end;
842030d0:	06 00 40 dd 	if NEG jump $M.celt.encode_flags.end;
      r0 = r0 - 1;
842030d4:	3f 00 22 e4 	r0 = r0 - 1;
      r1 = M[r5 + $celt.enc.MDCT_WEIGHT_POS_FIELD];
842030d8:	70 01 37 d1 	r1 = M[r5 + 368];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r1;
842030dc:	d4 01 37 d5 	M[r5 + 468] = r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
842030e0:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
842030e4:	87 f8 f0 e1 	call $celt.ec_enc_uint;

842030e8 <$M.celt.encode_flags.end>:
   end:
   // output
   r0 = 0;
842030e8:	00 00 20 01 	r0 = Null + 0;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842030ec:	03 00 00 fd 	jump (m) 0x3b020;
842030f0:	21 b0 f0 dd 

842030f4 <$celt.ec_laplace_encode_start>:
842030f4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   
   // push rLink onto stack
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842030f8:	04 00 03 f1 	SP = SP + 4;
   M[FP + TEMP] = r1;              // value
842030fc:	08 00 3c f1 	M[FP + 0x8] = r1;
   r10 = r1;                       // value
84203100:	0f 00 c3 00 	r10 = r1 + Null;
   if NEG                          // if(val <0):
   r10 = -r10;                     // val = -val
84203104:	c4 00 c0 20 	if NEG r10 = Null - r10;
   r7 = 32768;                     // ft = 32768;
84203108:	00 00 00 fd 	r7 = Null + 32768;
8420310c:	00 80 90 01 
   r6 = -r3;                       // fl = -fs
84203110:	5f 00 80 20 	r6 = Null - r3;
   M1 = 1;
84203114:	01 00 90 51 	M1 = Null + 1;
   M2 = 0;
84203118:	00 00 a0 51 	M2 = Null + 0;
   do calc_fl_loop;       
8420311c:	12 00 f0 e5 	do $M.celt.ec_laplace_encode_start.calc_fl_loop;
      r4 = r3 + r3;                // fs * 2
84203120:	5f 00 65 00 	r4 = r3 + r3;
      r6 = r6 + r4;                // fl = fl + fs * 2;
84203124:	00 00 86 03 	r6 = r6 + r4;
      r0 = r3;                     // tmp_s = fs
84203128:	0f 00 25 00 	r0 = r3 + Null;
      rMAC = r3*r2;                // fs * (ec_int32) decay
8420312c:	4f 00 15 cc 	rMAC = r3 * r2 (SS);
      r3 = rMAC LSHIFT (DAWTH-15); // fs = (fs * (ec_int32) decay);
84203130:	11 00 51 8d 	r3 = rMAC LSHIFT 17;
      if NZ jump end_update;       // jump if (fs != 0)
84203134:	0b 00 10 dd 	if NE jump $M.celt.ec_laplace_encode_start.end_update;
         r8 = r6 + 2;              // fl + 2
84203138:	af 00 a8 e4 	r8 = r6 + 2;
         Null = r7 - r8;           // (fl + 2 - ft)
8420313c:	af 00 09 20 	Null = r7 - r8;
         if POS jump set_fs;       // if (fl + 2 <= ft) , fs = 1
84203140:	07 00 50 dd 	if POS jump $M.celt.ec_laplace_encode_start.set_fs;
            r3 = r0;               // fs = tmp_s; 
84203144:	0f 00 52 00 	r3 = r0 + Null;
            r6 = r6 - r4;          // fl = tmp_l
84203148:	00 00 86 23 	r6 = r6 - r4;
            r1 = M2;               // value = i
8420314c:	af 00 30 44 	r1 = Null + M2;
            Null = M[FP + TEMP];
84203150:	08 00 08 f1 	Null = M[FP + 0x8];
            if NEG r1 = -r1;       // if(s) , value = -i
84203154:	34 00 30 20 	if NEG r1 = Null - r1;
            jump end_calc_loop;
84203158:	03 00 f0 dd 	jump $M.celt.ec_laplace_encode_start.calc_fl_loop;

8420315c <$M.celt.ec_laplace_encode_start.set_fs>:
      set_fs:
      r3 = 1;
8420315c:	2f 00 50 e4 	r3 = Null + 1;

84203160 <$M.celt.ec_laplace_encode_start.end_update>:
      end_update:
      M2 = M2 + 1;                 // i = i + 1        
84203160:	01 00 aa 59 	M2 = M2 + 1;

84203164 <$M.celt.ec_laplace_encode_start.calc_fl_loop>:
   calc_fl_loop:
   end_calc_loop:
   Null = r6;
84203164:	0f 00 08 00 	Null = r6 + Null;
   if NEG r6 = 0;                  // if (fl < 0) , fl = 0;
84203168:	04 00 80 00 	if NEG r6 = Null + Null;
   Null = M[FP + TEMP];
8420316c:	08 00 08 f1 	Null = M[FP + 0x8];
   if NEG r6 = r6 + r3;            // if (s) , fl = fl + fs;
84203170:	54 00 88 00 	if NEG r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
   r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r6;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 1] = Null;
#else
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r6;
84203174:	d4 01 87 d5 	M[r5 + 468] = r6;
   r6 = r6 + r3;
84203178:	00 00 85 03 	r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r6;
8420317c:	dc 01 87 d5 	M[r5 + 476] = r6;
#endif   
   M[FP + TEMP] = r1;
84203180:	08 00 3c f1 	M[FP + 0x8] = r1;
   call $celt.ec_encode_bin;
84203184:	fc f7 f0 e1 	call $celt.ec_encode_bin;
   r1 = M[FP + TEMP]; 
84203188:	08 00 38 f1 	r1 = M[FP + 0x8];
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
8420318c:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84203190:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203194:	0f 00 0d dc 	rts;

84203198 <$celt.idiv32>:
84203198:	00 04 e5 8d 	rMAC12 = r3 LSHIFT 0;
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // normalise divisor  to DAWTH-1 bits
   rMAC12 = r3(ZP);
   rMAC0 = r2;
8420319c:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
   r10 = signdet rMAC;
842031a0:	0f 00 c1 d8 	r10 = SIGNDET rMAC;
   r4 = rMAC LSHIFT r10;
842031a4:	cf 00 61 8c 	r4 = rMAC LSHIFT r10;

   rMAC12 = r1(ZP);
842031a8:	00 04 e3 8d 	rMAC12 = r1 LSHIFT 0;
   rMAC0 = r0;
842031ac:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r7 = signdet rMAC;
842031b0:	0f 00 91 d8 	r7 = SIGNDET rMAC;
   r7 = r7 - 2;
842031b4:	cf 00 99 e4 	r7 = r7 - 2;
   rMAC = rMAC LSHIFT r7 (56bit);
842031b8:	00 00 19 8f 	rMAC = rMAC LSHIFT r7 (56bit);

   // divide normalised dividend/divisor
   Div = rMAC / r4;
842031bc:	00 00 16 d9 	Div = rMAC / r4;

   // divisor truncated when normalise?
   r8 = r10 - DAWTH;
842031c0:	20 00 ac 21 	r8 = r10 - 32;
   if NEG jump truncate_proc;
842031c4:	12 00 40 dd 	if NEG jump $M.celt.idiv32.truncate_proc;
   r8 = r8 - r7;
842031c8:	00 00 a9 23 	r8 = r8 - r7;
   if POS jump div_rem;
842031cc:	05 00 50 dd 	if POS jump $M.celt.idiv32.div_rem;
      r7 = 0;
842031d0:	00 00 90 01 	r7 = Null + 0;
      r6 = DivResult;
842031d4:	01 00 80 d9 	r6 = DivResult;
      r6 = r6 LSHIFT r8;
842031d8:	00 00 8a 8f 	r6 = r6 LSHIFT r8;
     rts;
842031dc:	0f 00 0d dc 	rts;

842031e0 <$M.celt.idiv32.div_rem>:
   div_rem:
   // result might be more than DAWTH-1 bits
   r10 = r8 - (DAWTH);
842031e0:	20 00 ca 21 	r10 = r8 - 32;
   r7 = DivResult;
842031e4:	01 00 90 d9 	r7 = DivResult;
   r6 = r7 LSHIFT r8;
842031e8:	af 00 89 8c 	r6 = r7 LSHIFT r8;
   r7 = r7 LSHIFT r10;
842031ec:	00 00 9c 8f 	r7 = r7 LSHIFT r10;

   // divide the remainder to divisor
   rMAC = DivRemainder;
842031f0:	02 00 10 d9 	rMAC = DivRemainder;
   rMAC = rMAC LSHIFT r10 (56bit);
842031f4:	00 00 1c 8f 	rMAC = rMAC LSHIFT r10 (56bit);
   Div = rMAC / r4;
842031f8:	00 00 16 d9 	Div = rMAC / r4;

   // add result to previous division result
   r4 = DivResult;
842031fc:	01 00 60 d9 	r4 = DivResult;
   r6 = r6 + r4;
84203200:	00 00 86 03 	r6 = r6 + r4;
   r7 = r7 + carry;
84203204:	00 00 90 07 	r7 = r7 + Null + Carry;
   rts;
84203208:	0f 00 0d dc 	rts;

8420320c <$M.celt.idiv32.truncate_proc>:
   truncate_proc:
      r8 = r8 - r7;
8420320c:	00 00 a9 23 	r8 = r8 - r7;
      r7 = DivResult;
84203210:	01 00 90 d9 	r7 = DivResult;
      r6 = r7 LSHIFT r8;
84203214:	af 00 89 8c 	r6 = r7 LSHIFT r8;
      r8 = r8 - (DAWTH);
84203218:	20 00 aa 21 	r8 = r8 - 32;
      r7 = r7 LSHIFT r8;
8420321c:	00 00 9a 8f 	r7 = r7 LSHIFT r8;
      rMAC = r6*r2 (UU);
84203220:	4f 00 18 c0 	rMAC = r6 * r2 (UU);
      r8 = rMAC LSHIFT (DAWTH-1);
84203224:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
      rMAC0 = rMAC1;
84203228:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
      rMAC12 = rMAC2(ZP);
8420322c:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
      rMAC = rMAC + r7*r2(SU);
84203230:	4f 00 19 a8 	rMAC = rMAC + r7 * r2 (SU);
      rMAC = rMAC + r6*r3(SU);
84203234:	5f 00 18 a8 	rMAC = rMAC + r6 * r3 (SU);
      r4 = rMAC LSHIFT (DAWTH-1);
84203238:	1f 00 61 8d 	r4 = rMAC LSHIFT 31;
      Null = r0 - r8;
8420323c:	af 00 02 20 	Null = r0 - r8;
      Null = r1 - r4 -borrow;
84203240:	6f 00 03 24 	Null = r1 - r4 - Borrow;
      if POS rts;
84203244:	05 00 0d dc 	if POS rts;
         r6 = r6 - 1;
84203248:	3f 00 88 e4 	r6 = r6 - 1;
         r7 = r7 - borrow;
8420324c:	00 00 90 27 	r7 = r7 - Null - Borrow;
   rts;
84203250:	0f 00 0d dc 	rts;

84203254 <$celt.log2_frac>:
   
#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.LOG2_FRAC.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = signdet rMAC;
84203254:	0f 00 31 d8 	r1 = SIGNDET rMAC;
   #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
      r1 = r1 -(DAWTH-17);
84203258:	0f 00 33 21 	r1 = r1 - 15;
      rMAC = rMAC ASHIFT r1(56bit);
8420325c:	00 00 13 93 	rMAC = rMAC ASHIFT r1 (56bit);
      r1 = (DAWTH+16) -r1;
84203260:	30 00 33 65 	r1 = 48 - r1;
      r1 = r1 -6;
      rMAC = rMAC ASHIFT r1;
      rMAC = rMAC * 0.5 (frac);
      r1 = 41 - r1;
   #endif
   r2 = 1 LSHIFT r0;
84203264:	01 00 42 e9 	r2 = 0x1 LSHIFT r0;
   r1 = r1 - 1;
84203268:	3f 00 33 e4 	r1 = r1 - 1;
   r10 = r0+1;
8420326c:	2f 00 c2 e4 	r10 = r0 + 1;
   r6 = 0.5;
84203270:	00 40 00 fd 	r6 = Null + 1073741824;
84203274:	00 00 80 01 
   r0 = r1 LSHIFT r0;
84203278:	2f 00 23 8c 	r0 = r1 LSHIFT r0;
#ifdef K32
   r7 = (0x7FFFFF);
8420327c:	7f 00 00 fd 	r7 = Null + 8388607;
84203280:	ff ff 90 01 
#else
   r7 = (0x7FFF);
#endif
   r1 = 1;
84203284:	2f 00 30 e4 	r1 = Null + 1;
   do comp_loop;
84203288:	0a 00 f0 e5 	do $M.celt.log2_frac.comp_loop;
      NULL = rMAC LSHIFT -16;
8420328c:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ r0 = r0 + r2;
84203290:	41 00 22 00 	if NE r0 = r0 + r2;
      Null = rMAC LSHIFT -16;
84203294:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ rMAC = rMAC * r6 (frac);
84203298:	81 00 11 94 	if NE rMAC = rMAC * r6 (frac);
      rMAC = rMAC * rMAC;
8420329c:	1f 00 11 cc 	rMAC = rMAC * rMAC (SS);
#ifdef K32
      // Adjust rMAC72 to make rMAC0 and rMAC1 bit-exact with ARCH3 when retrieved
      rMAC = rMAC ASHIFT 8 (56bit);
842032a0:	08 00 11 91 	rMAC = rMAC ASHIFT 8 (56bit);
#endif
      rMAC = rMAC + r1 * r7;
842032a4:	9f 00 13 ac 	rMAC = rMAC + r1 * r7 (SS);
      rMAC = rMAC LSHIFT 8;
842032a8:	08 00 e1 8d 	rMAC = rMAC LSHIFT 8 (MI);
      r2 = r2 LSHIFT -1;
842032ac:	ff 00 44 8d 	r2 = r2 LSHIFT -1;

842032b0 <$M.celt.log2_frac.comp_loop>:
   comp_loop:
   rMAC = rMAC - 0x8000;
842032b0:	00 00 00 fd 	rMAC = rMAC - 32768;
842032b4:	00 80 11 21 
   if GT r0 = r0 + r1;
842032b8:	3c 00 22 00 	if GT r0 = r0 + r1;
   rts;
842032bc:	0f 00 0d dc 	rts;

842032c0 <$celt.imusdiv32>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IMUSDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // calc a*b
   rMAC = r0 * r2 (UU);
842032c0:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
842032c4:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
842032c8:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (ZP);
842032cc:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
   rMAC = rMAC + r1 * r2 (SU);
842032d0:	4f 00 13 a8 	rMAC = rMAC + r1 * r2 (SU);
   rMAC = rMAC + r3 * r0 (SU);
842032d4:	2f 00 15 a8 	rMAC = rMAC + r3 * r0 (SU);
   r7 = rMAC LSHIFT (DAWTH-1);
842032d8:	1f 00 91 8d 	r7 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
842032dc:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (SE);
842032e0:	e0 04 e1 91 	rMAC12 = rMAC ASHIFT -32;
   rMAC = rMAC + r1 * r3 (SS);
842032e4:	5f 00 13 ac 	rMAC = rMAC + r1 * r3 (SS);
   r8 = rMAC LSHIFT (DAWTH-1);
842032e8:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
   
   // r8:r7:r6 = a*b, calc a*b-c
   r6 = r6 - r4;
842032ec:	00 00 86 23 	r6 = r6 - r4;
   r7 = r7 - r5 - Borrow;
842032f0:	00 00 97 27 	r7 = r7 - r5 - Borrow;
   r8 = r8 - Borrow;
842032f4:	00 00 a0 27 	r8 = r8 - Null - Borrow;

   // divide to d (result can be up to 32 bits)
   rMAC  = r8;
842032f8:	0f 00 1a 00 	rMAC = r8 + Null;
   rMAC0 = r7;
842032fc:	00 05 e9 8d 	rMAC0 = r7 LSHIFT 0;
   Div = rMAC/r10;
84203300:	00 00 1c d9 	Div = rMAC / r10;
   r3 = DivResult;
84203304:	01 00 50 d9 	r3 = DivResult;
   r2 = DivRemainder;
84203308:	02 00 40 d9 	r2 = DivRemainder;
   r8 = r10 LSHIFT 1;
8420330c:	01 00 ac 8d 	r8 = r10 LSHIFT 1;
   rMAC = r2;
84203310:	0f 00 14 00 	rMAC = r2 + Null;
   rMAC0 = r6;
84203314:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
   Div = rMAC/r8;
84203318:	00 00 1a d9 	Div = rMAC / r8;
   r2 = DivResult;
8420331c:	01 00 40 d9 	r2 = DivResult;
   r8 = DivRemainder;
84203320:	02 00 a0 d9 	r8 = DivRemainder;
   r2 = r2 + r2;
84203324:	00 00 44 03 	r2 = r2 + r2;
   r7 = 1;
84203328:	2f 00 90 e4 	r7 = Null + 1;
   Null = r8 - r10;
8420332c:	cf 00 0a 20 	Null = r8 - r10;
   if POS r2 = r2 + r7;
84203330:	95 00 44 00 	if POS r2 = r2 + r7;
   rts;
84203334:	0f 00 0d dc 	rts;

84203338 <$celt.bitexact_cos>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITEXACT_COS.PATCH_ID_0)     // celt_patchers
#endif
   
   rMAC = r0*r0;
84203338:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
   r3 = 1;
8420333c:	2f 00 50 e4 	r3 = Null + 1;
   rMAC = rMAC + r3*4096;
84203340:	00 00 00 fd 	rMAC = rMAC + r3 * 1.9073486328125e-06 (SS);
84203344:	00 10 15 ad 
   r2 = rMAC ASHIFT (DAWTH-14);
84203348:	12 00 41 91 	r2 = rMAC ASHIFT 18;
   rMAC = r2 - 32767;
8420334c:	ff 7f 14 21 	rMAC = r2 - 32767;
   if POS r2 = r2 - rMAC;
84203350:	15 00 44 20 	if POS r2 = r2 - rMAC;

   rMAC = r2 * (-626);
84203354:	ff ff 00 fd 	rMAC = r2 * -2.91503965854644775390625e-07 (SS);
84203358:	8e fd 14 cd 
   rMAC = rMAC + r3*16384;
8420335c:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84203360:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84203364:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC + 8277;
84203368:	55 20 11 01 	rMAC = rMAC + 8277;

   rMAC = r2 * rMAC;
8420336c:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84203370:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84203374:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84203378:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC - 7651;
8420337c:	e3 1d 11 21 	rMAC = rMAC - 7651;

   rMAC = r2 * rMAC;
84203380:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84203384:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84203388:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
8420338c:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   r2 = rMAC - r2;
84203390:	4f 00 41 20 	r2 = rMAC - r2;
   if POS r2= -r3;
84203394:	55 00 40 20 	if POS r2 = Null - r3;
   r2 = r2 + 32768;
84203398:	00 00 00 fd 	r2 = r2 + 32768;
8420339c:	00 80 44 01 

   rts;
842033a0:	0f 00 0d dc 	rts;

842033a4 <$celt.put1byte>:
842033a4:	ec 01 27 d1 	r0 = M[r5 + 492];
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE.PATCH_ID_0)     // celt_patchers
#endif  

   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
   if LE rts;
842033a8:	0d 00 0d dc 	if LE rts;
   r0 = r0 - 1;
842033ac:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
842033b0:	ec 01 27 d5 	M[r5 + 492] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
842033b4:	e8 01 27 d1 	r0 = M[r5 + 488];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
842033b8:	12 00 00 dd 	if EQ jump $M.celt.put1byte.anotherword;
     push r1; //push unshifted byte to write
842033bc:	00 00 30 f3 	push r1;
     r0 = r0 LSHIFT 3;
842033c0:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
842033c4:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
842033c8:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
842033cc:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
842033d0:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
842033d4:	ff ff 33 89 
     r0 = M[I0, 0];
842033d8:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
     r0 = r0 AND r1;
842033dc:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
842033e0:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
842033e4:	00 00 23 87 	r0 = r0 OR r1;
     M[I0, 0] = r0;
842033e8:	00 a0 00 03 	Null = Null + Null, M[I0,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
842033ec:	e8 01 27 d1 	r0 = M[r5 + 488];
     r0 = r0 - 1;
842033f0:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
842033f4:	e8 01 27 d5 	M[r5 + 488] = r0;
     pop r1;  //restore written byte
842033f8:	00 00 34 f3 	pop r1;
     rts;
842033fc:	0f 00 0d dc 	rts;

84203400 <$M.celt.put1byte.anotherword>:
   anotherword:
   r0 = M[I0, 0];
84203400:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
   r0 = r0 AND 0xFFFFFF00;
84203404:	ff ff 00 fd 	r0 = r0 AND 0xffffff00;
84203408:	00 ff 22 81 
   r0 = r0 OR r1;
8420340c:	00 00 23 87 	r0 = r0 OR r1;
   M[I0, MK1] = r0;
84203410:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
84203414:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
84203418:	e8 01 27 d5 	M[r5 + 488] = r0;
   rts;
8420341c:	0f 00 0d dc 	rts;

84203420 <$celt.put1byte_to_end>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE_TO_END.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84203420:	f4 01 27 d1 	r0 = M[r5 + 500];
   r0 = r0 - 1;
84203424:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
84203428:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
8420342c:	f4 01 27 d5 	M[r5 + 500] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84203430:	f0 01 27 d1 	r0 = M[r5 + 496];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
84203434:	11 00 00 dd 	if EQ jump $M.celt.put1byte_to_end.anotherword;
     r0 = $celt.BYTE_POS_MAX_VALUE - r0; // Max byte count counting 0,1,2,3 and subtracting previously read byte count.
84203438:	03 00 22 65 	r0 = 3 - r0;
     r0 = r0 LSHIFT 3;
8420343c:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
84203440:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
84203444:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
84203448:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
8420344c:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
84203450:	ff ff 33 89 
     r0 = M[I1, 0];
84203454:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
     r0 = r0 AND r1;
84203458:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
8420345c:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
84203460:	00 00 23 87 	r0 = r0 OR r1;
     M[I1, 0] = r0;
84203464:	00 a4 00 03 	Null = Null + Null, M[I1,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84203468:	f0 01 27 d1 	r0 = M[r5 + 496];
     r0 = r0 - 1;
8420346c:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84203470:	f0 01 27 d5 	M[r5 + 496] = r0;
     rts;
84203474:	0f 00 0d dc 	rts;

84203478 <$M.celt.put1byte_to_end.anotherword>:
   anotherword:
   r0 = M[I1, 0];
84203478:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
   r0 = r0 AND 0x00FFFFFF;
8420347c:	ff 00 00 fd 	r0 = r0 AND 0xffffff;
84203480:	ff ff 22 81 
   r1 = r1 LSHIFT 24;
84203484:	18 00 33 8d 	r1 = r1 LSHIFT 24;
   r0 = r0 OR r1;
84203488:	00 00 23 87 	r0 = r0 OR r1;
   M[I1, -MK1] = r0;
8420348c:	00 a7 00 03 	Null = Null + Null, M[I1,-4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
84203490:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84203494:	f0 01 27 d5 	M[r5 + 496] = r0;
   rts;
84203498:	0f 00 0d dc 	rts;

8420349c <$celt.ec_dec_normalise>:
8420349c:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r8;

#else // K32

   // rng=r4
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG];
842034a0:	a8 01 67 d1 	r4 = M[r5 + 424];
   // rem = rMAC
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM];
842034a4:	a4 01 17 d1 	rMAC = M[r5 + 420];
   // dif = r7
   r7 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF];
842034a8:	b0 01 97 d1 	r7 = M[r5 + 432];

842034ac <$M.celt.ec_dec_normalise.retry>:
   retry:
      // see if range is still small
      r0 = r4 - ($celt.EC_CODE_BOT+1);
842034ac:	80 00 00 fd 	r0 = r4 - 8388609;
842034b0:	01 00 26 21 
      if C jump end;
842034b4:	0d 00 20 dd 	if C jump $M.celt.ec_dec_normalise.end;
         // update range
         r4 = r4 LSHIFT 8;
842034b8:	08 00 66 8d 	r4 = r4 LSHIFT 8;
         // read next byte from input buffer
         call $celt.get1byte;
842034bc:	8c 04 f0 e1 	call $celt.get1byte;
         // use the ramining bits
         rMAC = rMAC LSHIFT $celt.EC_CODE_EXTRA;
842034c0:	07 00 e1 8d 	rMAC = rMAC LSHIFT 7 (MI);
         rMAC = rMAC AND $celt.EC_SYM_MAX;
842034c4:	ff 00 11 81 	rMAC = rMAC AND 0xff;
         r0 = r1 LSHIFT ($celt.EC_CODE_EXTRA-$celt.EC_SYM_BITS);
842034c8:	ff 00 23 8d 	r0 = r1 LSHIFT -1;
         rMAC = rMAC OR r0;
842034cc:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 LSHIFT 8;
842034d0:	08 00 99 8d 	r7 = r7 LSHIFT 8;
         r7 = r7 - rMAC;
842034d4:	00 00 91 23 	r7 = r7 - rMAC;
         r7 = r7 AND 0x7FFFFFFF;
842034d8:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
842034dc:	ff ff 99 81 
         rMAC = r1;
842034e0:	0f 00 13 00 	rMAC = r1 + Null;
   jump retry;
842034e4:	f2 ff f0 dd 	jump $M.celt.ec_dec_normalise.retry;

842034e8 <$M.celt.ec_dec_normalise.end>:
   end:
   // rng = r4
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG] = r4;
842034e8:	a8 01 67 d5 	M[r5 + 424] = r4;
   // rem = rMAC
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM] = rMAC;
842034ec:	a4 01 17 d5 	M[r5 + 420] = rMAC;
   // dif = r7
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF] = r7;
842034f0:	b0 01 97 d5 	M[r5 + 432] = r7;

#endif // K32

    // pop rLink from stack
   jump $pop_rLink_and_rts;
842034f4:	03 00 00 fd 	jump (m) 0x3b020;
842034f8:	21 b0 f0 dd 

842034fc <$celt.ec_decode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842034fc:	00 00 d0 f3 	push rLink;
   //ft = r0:r0
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84203500:	cc 01 27 d5 	M[r5 + 460] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
84203504:	d0 01 37 d5 	M[r5 + 464] = r1;
   r2 = r0;
84203508:	0f 00 42 00 	r2 = r0 + Null;
   r3 = r1;
8420350c:	0f 00 53 00 	r3 = r1 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84203510:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84203514:	ac 01 37 d1 	r1 = M[r5 + 428];
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
84203518:	20 ff f0 e1 	call $celt.idiv32;

8420351c <$celt.ec_decode.bin_jump>:
   // label for jumping from $celt.ec_decode_bin
   $celt.ec_decode.bin_jump:
   // save norm = rng/inp
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0] = r6;
8420351c:	b8 01 87 d5 	M[r5 + 440] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1] = r7;
84203520:	bc 01 97 d5 	M[r5 + 444] = r7;
   r2 = r6;
84203524:	0f 00 48 00 	r2 = r6 + Null;
   r3 = r7;
84203528:	0f 00 59 00 	r3 = r7 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
8420352c:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
84203530:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - 1;
84203534:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84203538:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
8420353c:	17 ff f0 e1 	call $celt.idiv32;
   r2 = r6 + 1;
84203540:	2f 00 48 e4 	r2 = r6 + 1;
   r3 = r7 + carry;
84203544:	0f 00 59 04 	r3 = r7 + Null + Carry;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84203548:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
8420354c:	d0 01 37 d1 	r1 = M[r5 + 464];
   r0 = r0 - r2;
84203550:	00 00 24 23 	r0 = r0 - r2;
   r1 = r1 - r3 - borrow;
84203554:	00 00 35 27 	r1 = r1 - r3 - Borrow;
   if POS jump end;
84203558:	03 00 50 dd 	if POS jump $M.celt.ec_decode.end;
     r0 = 0;
8420355c:	00 00 20 01 	r0 = Null + 0;
     r1 = 0;
84203560:	00 00 30 01 	r1 = Null + 0;

84203564 <$M.celt.ec_decode.end>:
   end:
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203564:	03 00 00 fd 	jump (m) 0x3b020;
84203568:	21 b0 f0 dd 

8420356c <$celt.ec_dec_update>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_UPDATE.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
8420356c:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84203570:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84203574:	d0 01 37 d1 	r1 = M[r5 + 464];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
84203578:	dc 01 17 d1 	rMAC = M[r5 + 476];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
8420357c:	e0 01 f7 d1 	rMACB = M[r5 + 480];
   r0 = r0 - rMAC;
84203580:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
84203584:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif  
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0];
84203588:	b8 01 47 d1 	r2 = M[r5 + 440];
   r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1];
8420358c:	bc 01 57 d1 	r3 = M[r5 + 444];

   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
84203590:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
84203594:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
84203598:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //update dif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
8420359c:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
842035a0:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - r6;
842035a4:	00 00 28 23 	r0 = r0 - r6;
   r1 = r1 - r7 -borrow;
842035a8:	00 00 39 27 	r1 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif   
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0] = r0;
842035ac:	b0 01 27 d5 	M[r5 + 432] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r1;
842035b0:	b4 01 37 d5 	M[r5 + 436] = r1;

   // update rng
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
842035b4:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
842035b8:	d8 01 37 d1 	r1 = M[r5 + 472];
   NULL = r1 OR r0;
842035bc:	2f 00 03 84 	Null = r1 OR r0;
   if NZ jump calc_rng_norm;
842035c0:	08 00 10 dd 	if NE jump $M.celt.ec_dec_update.calc_rng_norm;
      r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
842035c4:	a8 01 27 d1 	r0 = M[r5 + 424];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
842035c8:	ac 01 37 d1 	r1 = M[r5 + 428];
      r4 = r0 - r6;
842035cc:	8f 00 62 20 	r4 = r0 - r6;
      r6 = r1 - r7 - borrow;
842035d0:	9f 00 83 24 	r6 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif        
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r4;
842035d4:	a8 01 67 d5 	M[r5 + 424] = r4;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r6;
842035d8:	ac 01 87 d5 	M[r5 + 428] = r6;


      jump norm_dec;
842035dc:	0c 00 f0 dd 	jump $M.celt.ec_dec_update.norm_dec;

842035e0 <$M.celt.ec_dec_update.calc_rng_norm>:
   calc_rng_norm:
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
842035e0:	dc 01 27 d1 	r0 = M[r5 + 476];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
842035e4:	e0 01 37 d1 	r1 = M[r5 + 480];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
842035e8:	d4 01 17 d1 	rMAC = M[r5 + 468];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
842035ec:	d8 01 f7 d1 	rMACB = M[r5 + 472];
   r0 = r0 - rMAC;
842035f0:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
842035f4:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif     
   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
842035f8:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
842035fc:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
84203600:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //IMUL32
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r6;
84203604:	a8 01 87 d5 	M[r5 + 424] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r7;
84203608:	ac 01 97 d5 	M[r5 + 428] = r7;

8420360c <$M.celt.ec_dec_update.norm_dec>:
   norm_dec:
   // normalise
   call $celt.ec_dec_normalise;
8420360c:	a4 ff f0 e1 	call $celt.ec_dec_normalise;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203610:	03 00 00 fd 	jump (m) 0x3b020;
84203614:	21 b0 f0 dd 

84203618 <$celt.ec_dec_bits>:
   
   // push rLink onto stack
   // r2=ftb
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84203618:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
8420361c:	08 00 03 f1 	SP = SP + 8;
   M[FP + TEMP_T + 0] = Null;
84203620:	08 00 0c f1 	M[FP + 0x8] = Null;
   M[FP + TEMP_T + MK1] =  Null;
84203624:	0c 00 0c f1 	M[FP + 0xc] = Null;
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84203628:	e4 01 47 d1 	r2 = M[r5 + 484];

8420362c <$M.celt.ec_dec_bits.loop_check_ftp>:
   loop_check_ftp:
      Null = r2 - $celt.EC_UNIT_BITS;
8420362c:	08 00 04 21 	Null = r2 - 8;
      if NEG jump end_check_ftp;
84203630:	11 00 40 dd 	if NEG jump $M.celt.ec_dec_bits.end_check_ftp;
      r8 = $celt.EC_UNIT_BITS;
84203634:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_decode_raw;
84203638:	1e 00 f0 e1 	call $celt.ec_decode_raw;
      r2 = M[FP + TEMP_T + 0];
8420363c:	08 00 48 f1 	r2 = M[FP + 0x8];
      r3 = M[FP + TEMP_T + MK1];
84203640:	0c 00 58 f1 	r3 = M[FP + 0xc];
      r3 = r3 LSHIFT  $celt.EC_UNIT_BITS;
84203644:	08 00 55 8d 	r3 = r3 LSHIFT 8;
      r4 = r2  LSHIFT ($celt.EC_UNIT_BITS-24);
84203648:	f0 00 64 8d 	r4 = r2 LSHIFT -16;
      r3 = r3 + r4;
8420364c:	00 00 56 03 	r3 = r3 + r4;
      r2 = r2 LSHIFT  $celt.EC_UNIT_BITS;
84203650:	08 00 44 8d 	r2 = r2 LSHIFT 8;
      r2 = r2 OR r0;
84203654:	00 00 42 87 	r2 = r2 OR r0;
      r3 = r3 OR r1;
84203658:	00 00 53 87 	r3 = r3 OR r1;
      M[FP + TEMP_T + 0] = r2;
8420365c:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP_T + MK1] = r3;
84203660:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84203664:	e4 01 47 d1 	r2 = M[r5 + 484];
      r2 = r2 - $celt.EC_UNIT_BITS;
84203668:	08 00 44 21 	r2 = r2 - 8;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
8420366c:	e4 01 47 d5 	M[r5 + 484] = r2;
  jump  loop_check_ftp;
84203670:	ef ff f0 dd 	jump $M.celt.ec_dec_bits.loop_check_ftp;

84203674 <$M.celt.ec_dec_bits.end_check_ftp>:
  end_check_ftp:
  r8 = r2;
84203674:	0f 00 a4 00 	r8 = r2 + Null;
  call $celt.ec_decode_raw;
84203678:	0e 00 f0 e1 	call $celt.ec_decode_raw;
  r2 = M[FP + TEMP_T + 0];
8420367c:	08 00 48 f1 	r2 = M[FP + 0x8];
  r3 = M[FP + TEMP_T + MK1];
84203680:	0c 00 58 f1 	r3 = M[FP + 0xc];
  r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84203684:	e4 01 67 d1 	r4 = M[r5 + 484];
  r3 = r3 LSHIFT  r4;
84203688:	00 00 56 8f 	r3 = r3 LSHIFT r4;
  r6 = r4 - 24;
8420368c:	18 00 86 21 	r6 = r4 - 24;
  r6 = r2  LSHIFT r6;
84203690:	8f 00 84 8c 	r6 = r2 LSHIFT r6;
  r3 = r3 + r6;
84203694:	00 00 58 03 	r3 = r3 + r6;
  r2 = r2 LSHIFT  r4;
84203698:	00 00 46 8f 	r2 = r2 LSHIFT r4;
  r0 = r2 OR r0;
8420369c:	2f 00 24 84 	r0 = r2 OR r0;
  r1 = r3 OR r1;
842036a0:	3f 00 35 84 	r1 = r3 OR r1;
  // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
842036a4:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
842036a8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842036ac:	0f 00 0d dc 	rts;

842036b0 <$celt.ec_decode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842036b0:	00 00 d0 f3 	push rLink;
   //rMAC: value
   //r7: count
   //r2: bits(input)
   //r4:end_bits_left
   //r6:end_byte
   rMAC = 0;
842036b4:	00 00 10 01 	rMAC = Null + 0;
   r7 = 0;
842036b8:	00 00 90 01 	r7 = Null + 0;
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT];
842036bc:	c4 01 67 d1 	r4 = M[r5 + 452];
   r6 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE];
842036c0:	c0 01 87 d1 	r6 = M[r5 + 448];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS];
842036c4:	c8 01 27 d1 	r0 = M[r5 + 456];
   r0 = r8 + r0;
842036c8:	2f 00 2a 00 	r0 = r8 + r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS] = r0;
842036cc:	c8 01 27 d5 	M[r5 + 456] = r0;

842036d0 <$M.celt.ec_decode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
842036d0:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
842036d4:	0b 00 40 dd 	if NEG jump $M.celt.ec_decode_raw.end_bits_loop;
         r0 = r4 - 8;
842036d8:	08 00 26 21 	r0 = r4 - 8;
         r0 = r6 LSHIFT r0;
842036dc:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
         r0 = r0 LSHIFT r7;
842036e0:	00 00 29 8f 	r0 = r0 LSHIFT r7;
         rMAC = rMAC OR r0;
842036e4:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 + r4;
842036e8:	00 00 96 03 	r7 = r7 + r4;
         r8 = r8 - r4;
842036ec:	00 00 a6 23 	r8 = r8 - r4;
         call $celt.get1byte_from_end;
842036f0:	0f 04 f0 e1 	call $celt.get1byte_from_end;
         r6 = r1;
842036f4:	0f 00 83 00 	r6 = r1 + Null;
         r4 = 8;
842036f8:	08 00 60 01 	r4 = Null + 8;
   jump loop_until_bits_left;
842036fc:	f5 ff f0 dd 	jump $M.celt.ec_decode_raw.loop_until_bits_left;

84203700 <$M.celt.ec_decode_raw.end_bits_loop>:
   end_bits_loop:
   r2 = 1 LSHIFT r8;
84203700:	01 00 4a e9 	r2 = 0x1 LSHIFT r8;
   r2 = r2 - 1;
84203704:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r4 - 8;
84203708:	08 00 26 21 	r0 = r4 - 8;
   r0 = r6 LSHIFT r0;
8420370c:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
   r0 = r0 AND r2;
84203710:	00 00 24 83 	r0 = r0 AND r2;
   r0 = r0 LSHIFT r7;
84203714:	00 00 29 8f 	r0 = r0 LSHIFT r7;
   r0 = rMAC OR r0;
84203718:	2f 00 21 84 	r0 = rMAC OR r0;
   r4 = r4 - r8;
8420371c:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT] = r4;
84203720:	c4 01 67 d5 	M[r5 + 452] = r4;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE] = r6;
84203724:	c0 01 87 d5 	M[r5 + 448] = r6;
   r1 = 0;
84203728:	00 00 30 01 	r1 = Null + 0;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420372c:	03 00 00 fd 	jump (m) 0x3b020;
84203730:	21 b0 f0 dd 

84203734 <$celt.ec_dec_uint>:
#endif

   .CONST TEMP_FTB             (0 + 2)*ADDR_PER_WORD;
   .CONST TEMP_FT              (1 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84203734:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203738:	0c 00 03 f1 	SP = SP + 12;

   r2 = r0 - 2;
8420373c:	cf 00 42 e4 	r2 = r0 - 2;
   r2 = r1 - borrow;
84203740:	0f 00 43 24 	r2 = r1 - Null - Borrow;
   if NEG call $error;
84203744:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84203748:	3f ac 40 e1 
   r0 = r0 - 1;
8420374c:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84203750:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif      
   M[FP + TEMP_FT + 0] = r0;
84203754:	0c 00 2c f1 	M[FP + 0xc] = r0;
   M[FP + TEMP_FT + MK1] = r1;
84203758:	10 00 3c f1 	M[FP + 0x10] = r1;
   // this is a macro
   $celt.EC_ILOG32(r0, r1, r2)
8420375c:	0f 00 13 00 	rMAC = r1 + Null;
84203760:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84203764:	0f 00 41 d8 	r2 = SIGNDET rMAC;
84203768:	3f 00 44 65 	r2 = 63 - r2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
8420376c:	e4 01 47 d5 	M[r5 + 484] = r2;
   Null = r2 - $celt.EC_UNIT_BITS;
84203770:	08 00 04 21 	Null = r2 - 8;
   if LE jump inc_ft;
84203774:	2b 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.inc_ft;
      r2 = $celt.EC_UNIT_BITS - r2;
84203778:	08 00 44 65 	r2 = 8 - r2;
      r3 = -r2;
8420377c:	4f 00 50 20 	r3 = Null - r2;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r3;
84203780:	e4 01 57 d5 	M[r5 + 484] = r3;
      M[FP + TEMP_FTB] = r3;
84203784:	08 00 5c f1 	M[FP + 0x8] = r3;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84203788:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
8420378c:	d0 01 37 d5 	M[r5 + 464] = r1;
      // TODO:BC7OPT
      r3 = r2 + 24;
84203790:	18 00 54 01 	r3 = r2 + 24;
      r3 = r1 LSHIFT r3;
84203794:	5f 00 53 8c 	r3 = r1 LSHIFT r3;
      r0 = r0 LSHIFT r2;
84203798:	00 00 24 8f 	r0 = r0 LSHIFT r2;
      r0 = r0 OR r3;
8420379c:	00 00 25 87 	r0 = r0 OR r3;
      r1 = r1 LSHIFT r2;
842037a0:	00 00 34 8f 	r1 = r1 LSHIFT r2;
      r0 = r0 + 1;
842037a4:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
842037a8:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif  
      call $celt.ec_decode;
842037ac:	54 ff f0 e1 	call $celt.ec_decode;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
842037b0:	d4 01 27 d5 	M[r5 + 468] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
842037b4:	d8 01 37 d5 	M[r5 + 472] = r1;
      r0 = r0 + 1;
842037b8:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
842037bc:	00 00 30 07 	r1 = r1 + Null + Carry;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
842037c0:	e0 01 37 d5 	M[r5 + 480] = r1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
842037c4:	dc 01 27 d5 	M[r5 + 476] = r0;

      call $celt.ec_dec_update;
842037c8:	69 ff f0 e1 	call $celt.ec_dec_update;

      call $celt.ec_dec_bits;
842037cc:	93 ff f0 e1 	call $celt.ec_dec_bits;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
842037d0:	d4 01 47 d1 	r2 = M[r5 + 468];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
842037d4:	d8 01 57 d1 	r3 = M[r5 + 472];
      r4 = M[FP + TEMP_FTB];
842037d8:	08 00 68 f1 	r4 = M[FP + 0x8];

      // TODO:BC7OPT
      r3 = r3 LSHIFT r4;
842037dc:	00 00 56 8f 	r3 = r3 LSHIFT r4;
      r7 = r4 - 24;
842037e0:	18 00 96 21 	r7 = r4 - 24;
      r7 = r2 LSHIFT r7;
842037e4:	9f 00 94 8c 	r7 = r2 LSHIFT r7;
      r3 = r3 OR r7;
842037e8:	00 00 59 87 	r3 = r3 OR r7;
      r2 = r2 LSHIFT r4;
842037ec:	00 00 46 8f 	r2 = r2 LSHIFT r4;
      r0 = r0 OR r2;
842037f0:	00 00 24 87 	r0 = r0 OR r2;
#ifdef K32
      r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
842037f4:	00 00 30 01 	r1 = Null + 0;
#else
      r1 = r1 OR r3;
#endif
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
842037f8:	cc 01 47 d1 	r2 = M[r5 + 460];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
842037fc:	d0 01 57 d1 	r3 = M[r5 + 464];
      r4 = M[FP + TEMP_FT + 0];
84203800:	0c 00 68 f1 	r4 = M[FP + 0xc];
      r10 = M[FP + TEMP_FT + MK1];
84203804:	10 00 c8 f1 	r10 = M[FP + 0x10];
      NULL = r0 - r4;
84203808:	6f 00 02 20 	Null = r0 - r4;
      NULL = r1 - r10 - borrow;
8420380c:	cf 00 03 24 	Null = r1 - r10 - Borrow;
      if LE jump end;
84203810:	13 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.end;
         r0 = r2;
84203814:	0f 00 24 00 	r0 = r2 + Null;
#ifdef K32
         r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
84203818:	00 00 30 01 	r1 = Null + 0;
#else
         r1 = r3;
#endif
      jump end;
8420381c:	10 00 f0 dd 	jump $M.celt.ec_dec_uint.end;

84203820 <$M.celt.ec_dec_uint.inc_ft>:
   inc_ft:
   r0 = r0 + 1;
84203820:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
84203824:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif     
#ifdef K32
   $celt.NATIVE_WORD32_CONVERT(r1,r0)
84203828:	18 00 33 8d 	r1 = r1 LSHIFT 24;
8420382c:	00 00 23 87 	r0 = r0 OR r1;
84203830:	00 00 30 01 	r1 = Null + 0;
#endif
   call $celt.ec_decode;
84203834:	32 ff f0 e1 	call $celt.ec_decode;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
84203838:	d4 01 27 d5 	M[r5 + 468] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
8420383c:	d8 01 37 d5 	M[r5 + 472] = r1;
   r0 = r0 + 1;
84203840:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
84203844:	00 00 30 07 	r1 = r1 + Null + Carry;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
84203848:	e0 01 37 d5 	M[r5 + 480] = r1;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
8420384c:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_dec_update;
84203850:	47 ff f0 e1 	call $celt.ec_dec_update;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84203854:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84203858:	d8 01 37 d1 	r1 = M[r5 + 472];

8420385c <$M.celt.ec_dec_uint.end>:

   end:
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
8420385c:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84203860:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203864:	0f 00 0d dc 	rts;

84203868 <$celt.decode_pulses32>:
84203868:	01 20 00 f1 	pushm <FP(=SP), rLink>;
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
8420386c:	10 00 03 f1 	SP = SP + 16;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif     
   // save nr of pulses and bins
   M[FP + TEMP + 0] = r4;
84203870:	08 00 6c f1 	M[FP + 0x8] = r4;
   M[FP + TEMP + MK1] = r3;
84203874:	0c 00 5c f1 	M[FP + 0xc] = r3;

#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
84203878:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
8420387c:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif
   if POS jump default;
84203880:	5c 00 50 dd 	if POS jump $M.celt.decode_pulses32.default;
   Null = r3 - 1;
84203884:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
84203888:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
8420388c:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
84203890:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
84203894:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
84203898:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif   
   jump r0;
8420389c:	0f 00 02 dc 	jump r0;

842038a0 <$M.celt.decode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = 1;
842038a0:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r0;
842038a4:	e4 01 27 d5 	M[r5 + 484] = r0;
      call $celt.ec_dec_bits;
842038a8:	5c ff f0 e1 	call $celt.ec_dec_bits;
      r4 = M[FP + TEMP + 0];
842038ac:	08 00 68 f1 	r4 = M[FP + 0x8];
      $celt.cwrsi1(r2, r0, r1)
842038b0:	2f 00 30 20 	r1 = Null - r0;
842038b4:	3f 00 14 00 	rMAC = r2 + r1;
842038b8:	00 00 31 8b 	r1 = r1 XOR rMAC;
      M[I7, 0] = r1;
842038bc:	bc 00 00 03 	Null = Null + Null, M[I7,0] = r1;
   jump end;
842038c0:	62 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842038c4 <$M.celt.decode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      $celt.ncwrs2(r4, r0)
842038c4:	2f 00 20 e4 	r0 = Null + 1;
842038c8:	0f 00 06 00 	Null = r4 + Null;
842038cc:	61 00 26 00 	if NE r0 = r4 + r4;
842038d0:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
842038d4:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
842038d8:	97 ff f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842038dc:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842038e0:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842038e4:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi2;
842038e8:	9b 00 f0 e1 	call $celt.cwrsi2;
   jump end;
842038ec:	57 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842038f0 <$M.celt.decode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      $celt.ncwrs3(r4, r0, r1, decode_pulses32_n_3_lb1)
842038f0:	2f 00 20 e4 	r0 = Null + 1;
842038f4:	00 00 30 01 	r1 = Null + 0;
842038f8:	0f 00 16 00 	rMAC = r4 + Null;
842038fc:	07 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_3_lb1;
84203900:	00 00 11 03 	rMAC = rMAC + rMAC;
84203904:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
84203908:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
8420390c:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203910:	af 00 22 e4 	r0 = r0 + 2;
84203914:	00 00 30 07 	r1 = r1 + Null + Carry;

84203918 <$M.celt.decode_pulses32.decode_pulses32_n_3_lb1>:
      call $celt.ec_dec_uint;
84203918:	87 ff f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
8420391c:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
84203920:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84203924:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi3;
84203928:	a1 00 f0 e1 	call $celt.cwrsi3;
   jump end;
8420392c:	47 00 f0 dd 	jump $M.celt.decode_pulses32.end;

84203930 <$M.celt.decode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      $celt.ncwrs4(r4, r0, r1, r2, decode_pulses32_n_4_lb1)
84203930:	2f 00 20 e4 	r0 = Null + 1;
84203934:	00 00 30 01 	r1 = Null + 0;
84203938:	aa 2a 00 fd 	r2 = Null + 715827883;
8420393c:	ab aa 40 01 
84203940:	04 00 16 99 	rMAC = r4 * 4 (int);
84203944:	0c 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_4_lb1;
84203948:	6f 00 26 98 	r0 = r4 * r4 (int);
8420394c:	af 00 22 e4 	r0 = r0 + 2;
84203950:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203954:	03 00 33 99 	r1 = r1 * 3 (int);
84203958:	1f 00 03 20 	Null = r1 - rMAC;
8420395c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203960:	1f 00 03 20 	Null = r1 - rMAC;
84203964:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203968:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
8420396c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203970:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

84203974 <$M.celt.decode_pulses32.decode_pulses32_n_4_lb1>:
      call $celt.ec_dec_uint;
84203974:	70 ff f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
84203978:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
8420397c:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84203980:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi4;
84203984:	d8 00 f0 e1 	call $celt.cwrsi4;
   jump end;
84203988:	30 00 f0 dd 	jump $M.celt.decode_pulses32.end;

8420398c <$M.celt.decode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
8420398c:	2f 00 20 e4 	r0 = Null + 1;
84203990:	00 00 30 01 	r1 = Null + 0;
84203994:	aa 2a 00 fd 	r2 = Null + 715827883;
84203998:	ab aa 40 01 
8420399c:	6f 00 16 98 	rMAC = r4 * r4 (int);
842039a0:	0e 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_5_lb1;
842039a4:	05 00 21 01 	r0 = rMAC + 5;
842039a8:	00 00 11 03 	rMAC = rMAC + rMAC;
842039ac:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842039b0:	03 00 33 99 	r1 = r1 * 3 (int);
842039b4:	1f 00 03 20 	Null = r1 - rMAC;
842039b8:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842039bc:	1f 00 03 20 	Null = r1 - rMAC;
842039c0:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842039c4:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842039c8:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842039cc:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842039d0:	af 00 22 e4 	r0 = r0 + 2;
842039d4:	00 00 30 07 	r1 = r1 + Null + Carry;

842039d8 <$M.celt.decode_pulses32.decode_pulses32_n_5_lb1>:
      call $celt.ec_dec_uint;
842039d8:	57 ff f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842039dc:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842039e0:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842039e4:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi5;
842039e8:	0f 01 f0 e1 	call $celt.cwrsi5;
   jump end;
842039ec:	17 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842039f0 <$M.celt.decode_pulses32.default>:

   // -- process n > 5
   default:
      M[FP + TEMP + MK2] = r5;
842039f0:	10 00 7c f1 	M[FP + 0x10] = r5;
      push I7;
842039f4:	00 00 71 f3 	push I7;
      r0 = M[r5 + $celt.dec.UVECTOR_FIELD];
842039f8:	c8 00 27 d1 	r0 = M[r5 + 200];
      I7 = r0;//&$celt.dec.uvector;
842039fc:	2f 00 70 50 	I7 = Null + r0;
      M[FP + TEMP + 3*MK1] = r0;
84203a00:	14 00 2c f1 	M[FP + 0x14] = r0;
      push r5;
84203a04:	00 00 70 f3 	push r5;
      call $celt.ncwrs_urow;
84203a08:	91 01 f0 e1 	call $celt.ncwrs_urow;
      pop r5;
84203a0c:	00 00 74 f3 	pop r5;
      call $celt.ec_dec_uint;
84203a10:	49 ff f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 3*MK1];
84203a14:	14 00 68 f1 	r4 = M[FP + 0x14];
      I5 = r4;
84203a18:	6f 00 50 50 	I5 = Null + r4;
      #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
         I7 = M[SP - MK1];
84203a1c:	fc ff 79 f1 	I7 = M[SP + -0x4];
      #else
         I7 = plook 0;
      #endif
      r4 = M[FP + TEMP + 0];
84203a20:	08 00 68 f1 	r4 = M[FP + 0x8];
      r3 = M[FP + TEMP + MK1];
84203a24:	0c 00 58 f1 	r3 = M[FP + 0xc];
      M3 = r3;
84203a28:	5f 00 b0 50 	M3 = Null + r3;
      r6 = r0;
84203a2c:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84203a30:	0f 00 93 00 	r7 = r1 + Null;
      push r5;
84203a34:	00 00 70 f3 	push r5;
      call $celt.cwrsi;
84203a38:	61 01 f0 e1 	call $celt.cwrsi;
      pop r5;
84203a3c:	00 00 74 f3 	pop r5;
      r5 = M[FP + TEMP + MK2];
84203a40:	10 00 78 f1 	r5 = M[FP + 0x10];
      pop I7;
84203a44:	00 00 75 f3 	pop I7;

84203a48 <$M.celt.decode_pulses32.end>:
   end:
   r4 = M[FP + TEMP + 0];
84203a48:	08 00 68 f1 	r4 = M[FP + 0x8];
   r3 = M[FP + TEMP + MK1];
84203a4c:	0c 00 58 f1 	r3 = M[FP + 0xc];
   SP = SP - STACK_FRAME_SIZE;
84203a50:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
84203a54:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203a58:	0f 00 0d dc 	rts;

84203a5c <$celt.encode_pulses>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_PULSES.PATCH_ID_0)     // celt_patchers
#endif
   
   // zero output for zero pulses
   Null = r4;
84203a5c:	0f 00 06 00 	Null = r4 + Null;
   if Z rts;
84203a60:	00 00 0d dc 	if EQ rts;
   push rlink;
84203a64:	00 00 d0 f3 	push rLink;
   // NOTE: no state should be below this point
   // does it fit into a 32-bit unsigned number?
   $celt.fits_in32(r3, r4, r0, encode_pulses_lb1, encode_pulses_lb2)
84203a68:	0e 00 05 21 	Null = r3 - 14;
84203a6c:	0b 00 40 dd 	if NEG jump $M.celt.encode_pulses.encode_pulses_lb1;
84203a70:	0f 00 20 00 	r0 = Null + Null;
84203a74:	0e 00 06 21 	Null = r4 - 14;
84203a78:	0e 00 50 dd 	if POS jump $M.celt.encode_pulses.encode_pulses_lb2;
84203a7c:	18 02 27 d1 	r0 = M[r5 + 536];
84203a80:	02 00 66 91 	r4 = r4 ASHIFT 2;
84203a84:	00 00 26 d3 	r0 = M[r0 + r4];
84203a88:	fe 00 66 91 	r4 = r4 ASHIFT -2;
84203a8c:	5f 00 02 20 	Null = r0 - r3;
84203a90:	04 00 20 00 	if NEG r0 = Null + Null;
84203a94:	07 00 f0 dd 	jump $M.celt.encode_pulses.encode_pulses_lb2;

84203a98 <$M.celt.encode_pulses.encode_pulses_lb1>:
84203a98:	1c 02 27 d1 	r0 = M[r5 + 540];
84203a9c:	02 00 55 91 	r3 = r3 ASHIFT 2;
84203aa0:	00 00 25 d3 	r0 = M[r0 + r3];
84203aa4:	fe 00 55 91 	r3 = r3 ASHIFT -2;
84203aa8:	6f 00 02 20 	Null = r0 - r4;
84203aac:	04 00 20 00 	if NEG r0 = Null + Null;

84203ab0 <$M.celt.encode_pulses.encode_pulses_lb2>:
84203ab0:	0f 00 02 00 	Null = r0 + Null;
   if Z jump split_it;
84203ab4:	04 00 00 dd 	if EQ jump $M.celt.encode_pulses.split_it;

   // yes, it does
   call $celt.encode_pulses32;
84203ab8:	aa 02 f0 e1 	call $celt.encode_pulses32;
   jump $pop_rLink_and_rts;
84203abc:	03 00 00 fd 	jump (m) 0x3b020;
84203ac0:	21 b0 f0 dd 

84203ac4 <$M.celt.encode_pulses.split_it>:

   // No, it doesnt,
   split_it:

      push I7;
84203ac4:	00 00 71 f3 	push I7;
      push r3;
84203ac8:	00 00 50 f3 	push r3;
      push r4;
84203acc:	00 00 60 f3 	push r4;
      I6 = I7;
84203ad0:	0f 00 67 58 	I6 = I7 + Null;
      r3 = r3 + 1;
84203ad4:	2f 00 55 e4 	r3 = r3 + 1;
      r3 = r3 LSHIFT -1;
84203ad8:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
      r10 = r3;
84203adc:	0f 00 c5 00 	r10 = r3 + Null;
      r1 = 0, r0 = M[I6, MK1];
84203ae0:	29 00 33 23 	r1 = r1 - r1, r0 = M[I6,4];
      do calc_count_loop;
84203ae4:	04 00 f0 e5 	do $M.celt.encode_pulses.calc_count_loop;
         Null = r0;
84203ae8:	0f 00 02 00 	Null = r0 + Null;
         if NEG r0 = -r0;
84203aec:	24 00 20 20 	if NEG r0 = Null - r0;
         r1 = r1 + r0, r0 = M[I6, MK1];
84203af0:	29 00 32 03 	r1 = r1 + r0, r0 = M[I6,4];

84203af4 <$M.celt.encode_pulses.calc_count_loop>:
      calc_count_loop:
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = Null;
84203af4:	d8 01 07 d5 	M[r5 + 472] = Null;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
84203af8:	d4 01 37 d5 	M[r5 + 468] = r1;
      r4 = r4 + 1;
84203afc:	2f 00 66 e4 	r4 = r4 + 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r4;
84203b00:	cc 01 67 d5 	M[r5 + 460] = r4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + MK1] = Null;
84203b04:	d0 01 07 d5 	M[r5 + 464] = Null;
      push r1;
84203b08:	00 00 30 f3 	push r1;
      push r3;
84203b0c:	00 00 50 f3 	push r3;
      call $celt.ec_enc_uint;
84203b10:	fc f5 f0 e1 	call $celt.ec_enc_uint;
      pop r3;
84203b14:	00 00 54 f3 	pop r3;
      pop r4;
84203b18:	00 00 64 f3 	pop r4;
      call $celt.encode_pulses;
84203b1c:	d0 ff f0 e1 	call $celt.encode_pulses;

    #if !defined(KAL_ARCH3) && !defined(KAL_ARCH4) && !defined(KAL_ARCH5)
      r0 = plook 0;
      r1 = plook 1;
    #else
      r0 = M[SP - MK1];
84203b20:	fc ff 28 f1 	r0 = M[SP + -0x4];
      r1 = M[SP - MK2];
84203b24:	f8 ff 38 f1 	r1 = M[SP + -0x8];
    #endif

      Words2Addr(r3);
84203b28:	02 00 55 91 	r3 = r3 ASHIFT 2;
      I7 = I7 + r3;
84203b2c:	00 00 75 5b 	I7 = I7 + r3;
      Addr2Words(r3);
84203b30:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r4 = r0 - r4;
84203b34:	6f 00 62 20 	r4 = r0 - r4;
      r3 = r1 - r3;
84203b38:	5f 00 53 20 	r3 = r1 - r3;
      call $celt.encode_pulses;
84203b3c:	c8 ff f0 e1 	call $celt.encode_pulses;
      pop r4;
84203b40:	00 00 64 f3 	pop r4;
      pop r3;
84203b44:	00 00 54 f3 	pop r3;
      pop I7;
84203b48:	00 00 75 f3 	pop I7;
   jump $pop_rLink_and_rts;
84203b4c:	03 00 00 fd 	jump (m) 0x3b020;
84203b50:	21 b0 f0 dd 

84203b54 <$celt.cwrsi2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.CWRSI2.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = r4 + 1;
84203b54:	2f 00 26 e4 	r0 = r4 + 1;
   $celt.ucwrs2(r0, r3)
84203b58:	2f 00 52 00 	r3 = r0 + r0;
84203b5c:	3f 00 55 e4 	r3 = r3 - 1;
84203b60:	04 00 50 00 	if NEG r3 = Null + Null;
   Null = r6 - r3;
84203b64:	5f 00 08 20 	Null = r6 - r3;
   Null = r7 - Borrow;
84203b68:	0f 00 09 24 	Null = r7 - Null - Borrow;
   if NEG r3 = 0;
84203b6c:	04 00 50 00 	if NEG r3 = Null + Null;
   r6 = r6 - r3;
84203b70:	00 00 85 23 	r6 = r6 - r3;
   r2 = r6 + 1;
84203b74:	2f 00 48 e4 	r2 = r6 + 1;
   r2 = r2 LSHIFT -1;
84203b78:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
   $celt.ucwrs2(r2, r1)
84203b7c:	4f 00 34 00 	r1 = r2 + r2;
84203b80:	3f 00 33 e4 	r1 = r1 - 1;
84203b84:	04 00 30 00 	if NEG r1 = Null + Null;
   r0 = r4 - r2;
84203b88:	4f 00 26 20 	r0 = r4 - r2;
   Null = r3;
84203b8c:	0f 00 05 00 	Null = r3 + Null;
   if NZ r0 = -r0;
84203b90:	21 00 20 20 	if NE r0 = Null - r0;
   r6 = r6 - r1, M[I7, MK1] = r0;
84203b94:	ad 00 83 23 	r6 = r6 - r1, M[I7,4] = r0;
   $celt.cwrsi1(r2, r6, r3)
84203b98:	8f 00 50 20 	r3 = Null - r6;
84203b9c:	5f 00 14 00 	rMAC = r2 + r3;
84203ba0:	00 00 51 8b 	r3 = r3 XOR rMAC;
   M[I7, -MK1] = r3;
84203ba4:	df 00 00 03 	Null = Null + Null, M[I7,-4] = r3;
   rts;
84203ba8:	0f 00 0d dc 	rts;

84203bac <$celt.cwrsi3>:
#endif
  
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84203bac:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203bb0:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84203bb4:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs3(r3, r0, r1,  cwrsi3_lbl1)
84203bb8:	00 00 20 01 	r0 = Null + 0;
84203bbc:	00 00 30 01 	r1 = Null + 0;
84203bc0:	3f 00 15 e4 	rMAC = r3 - 1;
84203bc4:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl1;
84203bc8:	1f 00 15 cc 	rMAC = r3 * rMAC (SS);
84203bcc:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203bd0:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203bd4:	2f 00 22 e4 	r0 = r0 + 1;
84203bd8:	00 00 30 07 	r1 = r1 + Null + Carry;

84203bdc <$M.celt.cwrsi3.cwrsi3_lbl1>:
   M[FP + TMP + 0]  = r0;
84203bdc:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84203be0:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84203be4:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
84203be8:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84203bec:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84203bf0:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84203bf4:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng1_end;
      M0 = 1;
84203bf8:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84203bfc:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84203c00:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84203c04 <$M.celt.cwrsi3.chng1_end>:
   chng1_end:
   r2 = 0;
84203c04:	00 00 40 01 	r2 = Null + 0;
   Null = r6 - 1;
84203c08:	3f 00 08 e4 	Null = r6 - 1;
   Null = r7 - r1 - borrow;
84203c0c:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng2_end;
84203c10:	1f 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng2_end;
      r0 = r6 + r6;
84203c14:	8f 00 28 00 	r0 = r6 + r6;
      r1 = r7 + r7 + Carry;
84203c18:	9f 00 39 04 	r1 = r7 + r7 + Carry;
      r0 = r0 - 1;
84203c1c:	3f 00 22 e4 	r0 = r0 - 1;
      r1 = r1 - Borrow;
84203c20:	00 00 30 27 	r1 = r1 - Null - Borrow;
      M1 = r7;
84203c24:	9f 00 90 50 	M1 = Null + r7;
      $celt.ISQRT32(cwrsi3_lbl2, cwrsi3_lbl3)
84203c28:	0f 00 13 00 	rMAC = r1 + Null;
84203c2c:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84203c30:	0f 00 51 d8 	r3 = SIGNDET rMAC;
84203c34:	3e 00 55 65 	r3 = 62 - r3;
84203c38:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
84203c3c:	00 00 40 01 	r2 = Null + 0;
84203c40:	2f 00 c5 e4 	r10 = r3 + 1;
84203c44:	01 00 55 e9 	r3 = 0x1 LSHIFT r3;
84203c48:	0e 00 f0 e5 	do $M.celt.cwrsi3.cwrsi3_lbl2;
84203c4c:	4f 00 64 00 	r4 = r2 + r2;
84203c50:	00 00 65 03 	r4 = r4 + r3;
84203c54:	19 00 ac 21 	r8 = r10 - 25;
84203c58:	af 00 96 8c 	r7 = r4 LSHIFT r8;
84203c5c:	3f 00 ac e4 	r8 = r10 - 1;
84203c60:	00 00 6a 8f 	r4 = r4 LSHIFT r8;
84203c64:	6f 00 02 20 	Null = r0 - r4;
84203c68:	9f 00 03 24 	Null = r1 - r7 - Borrow;
84203c6c:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl3;
84203c70:	00 00 45 03 	r2 = r2 + r3;
84203c74:	00 00 26 23 	r0 = r0 - r4;
84203c78:	00 00 39 27 	r1 = r1 - r7 - Borrow;

84203c7c <$M.celt.cwrsi3.cwrsi3_lbl3>:
84203c7c:	ff 00 55 8d 	r3 = r3 LSHIFT -1;

84203c80 <$M.celt.cwrsi3.cwrsi3_lbl2>:
      r2 = r2 + 1;
84203c80:	2f 00 44 e4 	r2 = r2 + 1;
      r2 = r2 LSHIFT -1;
84203c84:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
      r7 = M1;
84203c88:	9f 00 90 44 	r7 = Null + M1;

84203c8c <$M.celt.cwrsi3.chng2_end>:
   chng2_end:
   $celt.ucwrs3(r2, r0, r1,  cwrsi3_lbl4)
84203c8c:	00 00 20 01 	r0 = Null + 0;
84203c90:	00 00 30 01 	r1 = Null + 0;
84203c94:	3f 00 14 e4 	rMAC = r2 - 1;
84203c98:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl4;
84203c9c:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
84203ca0:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203ca4:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203ca8:	2f 00 22 e4 	r0 = r0 + 1;
84203cac:	00 00 30 07 	r1 = r1 + Null + Carry;

84203cb0 <$M.celt.cwrsi3.cwrsi3_lbl4>:
   r6 = r6 - r0;
84203cb0:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84203cb4:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84203cb8:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r2 - r0;
84203cbc:	2f 00 24 20 	r0 = r2 - r0;
   Null = M0;
84203cc0:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84203cc4:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84203cc8:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   r4 = r2;
84203ccc:	0f 00 64 00 	r4 = r2 + Null;
   call $celt.cwrsi2;
84203cd0:	a1 ff f0 e1 	call $celt.cwrsi2;
   r0 = M[I7, -MK1];
84203cd4:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84203cd8:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84203cdc:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203ce0:	0f 00 0d dc 	rts;

84203ce4 <$celt.cwrsi4>:
#endif
   
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84203ce4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203ce8:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84203cec:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs4(r3, r0, r1, r2, cwrsi4_lbl1)
84203cf0:	00 00 30 01 	r1 = Null + 0;
84203cf4:	0f 00 25 00 	r0 = r3 + Null;
84203cf8:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl1;
84203cfc:	aa 2a 00 fd 	r2 = Null + 715827883;
84203d00:	ab aa 40 01 
84203d04:	5f 00 15 00 	rMAC = r3 + r3;
84203d08:	03 00 11 21 	rMAC = rMAC - 3;
84203d0c:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84203d10:	bf 00 11 e4 	rMAC = rMAC + 4;
84203d14:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203d18:	03 00 33 99 	r1 = r1 * 3 (int);
84203d1c:	1f 00 03 20 	Null = r1 - rMAC;
84203d20:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203d24:	1f 00 03 20 	Null = r1 - rMAC;
84203d28:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203d2c:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84203d30:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203d34:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203d38:	3f 00 22 e4 	r0 = r0 - 1;
84203d3c:	00 00 30 27 	r1 = r1 - Null - Borrow;

84203d40 <$M.celt.cwrsi4.cwrsi4_lbl1>:
   M[FP + TMP + 0]  = r0;
84203d40:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84203d44:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84203d48:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
84203d4c:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84203d50:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84203d54:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84203d58:	04 00 40 dd 	if NEG jump $M.celt.cwrsi4.chng1_end;
      M0 = 1;
84203d5c:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84203d60:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84203d64:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84203d68 <$M.celt.cwrsi4.chng1_end>:
   chng1_end:
   r10 = 0;
84203d68:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84203d6c:	0f 00 a6 00 	r8 = r4 + Null;

84203d70 <$M.celt.cwrsi4.cwrsi4_loop1>:
   cwrsi4_loop1:
      r4 = r10 + r8;
84203d70:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84203d74:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs4(r4, r0, r1, r2, cwrsi4_lbl2)
84203d78:	00 00 30 01 	r1 = Null + 0;
84203d7c:	0f 00 26 00 	r0 = r4 + Null;
84203d80:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl2;
84203d84:	aa 2a 00 fd 	r2 = Null + 715827883;
84203d88:	ab aa 40 01 
84203d8c:	6f 00 16 00 	rMAC = r4 + r4;
84203d90:	03 00 11 21 	rMAC = rMAC - 3;
84203d94:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84203d98:	bf 00 11 e4 	rMAC = rMAC + 4;
84203d9c:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203da0:	03 00 33 99 	r1 = r1 * 3 (int);
84203da4:	1f 00 03 20 	Null = r1 - rMAC;
84203da8:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203dac:	1f 00 03 20 	Null = r1 - rMAC;
84203db0:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203db4:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84203db8:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203dbc:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203dc0:	3f 00 22 e4 	r0 = r0 - 1;
84203dc4:	00 00 30 27 	r1 = r1 - Null - Borrow;

84203dc8 <$M.celt.cwrsi4.cwrsi4_lbl2>:
      r2 = r6 - r0;
84203dc8:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84203dcc:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84203dd0:	07 00 40 dd 	if NEG jump $M.celt.cwrsi4.pos_part;
         r2 = r3 OR r2;
84203dd4:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi4_loop1_end;
84203dd8:	07 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         Null = r4 - r8;
84203ddc:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi4_loop1_end;
84203de0:	05 00 50 dd 	if POS jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         r10 = r4 + 1;
84203de4:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi4_loop1;
84203de8:	e2 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84203dec <$M.celt.cwrsi4.pos_part>:
      pos_part:
          r8 = r4 - 1;
84203dec:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi4_loop1;
84203df0:	e0 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84203df4 <$M.celt.cwrsi4.cwrsi4_loop1_end>:
   cwrsi4_loop1_end:

   r6 = r6 - r0;
84203df4:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84203df8:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84203dfc:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84203e00:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84203e04:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84203e08:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84203e0c:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi3;
84203e10:	67 ff f0 e1 	call $celt.cwrsi3;
   r0 = M[I7, -MK1];
84203e14:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84203e18:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84203e1c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203e20:	0f 00 0d dc 	rts;

84203e24 <$celt.cwrsi5>:
#endif
  
     // push rLink onto stack
   .CONST TMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84203e24:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203e28:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84203e2c:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs5(r3, r0, r1, r2, cwrsi5_lbl1)
84203e30:	00 00 30 01 	r1 = Null + 0;
84203e34:	0f 00 25 00 	r0 = r3 + Null;
84203e38:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl1;
84203e3c:	aa 2a 00 fd 	r2 = Null + 715827883;
84203e40:	ab aa 40 01 
84203e44:	cf 00 15 e4 	rMAC = r3 - 2;
84203e48:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84203e4c:	05 00 11 01 	rMAC = rMAC + 5;
84203e50:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84203e54:	df 00 11 e4 	rMAC = rMAC - 4;
84203e58:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203e5c:	03 00 33 99 	r1 = r1 * 3 (int);
84203e60:	1f 00 03 20 	Null = r1 - rMAC;
84203e64:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203e68:	1f 00 03 20 	Null = r1 - rMAC;
84203e6c:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203e70:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84203e74:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203e78:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203e7c:	2f 00 22 e4 	r0 = r0 + 1;
84203e80:	00 00 30 07 	r1 = r1 + Null + Carry;

84203e84 <$M.celt.cwrsi5.cwrsi5_lbl1>:
   M[FP + TMP + 0]  = r0;
84203e84:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84203e88:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84203e8c:	10 00 6c f1 	M[FP + 0x10] = r4;

   M0 = 0;
84203e90:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84203e94:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84203e98:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84203e9c:	04 00 40 dd 	if NEG jump $M.celt.cwrsi5.chng1_end;
      M0 = 1;
84203ea0:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84203ea4:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84203ea8:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84203eac <$M.celt.cwrsi5.chng1_end>:
   chng1_end:
   r10 = 0;
84203eac:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84203eb0:	0f 00 a6 00 	r8 = r4 + Null;

84203eb4 <$M.celt.cwrsi5.cwrsi5_loop1>:
   cwrsi5_loop1:
      r4 = r10 + r8;
84203eb4:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84203eb8:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs5(r4, r0, r1, r2, cwrsi5_lbl2)
84203ebc:	00 00 30 01 	r1 = Null + 0;
84203ec0:	0f 00 26 00 	r0 = r4 + Null;
84203ec4:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl2;
84203ec8:	aa 2a 00 fd 	r2 = Null + 715827883;
84203ecc:	ab aa 40 01 
84203ed0:	cf 00 16 e4 	rMAC = r4 - 2;
84203ed4:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84203ed8:	05 00 11 01 	rMAC = rMAC + 5;
84203edc:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84203ee0:	df 00 11 e4 	rMAC = rMAC - 4;
84203ee4:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203ee8:	03 00 33 99 	r1 = r1 * 3 (int);
84203eec:	1f 00 03 20 	Null = r1 - rMAC;
84203ef0:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203ef4:	1f 00 03 20 	Null = r1 - rMAC;
84203ef8:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203efc:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84203f00:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203f04:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203f08:	2f 00 22 e4 	r0 = r0 + 1;
84203f0c:	00 00 30 07 	r1 = r1 + Null + Carry;

84203f10 <$M.celt.cwrsi5.cwrsi5_lbl2>:
      r2 = r6 - r0;
84203f10:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84203f14:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84203f18:	07 00 40 dd 	if NEG jump $M.celt.cwrsi5.pos_part;
         r2 = r3 OR r2;
84203f1c:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi5_loop1_end;
84203f20:	07 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         Null = r4 - r8;
84203f24:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi5_loop1_end;
84203f28:	05 00 50 dd 	if POS jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         r10 = r4 + 1;
84203f2c:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi5_loop1;
84203f30:	e1 ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84203f34 <$M.celt.cwrsi5.pos_part>:
      pos_part:
         r8 = r4 - 1;
84203f34:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi5_loop1;
84203f38:	df ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84203f3c <$M.celt.cwrsi5.cwrsi5_loop1_end>:

   cwrsi5_loop1_end:
   r6 = r6 - r0;
84203f3c:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84203f40:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84203f44:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84203f48:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84203f4c:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84203f50:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84203f54:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi4;
84203f58:	63 ff f0 e1 	call $celt.cwrsi4;
   r0 = M[I7, -MK1];
84203f5c:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84203f60:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84203f64:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203f68:	0f 00 0d dc 	rts;

84203f6c <$celt.uprev>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UPREV.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84203f6c:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  uprev_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84203f70:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1,  r0 = M[I2, M0]; //0 ->1
84203f74:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84203f78:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do uprev_loop;
84203f7c:	04 00 f0 e5 	do $M.celt.uprev.uprev_loop;
     r6 = r4 - r0;
84203f80:	2f 00 86 20 	r6 = r4 - r0;
     r2 = r6 - r2, M[I3, M0] = r2;
84203f84:	4f cc 48 20 	r2 = r6 - r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84203f88:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84203f8c <$M.celt.uprev.uprev_loop>:
  uprev_loop:
  M[I3, M0] = r2;
84203f8c:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;
#endif // K32

  rts;
84203f90:	0f 00 0d dc 	rts;

84203f94 <$celt.unext>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNEXT.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84203f94:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  unext_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84203f98:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1, r0 = M[I2, M0]; //0 ->1
84203f9c:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84203fa0:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do unext_loop;
84203fa4:	04 00 f0 e5 	do $M.celt.unext.unext_loop;
     r6 = r4 + r0;
84203fa8:	2f 00 86 00 	r6 = r4 + r0;
     r2 = r6 + r2, M[I3, M0] = r2;
84203fac:	4f cc 48 00 	r2 = r6 + r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84203fb0:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84203fb4 <$M.celt.unext.unext_loop>:
  unext_loop:
  M[I3, M0] = r2;  
84203fb4:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;

#endif // K32
  rts;
84203fb8:	0f 00 0d dc 	rts;

84203fbc <$celt.cwrsi>:

   //r4 = k
   //I7 = y
   //I5 = u (32 bit
   //M3 = n
   push rlink;
84203fbc:	00 00 d0 f3 	push rLink;
   Words2Addr(r4);
84203fc0:	02 00 66 91 	r4 = r4 ASHIFT 2;
   r8 = I5 + r4;
84203fc4:	6f 00 a5 48 	r8 = I5 + r4;
   r8 = r8 + r4;
84203fc8:	00 00 a6 03 	r8 = r8 + r4;
   Addr2Words(r4);
84203fcc:	fe 00 66 91 	r4 = r4 ASHIFT -2;
      I3 = I5;
      pushm <r0, r1, r4, r6, r7>;
      call $celt.uprev;
      popm <r0, r1, r4, r6, r7>;
#else // K32
   M2 = -2*ADDR_PER_WORD;
84203fd0:	f8 ff a0 51 	M2 = Null + -8;

84203fd4 <$M.celt.cwrsi.cwrsi_loop>:
   cwrsi_loop:
      r0 = M[r8 + MK2];
84203fd4:	08 00 2a d1 	r0 = M[r8 + 8];
      M0 = 0;
84203fd8:	00 00 80 51 	M0 = Null + 0;
      Null = r6 - r0;
84203fdc:	2f 00 08 20 	Null = r6 - r0;
      if NC jump chng1_end;
84203fe0:	03 00 30 dd 	if NC jump $M.celt.cwrsi.chng1_end;
         M0 = 1;
84203fe4:	01 00 80 51 	M0 = Null + 1;
         r6 = r6 - r0;
84203fe8:	00 00 82 23 	r6 = r6 - r0;

84203fec <$M.celt.cwrsi.chng1_end>:
      chng1_end:
      r0 = M[r8 + 0];
84203fec:	00 00 2a d1 	r0 = M[r8 + 0];
      I2 = r8 - 2*ADDR_PER_WORD;
84203ff0:	08 00 2a 71 	I2 = r8 - 8;

84203ff4 <$M.celt.cwrsi.cwrsi_loop2>:
      cwrsi_loop2:
        r2 = r6 - r0, r0 = M[I2, M2];
84203ff4:	2f 2a 48 20 	r2 = r6 - r0, r0 = M[I2,M2];
      if NC jump cwrsi_loop2;
84203ff8:	ff ff 30 dd 	if NC jump $M.celt.cwrsi.cwrsi_loop2;
      r8 = I2 + 4*ADDR_PER_WORD;
84203ffc:	10 00 a2 49 	r8 = I2 + 16;
      r6 = r2;
84204000:	0f 00 84 00 	r6 = r2 + Null;
      r3 = r8 - I5;
84204004:	5f 00 5a 64 	r3 = r8 - I5;
      Addr2Words(r3);
84204008:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r3 = r3 LSHIFT -1;
8420400c:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
      r4 = r4 - r3;
84204010:	00 00 65 23 	r4 = r4 - r3;
      Null = M0;
84204014:	00 00 08 47 	Null = Null + M0;
      if NZ r4 = -r4;
84204018:	61 00 60 20 	if NE r4 = Null - r4;
      M[I7, MK1] = r4;
8420401c:	ed 00 00 03 	Null = Null + Null, M[I7,4] = r4;
      r4 = r3;
84204020:	0f 00 65 00 	r4 = r3 + Null;
      r10 = r4 + 2;
84204024:	af 00 c6 e4 	r10 = r4 + 2;
      r2 = 0;
84204028:	00 00 40 01 	r2 = Null + 0;
      I3 = I5;
8420402c:	0f 00 35 58 	I3 = I5 + Null;
      pushm <r4, r6>;
84204030:	40 01 00 f1 	pushm <r4, r6>;
      call $celt.uprev;
84204034:	ce ff f0 e1 	call $celt.uprev;
      popm  <r4, r6>;
84204038:	40 01 04 f1 	popm <r4, r6>;
#endif
     M3 = M3 - 1;
8420403c:	01 00 bb 79 	M3 = M3 - 1;

   if NZ jump cwrsi_loop;
84204040:	e5 ff 10 dd 	if NE jump $M.celt.cwrsi.cwrsi_loop;


   jump $pop_rLink_and_rts;
84204044:	03 00 00 fd 	jump (m) 0x3b020;
84204048:	21 b0 f0 dd 

8420404c <$celt.ncwrs_urow>:
   //r4 = k
   //r3 = n
   //len=_k+2;
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
8420404c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84204050:	10 00 03 f1 	SP = SP + 16;
   Words2Addr(r4);
84204054:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I6 = I7 + r4;
84204058:	6f 00 67 58 	I6 = I7 + r4;
   I6 = I6 + r4;
8420405c:	00 00 66 5b 	I6 = I6 + r4;
   r8 = I7;
84204060:	7f 00 a0 44 	r8 = Null + I7;
   Addr2Words(r4);
84204064:	fe 00 66 91 	r4 = r4 ASHIFT -2;
   M3 = r4 + 2;
84204068:	02 00 b6 51 	M3 = r4 + 2;
   M[r8 + 0] = Null;
8420406c:	00 00 0a d5 	M[r8 + 0] = Null;
   M[r8 + MK1] = Null;
84204070:	04 00 0a d5 	M[r8 + 4] = Null;
   r0 = 1;
84204074:	2f 00 20 e4 	r0 = Null + 1;
   M[r8 + MK2] = r0;
84204078:	08 00 2a d5 	M[r8 + 8] = r0;
   M[r8 + 3*MK1] = Null;
8420407c:	0c 00 0a d5 	M[r8 + 12] = Null;

   Addr2Words(r3);
84204080:	fe 00 55 91 	r3 = r3 ASHIFT -2;
   Null = r3 - 7;
84204084:	07 00 05 21 	Null = r3 - 7;
   if NEG jump path1;
84204088:	2b 00 40 dd 	if NEG jump $M.celt.ncwrs_urow.path1;
   Null = r4 - 256;
8420408c:	00 01 06 21 	Null = r4 - 256;
   if POS jump path1;
84204090:	29 00 50 dd 	if POS jump $M.celt.ncwrs_urow.path1;

84204094 <$M.celt.ncwrs_urow.path2>:
   path2: /*n>6 && k<=255*/
      r0 = r3 + r3;
84204094:	5f 00 25 00 	r0 = r3 + r3;
      r0 = r0 - 1;
84204098:	3f 00 22 e4 	r0 = r0 - 1;
      M[r8 + 4*MK1] = r0;
8420409c:	10 00 2a d5 	M[r8 + 16] = r0;
      r1 = 0;
842040a0:	00 00 30 01 	r1 = Null + 0;
      M[r8 + 5*MK1] = r1;
842040a4:	14 00 3a d5 	M[r8 + 20] = r1;
      M3 = r4 + -1;
842040a8:	ff ff b6 51 	M3 = r4 + -1;
      if LE jump end;
842040ac:	35 00 d0 dd 	if LE jump $M.celt.ncwrs_urow.end;
      I3 = r8 + 6*ADDR_PER_WORD;
842040b0:	18 00 3a 51 	I3 = r8 + 24;
      r4 = 1;
842040b4:	2f 00 60 e4 	r4 = Null + 1;
      r5 = 0;
842040b8:	00 00 70 01 	r5 = Null + 0;
      r2 = r0;
842040bc:	0f 00 42 00 	r2 = r0 + Null;
      r3 = r1;
842040c0:	0f 00 53 00 	r3 = r1 + Null;
      M[FP + TEMP + 0] = r2;  //UM1
842040c4:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP + MK1] = r3;  //uM1
842040c8:	0c 00 5c f1 	M[FP + 0xc] = r3;
      M[FP + TEMP + MK2] = r4;  //um2
842040cc:	10 00 6c f1 	M[FP + 0x10] = r4;
      M[FP + TEMP + 3*MK1] = r5;  //um2
842040d0:	14 00 7c f1 	M[FP + 0x14] = r5;
      r10 = FP + TEMP + 2*MK1;
842040d4:	10 00 c7 f1 	r10 = FP + 16;
      I2 = r10;
842040d8:	cf 00 20 50 	I2 = Null + r10;
      r10 = 2; //is not a do loop
842040dc:	af 00 c0 e4 	r10 = Null + 2;
      M2 = 1;
842040e0:	01 00 a0 51 	M2 = Null + 1;

842040e4 <$M.celt.ncwrs_urow.path2_unext_loop>:
      path2_unext_loop:
         r4 = M[I2, MK1];                //um2 2 ->3
842040e4:	00 69 00 03 	Null = Null + Null, r4 = M[I2,4];
         r5 = M[I2, -MK1];               //um2 3->2
842040e8:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         call $celt.imusdiv32;
842040ec:	75 fc f0 e1 	call $celt.imusdiv32;
         r2 = r2 + r4;
842040f0:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2; //um2 2 ->3
842040f4:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, -MK1] = r3;                       //um2 3 ->2
842040f8:	00 db 00 03 	Null = Null + Null, M[I2,-4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
842040fc:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
84204100:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
         if Z jump end;
84204104:	1f 00 00 dd 	if EQ jump $M.celt.ncwrs_urow.end;
         r5 = M[I2, -MK1];               //2->1 dummy
84204108:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r5 = M[I2, -MK1];               //um1 1->0
8420410c:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r4 = M[I2, 0];                //um1 0->0
84204110:	00 68 00 03 	Null = Null + Null, r4 = M[I2,0];
         call $celt.imusdiv32;
84204114:	6b fc f0 e1 	call $celt.imusdiv32;

         r2 = r2 + r4;
84204118:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2;  //um2 0 ->1
8420411c:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, MK1] = r3;                        //um2 1 ->2
84204120:	00 d9 00 03 	Null = Null + Null, M[I2,4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
84204124:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
84204128:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
      if NZ jump path2_unext_loop;
8420412c:	ee ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path2_unext_loop;
      jump end;
84204130:	14 00 f0 dd 	jump $M.celt.ncwrs_urow.end;

84204134 <$M.celt.ncwrs_urow.path1>:
   path1: /*n<=6 || k>255*/
      r10 = r4 - 1;
84204134:	3f 00 c6 e4 	r10 = r4 - 1;
      I3 = r8 + 4*ADDR_PER_WORD;
84204138:	10 00 3a 51 	I3 = r8 + 16;
      r0 = 3;
8420413c:	03 00 20 01 	r0 = Null + 3;
      r1 = 2;
84204140:	af 00 30 e4 	r1 = Null + 2;
      r2 = 0;
84204144:	00 00 40 01 	r2 = Null + 0;
      do set_uk_2_plus_loop;
84204148:	03 00 f0 e5 	do $M.celt.ncwrs_urow.set_uk_2_plus_loop;
         r0 = r0 + r1, M[I3, MK1] = r0;
8420414c:	00 ad 23 03 	r0 = r0 + r1, M[I3,4] = r0;
         M[I3, MK1] = r2;
84204150:	00 cd 00 03 	Null = Null + Null, M[I3,4] = r2;

84204154 <$M.celt.ncwrs_urow.set_uk_2_plus_loop>:
      set_uk_2_plus_loop:
      M[I3, MK1] = r0;
84204154:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;
      M[I3, MK2] = r2;
84204158:	00 ce 00 03 	Null = Null + Null, M[I3,8] = r2;
      M3 = r3 - 2;
8420415c:	02 00 b5 71 	M3 = r3 - 2;
      M2 = r4 + 1;
84204160:	01 00 a6 51 	M2 = r4 + 1;

84204164 <$M.celt.ncwrs_urow.path1_unext_loop>:
      path1_unext_loop:
         r10 = M2;
84204164:	af 00 c0 44 	r10 = Null + M2;
         r3 = 0;
84204168:	00 00 50 01 	r3 = Null + 0;
         r2 = 1;
8420416c:	2f 00 40 e4 	r2 = Null + 1;
         I3 = I7 + 2*ADDR_PER_WORD;
84204170:	08 00 37 59 	I3 = I7 + 8;
         call $celt.unext;
84204174:	88 ff f0 e1 	call $celt.unext;
         M3 = M3 - 1;
84204178:	01 00 bb 79 	M3 = M3 - 1;
      if NZ jump path1_unext_loop;
8420417c:	fa ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path1_unext_loop;

84204180 <$M.celt.ncwrs_urow.end>:
   end:
   r0 = M[I6, MK1];
84204180:	29 00 00 03 	Null = Null + Null, r0 = M[I6,4];
   r1 = M[I6, MK1];
84204184:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r2 = M[I6, MK1];
84204188:	49 00 00 03 	Null = Null + Null, r2 = M[I6,4];
   r3 = M[I6, MK1];
8420418c:	59 00 00 03 	Null = Null + Null, r3 = M[I6,4];
   r0 = r0 + r2;
84204190:	00 00 24 03 	r0 = r0 + r2;
   r1 = r1 + r3 + Carry;
84204194:	00 00 35 07 	r1 = r1 + r3 + Carry;
   SP = SP - STACK_FRAME_SIZE;
84204198:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
8420419c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842041a0:	0f 00 0d dc 	rts;

842041a4 <$celt.icwrs2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS2.PATCH_ID_0)     // celt_patchers
#endif  
   
   I7 = I7 + MK1;
842041a4:	04 00 77 59 	I7 = I7 + 4;
   r0 = M[I7, -MK1];
842041a8:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   $celt.icwrs1(r0, r4, r6)
842041ac:	2f 00 80 e4 	r6 = Null + 1;
842041b0:	0f 00 62 00 	r4 = r0 + Null;
842041b4:	05 00 80 00 	if POS r6 = Null + Null;
842041b8:	61 00 60 20 	if NE r4 = Null - r4;
   $celt.ucwrs2(r4, r0)
842041bc:	6f 00 26 00 	r0 = r4 + r4;
842041c0:	3f 00 22 e4 	r0 = r0 - 1;
842041c4:	04 00 20 00 	if NEG r0 = Null + Null;
   r6 = r6 + r0, r1 = M[I7, 0];
842041c8:	3c 00 82 03 	r6 = r6 + r0, r1 = M[I7,0];
   Null = r1;
842041cc:	0f 00 03 00 	Null = r1 + Null;
   if POS jump end;
842041d0:	08 00 50 dd 	if POS jump $M.celt.icwrs2.end;
      r4 = r4 - r1;
842041d4:	00 00 63 23 	r4 = r4 - r1;
      r0 = r4 + 1;
842041d8:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs2(r0, r2)
842041dc:	2f 00 42 00 	r2 = r0 + r0;
842041e0:	3f 00 44 e4 	r2 = r2 - 1;
842041e4:	04 00 40 00 	if NEG r2 = Null + Null;
      r6 = r6 + r2;
842041e8:	00 00 84 03 	r6 = r6 + r2;
      rts;
842041ec:	0f 00 0d dc 	rts;

842041f0 <$M.celt.icwrs2.end>:
   end:
   r4 = r4 + r1;
842041f0:	00 00 63 03 	r4 = r4 + r1;
   rts;
842041f4:	0f 00 0d dc 	rts;

842041f8 <$celt.icwrs3>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS3.PATCH_ID_0)     // celt_patchers
#endif  
   
   push rlink;
842041f8:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
842041fc:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs2;
84204200:	e9 ff f0 e1 	call $celt.icwrs2;
   I7 = I7 - MK1;
84204204:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs3(r4, r0, r1, icwrs3_lbl1)
84204208:	00 00 20 01 	r0 = Null + 0;
8420420c:	00 00 30 01 	r1 = Null + 0;
84204210:	3f 00 16 e4 	rMAC = r4 - 1;
84204214:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl1;
84204218:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
8420421c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84204220:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84204224:	2f 00 22 e4 	r0 = r0 + 1;
84204228:	00 00 30 07 	r1 = r1 + Null + Carry;

8420422c <$M.celt.icwrs3.icwrs3_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
8420422c:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
84204230:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
84204234:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
84204238:	10 00 50 dd 	if POS jump $M.celt.icwrs3.end;
      r4 = r4 - r2;
8420423c:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
84204240:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs3(r0, r1, r2, icwrs3_lbl2)
84204244:	00 00 30 01 	r1 = Null + 0;
84204248:	00 00 40 01 	r2 = Null + 0;
8420424c:	3f 00 12 e4 	rMAC = r0 - 1;
84204250:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl2;
84204254:	1f 00 12 cc 	rMAC = r0 * rMAC (SS);
84204258:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
8420425c:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84204260:	2f 00 33 e4 	r1 = r1 + 1;
84204264:	00 00 40 07 	r2 = r2 + Null + Carry;

84204268 <$M.celt.icwrs3.icwrs3_lbl2>:
      r6 = r6 + r1;
84204268:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
8420426c:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
84204270:	03 00 00 fd 	jump (m) 0x3b020;
84204274:	21 b0 f0 dd 

84204278 <$M.celt.icwrs3.end>:
   end:
   r4 = r4 + r2;
84204278:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
8420427c:	03 00 00 fd 	jump (m) 0x3b020;
84204280:	21 b0 f0 dd 

84204284 <$celt.icwrs4>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS4.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84204284:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
84204288:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs3;
8420428c:	db ff f0 e1 	call $celt.icwrs3;
   I7 = I7 - MK1;
84204290:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs4(r4, r0, r1, r2, icwrs4_lbl1)
84204294:	00 00 30 01 	r1 = Null + 0;
84204298:	0f 00 26 00 	r0 = r4 + Null;
8420429c:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl1;
842042a0:	aa 2a 00 fd 	r2 = Null + 715827883;
842042a4:	ab aa 40 01 
842042a8:	6f 00 16 00 	rMAC = r4 + r4;
842042ac:	03 00 11 21 	rMAC = rMAC - 3;
842042b0:	00 00 16 9b 	rMAC = rMAC * r4 (int);
842042b4:	bf 00 11 e4 	rMAC = rMAC + 4;
842042b8:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842042bc:	03 00 33 99 	r1 = r1 * 3 (int);
842042c0:	1f 00 03 20 	Null = r1 - rMAC;
842042c4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842042c8:	1f 00 03 20 	Null = r1 - rMAC;
842042cc:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842042d0:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842042d4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842042d8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842042dc:	3f 00 22 e4 	r0 = r0 - 1;
842042e0:	00 00 30 27 	r1 = r1 - Null - Borrow;

842042e4 <$M.celt.icwrs4.icwrs4_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
842042e4:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
842042e8:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
842042ec:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
842042f0:	1b 00 50 dd 	if POS jump $M.celt.icwrs4.end;
      r4 = r4 - r2;
842042f4:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
842042f8:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs4(r0, r1, r2, r3, icwrs4_lbl2)
842042fc:	00 00 40 01 	r2 = Null + 0;
84204300:	0f 00 32 00 	r1 = r0 + Null;
84204304:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl2;
84204308:	aa 2a 00 fd 	r3 = Null + 715827883;
8420430c:	ab aa 50 01 
84204310:	2f 00 12 00 	rMAC = r0 + r0;
84204314:	03 00 11 21 	rMAC = rMAC - 3;
84204318:	00 00 12 9b 	rMAC = rMAC * r0 (int);
8420431c:	bf 00 11 e4 	rMAC = rMAC + 4;
84204320:	5f 00 41 94 	r2 = rMAC * r3 (frac);
84204324:	03 00 44 99 	r2 = r2 * 3 (int);
84204328:	1f 00 04 20 	Null = r2 - rMAC;
8420432c:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
84204330:	1f 00 04 20 	Null = r2 - rMAC;
84204334:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
84204338:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
8420433c:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
84204340:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84204344:	3f 00 33 e4 	r1 = r1 - 1;
84204348:	00 00 40 27 	r2 = r2 - Null - Borrow;

8420434c <$M.celt.icwrs4.icwrs4_lbl2>:
      r6 = r6 + r1;
8420434c:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
84204350:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
84204354:	03 00 00 fd 	jump (m) 0x3b020;
84204358:	21 b0 f0 dd 

8420435c <$M.celt.icwrs4.end>:
   end:
   r4 = r4 + r2;
8420435c:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
84204360:	03 00 00 fd 	jump (m) 0x3b020;
84204364:	21 b0 f0 dd 

84204368 <$celt.icwrs5>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS5.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84204368:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
8420436c:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs4;
84204370:	c5 ff f0 e1 	call $celt.icwrs4;
   I7 = I7 - MK1;
84204374:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs5(r4, r0, r1, r2, icwrs5_lbl1)
84204378:	00 00 30 01 	r1 = Null + 0;
8420437c:	0f 00 26 00 	r0 = r4 + Null;
84204380:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl1;
84204384:	aa 2a 00 fd 	r2 = Null + 715827883;
84204388:	ab aa 40 01 
8420438c:	cf 00 16 e4 	rMAC = r4 - 2;
84204390:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84204394:	05 00 11 01 	rMAC = rMAC + 5;
84204398:	00 00 16 9b 	rMAC = rMAC * r4 (int);
8420439c:	df 00 11 e4 	rMAC = rMAC - 4;
842043a0:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842043a4:	03 00 33 99 	r1 = r1 * 3 (int);
842043a8:	1f 00 03 20 	Null = r1 - rMAC;
842043ac:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842043b0:	1f 00 03 20 	Null = r1 - rMAC;
842043b4:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842043b8:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842043bc:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842043c0:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842043c4:	2f 00 22 e4 	r0 = r0 + 1;
842043c8:	00 00 30 07 	r1 = r1 + Null + Carry;

842043cc <$M.celt.icwrs5.icwrs5_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
842043cc:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
842043d0:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
842043d4:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
842043d8:	1c 00 50 dd 	if POS jump $M.celt.icwrs5.end;
      r4 = r4 - r2;
842043dc:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
842043e0:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs5(r0, r1, r2, r3, icwrs5_lbl2)
842043e4:	00 00 40 01 	r2 = Null + 0;
842043e8:	0f 00 32 00 	r1 = r0 + Null;
842043ec:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl2;
842043f0:	aa 2a 00 fd 	r3 = Null + 715827883;
842043f4:	ab aa 50 01 
842043f8:	cf 00 12 e4 	rMAC = r0 - 2;
842043fc:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84204400:	05 00 11 01 	rMAC = rMAC + 5;
84204404:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84204408:	df 00 11 e4 	rMAC = rMAC - 4;
8420440c:	5f 00 41 94 	r2 = rMAC * r3 (frac);
84204410:	03 00 44 99 	r2 = r2 * 3 (int);
84204414:	1f 00 04 20 	Null = r2 - rMAC;
84204418:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
8420441c:	1f 00 04 20 	Null = r2 - rMAC;
84204420:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
84204424:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
84204428:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
8420442c:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84204430:	2f 00 33 e4 	r1 = r1 + 1;
84204434:	00 00 40 07 	r2 = r2 + Null + Carry;

84204438 <$M.celt.icwrs5.icwrs5_lbl2>:
      r6 = r6 + r1;
84204438:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
8420443c:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
84204440:	03 00 00 fd 	jump (m) 0x3b020;
84204444:	21 b0 f0 dd 

84204448 <$M.celt.icwrs5.end>:
   end:
   r4 = r4 + r2;
84204448:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
8420444c:	03 00 00 fd 	jump (m) 0x3b020;
84204450:	21 b0 f0 dd 

84204454 <$celt.icwrs>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84204454:	00 00 d0 f3 	push rLink;

   I2 = I5;
84204458:	0f 00 25 58 	I2 = I5 + Null;
   M0 = MK1;
8420445c:	04 00 80 51 	M0 = Null + 4;
   r2 = 0;
84204460:	00 00 40 01 	r2 = Null + 0;
   r10 = r4, M[I2, M0] = r2;
84204464:	0f c8 c6 00 	r10 = r4 + Null, M[I2,M0] = r2;
   r0 = 1, M[I2, M0] = r2; 
84204468:	2f c8 20 e4 	r0 = Null + 1, M[I2,M0] = r2;
   r1 = r0 + r0, M[I2, M0] = r0;
8420446c:	2f a8 32 00 	r1 = r0 + r0, M[I2,M0] = r0;
   do init_u_loop;
84204470:	03 00 f0 e5 	do $M.celt.icwrs.init_u_loop;
      r0 = r0 + r1, M[I2, M0] = r2;
84204474:	00 c8 23 02 	r0 = r0 + r1, M[I2,M0] = r2;
      M[I2, M0] = r0;
84204478:	00 a8 00 02 	Null = Null + Null, M[I2,M0] = r0;

8420447c <$M.celt.icwrs.init_u_loop>:
   init_u_loop:
   I7 = I7 - MK1;
8420447c:	04 00 77 79 	I7 = I7 - 4;
   I7 = I7 + r3, M[I2, M0] = r2;
84204480:	00 c8 75 5a 	I7 = I7 + r3, M[I2,M0] = r2;
   r2 = M[I7, -MK1];
84204484:	4f 00 00 03 	Null = Null + Null, r2 = M[I7,-4];
   $celt.icwrs1(r2, r8, r6)
84204488:	2f 00 80 e4 	r6 = Null + 1;
8420448c:	0f 00 a4 00 	r8 = r2 + Null;
84204490:	05 00 80 00 	if POS r6 = Null + Null;
84204494:	a1 00 a0 20 	if NE r8 = Null - r8;
   r8 = r8 + r8;
84204498:	00 00 aa 03 	r8 = r8 + r8;
   Words2Addr(r8);
8420449c:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   r8 = I5 + r8;
842044a0:	af 00 a5 48 	r8 = I5 + r8;
   r0 = M[r8 + 0];
842044a4:	00 00 2a d1 	r0 = M[r8 + 0];
   r6 = r6 + r0;
842044a8:	00 00 82 03 	r6 = r6 + r0;
   r7 = 0, r0 = M[I7, -MK1];
842044ac:	2f 00 99 23 	r7 = r7 - r7, r0 = M[I7,-4];
   r1  = r0 + r0;
842044b0:	2f 00 32 00 	r1 = r0 + r0;
   if POS jump index_up;
842044b4:	06 00 50 dd 	if POS jump $M.celt.icwrs.index_up;
      r1 = -r1;
842044b8:	3f 00 30 20 	r1 = Null - r1;
      r2 = r1 + 2;
842044bc:	af 00 43 e4 	r2 = r1 + 2;
      Words2Addr(r2);
842044c0:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r0 = M[r8 + r2];
842044c4:	4f 00 2a d0 	r0 = M[r8 + r2];
      r6 = r6 + r0;
842044c8:	00 00 82 03 	r6 = r6 + r0;

842044cc <$M.celt.icwrs.index_up>:
   index_up:
   Words2Addr(r1);
842044cc:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;
842044d0:	00 00 a3 03 	r8 = r8 + r1;
   M3 = r3 - 2*ADDR_PER_WORD;
842044d4:	08 00 b5 71 	M3 = r3 - 8;
   M1 = r4 + 2;
842044d8:	02 00 96 51 	M1 = r4 + 2;

842044dc <$M.celt.icwrs.index_up_loop>:
   index_up_loop:
       r2 = 0;
842044dc:	00 00 40 01 	r2 = Null + 0;
       r3 = 0;
842044e0:	00 00 50 01 	r3 = Null + 0;
       r10 = M1;
842044e4:	9f 00 c0 44 	r10 = Null + M1;
       I3 = I5;
842044e8:	0f 00 35 58 	I3 = I5 + Null;
       pushm<r6, r7>;
842044ec:	00 03 00 f1 	pushm <r6, r7>;
       call $celt.unext;
842044f0:	a9 fe f0 e1 	call $celt.unext;
       popm<r6, r7>;
842044f4:	00 03 04 f1 	popm <r6, r7>;
       r0 = M[r8 + 0];
842044f8:	00 00 2a d1 	r0 = M[r8 + 0];
       r1 = M[r8 + MK1];
842044fc:	04 00 3a d1 	r1 = M[r8 + 4];
       r6 = r6 + r0;
84204500:	00 00 82 03 	r6 = r6 + r0;
       r7 = r7 + r1 + Carry, r5 = M[I7, -MK1];
84204504:	7f 00 93 07 	r7 = r7 + r1 + Carry, r5 = M[I7,-4];
       r5 = r5 + r5;
84204508:	00 00 77 03 	r5 = r5 + r5;
       if POS jump end_update;
8420450c:	09 00 50 dd 	if POS jump $M.celt.icwrs.end_update;
          r5 = -r5;
84204510:	7f 00 70 20 	r5 = Null - r5;
          r2 = r5 + 2; 
84204514:	af 00 47 e4 	r2 = r5 + 2;
          Words2Addr(r2);
84204518:	02 00 44 91 	r2 = r2 ASHIFT 2;
          r0 = M[r8 + r2]; 
8420451c:	4f 00 2a d0 	r0 = M[r8 + r2];
          r2 = r2 + ADDR_PER_WORD;
84204520:	bf 00 44 e4 	r2 = r2 + 4;
          r1 = M[r8 + r2];
84204524:	4f 00 3a d0 	r1 = M[r8 + r2];
          r6 = r6 + r0;
84204528:	00 00 82 03 	r6 = r6 + r0;
          r7 = r7 + r1 + Carry;
8420452c:	00 00 93 07 	r7 = r7 + r1 + Carry;

84204530 <$M.celt.icwrs.end_update>:
       end_update:
       Words2Addr(r5);
84204530:	02 00 77 91 	r5 = r5 ASHIFT 2;
       r8 = r8 + r5;
84204534:	00 00 a7 03 	r8 = r8 + r5;
       M3 = M3 - ADDR_PER_WORD;  //1
84204538:	04 00 bb 79 	M3 = M3 - 4;
  if NZ jump index_up_loop;
8420453c:	e8 ff 10 dd 	if NE jump $M.celt.icwrs.index_up_loop;
  r0 = M[r8 + 0];
84204540:	00 00 2a d1 	r0 = M[r8 + 0];
  r1 = M[r8 +   MK1];
84204544:	04 00 3a d1 	r1 = M[r8 + 4];
  r2 = M[r8 + 2*MK1];
84204548:	08 00 4a d1 	r2 = M[r8 + 8];
  r3 = M[r8 + 3*MK1];
8420454c:	0c 00 5a d1 	r3 = M[r8 + 12];
  r0 = r0 + r2;
84204550:	00 00 24 03 	r0 = r0 + r2;
  r1 = r1 + r3 + Carry;
84204554:	00 00 35 07 	r1 = r1 + r3 + Carry;
  jump $pop_rLink_and_rts;
84204558:	03 00 00 fd 	jump (m) 0x3b020;
8420455c:	21 b0 f0 dd 

84204560 <$celt.encode_pulses32>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_PULSES32.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84204560:	00 00 d0 f3 	push rLink;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif   
   // save nr of pulses and bins
   pushm<r3, r4, r5>;
84204564:	e0 00 00 f1 	pushm <r3, r4, r5>;
   push I7;
84204568:	00 00 71 f3 	push I7;
   
#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
8420456c:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
84204570:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif   
   if POS jump default;
84204574:	50 00 50 dd 	if POS jump $M.celt.encode_pulses32.default;
   Null = r3 - 1;
84204578:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
8420457c:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84204580:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
84204584:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
84204588:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
8420458c:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif
   jump r0;
84204590:	0f 00 02 dc 	jump r0;

84204594 <$M.celt.encode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = M[I7, 0];
84204594:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
      $celt.icwrs1(r0, r4, r6)
84204598:	2f 00 80 e4 	r6 = Null + 1;
8420459c:	0f 00 62 00 	r4 = r0 + Null;
842045a0:	05 00 80 00 	if POS r6 = Null + Null;
842045a4:	61 00 60 20 	if NE r4 = Null - r4;
      r0 = 1;
842045a8:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB + 0] = r0;
842045ac:	e4 01 27 d5 	M[r5 + 484] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
842045b0:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = Null;
842045b4:	d8 01 07 d5 	M[r5 + 472] = Null;
      
      call $celt.ec_enc_bits;
842045b8:	36 f3 f0 e1 	call $celt.ec_enc_bits;
   jump $pop_rLink_and_rts;
842045bc:	03 00 00 fd 	jump (m) 0x3b020;
842045c0:	21 b0 f0 dd 

842045c4 <$M.celt.encode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      call $celt.icwrs2;
842045c4:	f8 fe f0 e1 	call $celt.icwrs2;
      $celt.ncwrs2(r4, r0)
842045c8:	2f 00 20 e4 	r0 = Null + 1;
842045cc:	0f 00 06 00 	Null = r4 + Null;
842045d0:	61 00 26 00 	if NE r0 = r4 + r4;
842045d4:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
842045d8:	00 00 30 01 	r1 = Null + 0;
      r7 = 0;
842045dc:	00 00 90 01 	r7 = Null + 0;
   jump end;
842045e0:	3a 00 f0 dd 	jump $M.celt.encode_pulses32.end;

842045e4 <$M.celt.encode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      call $celt.icwrs3;
842045e4:	05 ff f0 e1 	call $celt.icwrs3;
      $celt.ncwrs3(r4, r0, r1, encode_pulses32_n_3_lb1)
842045e8:	2f 00 20 e4 	r0 = Null + 1;
842045ec:	00 00 30 01 	r1 = Null + 0;
842045f0:	0f 00 16 00 	rMAC = r4 + Null;
842045f4:	07 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_3_lb1;
842045f8:	00 00 11 03 	rMAC = rMAC + rMAC;
842045fc:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
84204600:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84204604:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84204608:	af 00 22 e4 	r0 = r0 + 2;
8420460c:	00 00 30 07 	r1 = r1 + Null + Carry;

84204610 <$M.celt.encode_pulses32.encode_pulses32_n_3_lb1>:
   jump end;
84204610:	2e 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84204614 <$M.celt.encode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      call $celt.icwrs4;
84204614:	1c ff f0 e1 	call $celt.icwrs4;
      $celt.ncwrs4(r4, r0, r1, r2, encode_pulses32_n_4_lb1)
84204618:	2f 00 20 e4 	r0 = Null + 1;
8420461c:	00 00 30 01 	r1 = Null + 0;
84204620:	aa 2a 00 fd 	r2 = Null + 715827883;
84204624:	ab aa 40 01 
84204628:	04 00 16 99 	rMAC = r4 * 4 (int);
8420462c:	0c 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_4_lb1;
84204630:	6f 00 26 98 	r0 = r4 * r4 (int);
84204634:	af 00 22 e4 	r0 = r0 + 2;
84204638:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420463c:	03 00 33 99 	r1 = r1 * 3 (int);
84204640:	1f 00 03 20 	Null = r1 - rMAC;
84204644:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84204648:	1f 00 03 20 	Null = r1 - rMAC;
8420464c:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84204650:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84204654:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84204658:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

8420465c <$M.celt.encode_pulses32.encode_pulses32_n_4_lb1>:
   jump end;
8420465c:	1b 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84204660 <$M.celt.encode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      call $celt.icwrs5;
84204660:	42 ff f0 e1 	call $celt.icwrs5;
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
84204664:	2f 00 20 e4 	r0 = Null + 1;
84204668:	00 00 30 01 	r1 = Null + 0;
8420466c:	aa 2a 00 fd 	r2 = Null + 715827883;
84204670:	ab aa 40 01 
84204674:	6f 00 16 98 	rMAC = r4 * r4 (int);
84204678:	0e 00 00 dd 	if EQ jump $M.celt.encode_pulses32.decode_pulses32_n_5_lb1;
8420467c:	05 00 21 01 	r0 = rMAC + 5;
84204680:	00 00 11 03 	rMAC = rMAC + rMAC;
84204684:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84204688:	03 00 33 99 	r1 = r1 * 3 (int);
8420468c:	1f 00 03 20 	Null = r1 - rMAC;
84204690:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84204694:	1f 00 03 20 	Null = r1 - rMAC;
84204698:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
8420469c:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842046a0:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842046a4:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842046a8:	af 00 22 e4 	r0 = r0 + 2;
842046ac:	00 00 30 07 	r1 = r1 + Null + Carry;

842046b0 <$M.celt.encode_pulses32.decode_pulses32_n_5_lb1>:
   jump end;
842046b0:	06 00 f0 dd 	jump $M.celt.encode_pulses32.end;

842046b4 <$M.celt.encode_pulses32.default>:

   // -- process n > 5
   default:
      r0 = M[r5 + $celt.enc.UVECTOR_FIELD];
842046b4:	c8 00 27 d1 	r0 = M[r5 + 200];
      I5 = r0;
842046b8:	2f 00 50 50 	I5 = Null + r0;
      push r5; // r5 needs to be preserved
842046bc:	00 00 70 f3 	push r5;
      call $celt.icwrs;
842046c0:	65 ff f0 e1 	call $celt.icwrs;
      pop r5;
842046c4:	00 00 74 f3 	pop r5;

842046c8 <$M.celt.encode_pulses32.end>:
   end:
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
842046c8:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + MK1] = r1;
842046cc:	d0 01 37 d5 	M[r5 + 464] = r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
842046d0:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = r7;
842046d4:	d8 01 97 d5 	M[r5 + 472] = r7;
      call $celt.ec_enc_uint;
842046d8:	0a f3 f0 e1 	call $celt.ec_enc_uint;

      pop I7;
842046dc:	00 00 75 f3 	pop I7;
      popm<r3, r4, r5>;
842046e0:	e0 00 04 f1 	popm <r3, r4, r5>;

   jump $pop_rLink_and_rts;
842046e4:	03 00 00 fd 	jump (m) 0x3b020;
842046e8:	21 b0 f0 dd 

842046ec <$celt.get1byte>:
842046ec:	f8 01 27 d1 	r0 = M[r5 + 504];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];           // calc amount of shift
   r0 = r0 * (-8) (int); 
842046f0:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I0, 0];                           // r1 = the current word
842046f4:	00 30 00 03 	Null = Null + Null, r1 = M[I0,0];
   r1 = r1 LSHIFT r0;                       // shift current word
842046f8:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                        // extract only the desired bits
842046fc:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
84204700:	f8 01 27 d1 	r0 = M[r5 + 504];
#ifdef DATAFORMAT_32
   r0 = r0 - 1;
84204704:	3f 00 22 e4 	r0 = r0 - 1;
   if POS jump no_p_update;
84204708:	03 00 50 dd 	if POS jump $M.celt.get1byte.no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
8420470c:	00 21 00 03 	Null = Null + Null, r0 = M[I0,4];
      r0 = $celt.BYTE_POS_MAX_VALUE;
84204710:	03 00 20 01 	r0 = Null + 3;

84204714 <$M.celt.get1byte.no_p_update>:
   no_p_update:
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
84204714:	f8 01 27 d5 	M[r5 + 504] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
   if Z jump no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
   no_p_update:
#endif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED];
84204718:	fc 01 27 d1 	r0 = M[r5 + 508];
   if LE r1 = 0;
8420471c:	0d 00 30 00 	if LE r1 = Null + Null;
   r0 = r0 - 1;
84204720:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;  // update number of frame bits read
84204724:	fc 01 27 d5 	M[r5 + 508] = r0;
   rts;
84204728:	0f 00 0d dc 	rts;

8420472c <$celt.get1byte_from_end>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE_FROM_END.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = -1;
8420472c:	3f 00 30 e4 	r1 = Null - 1;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84204730:	04 02 27 d1 	r0 = M[r5 + 516];
   r0 = r0 - 1;
84204734:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
84204738:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;  // update number of frame bits read
8420473c:	04 02 27 d5 	M[r5 + 516] = r0;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];           // calc amount of shift
84204740:	00 02 27 d1 	r0 = M[r5 + 512];
#ifdef DATAFORMAT_32
   r0 = $celt.BYTE_POS_MAX_VALUE - r0;
84204744:	03 00 22 65 	r0 = 3 - r0;
   if GT jump stay_in_this_word;
84204748:	02 00 c0 dd 	if GT jump $M.celt.get1byte_from_end.stay_in_this_word;
      r1 = M[I1, -MK1];
8420474c:	00 37 00 03 	Null = Null + Null, r1 = M[I1,-4];

84204750 <$M.celt.get1byte_from_end.stay_in_this_word>:
   stay_in_this_word:
   r0 = r0 * (-8) (int);
84204750:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I1, 0];                                   // r1 = the current word
84204754:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
   r1 = r1 LSHIFT r0;                               // shift current word
84204758:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                                // extract only the desired bits
8420475c:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];
84204760:	00 02 27 d1 	r0 = M[r5 + 512];
   if NZ jump no_reset;
84204764:	02 00 10 dd 	if NE jump $M.celt.get1byte_from_end.no_reset;
      r0 = 4;
84204768:	bf 00 20 e4 	r0 = Null + 4;

8420476c <$M.celt.get1byte_from_end.no_reset>:
   no_reset:
   r0 = r0 - 1;
8420476c:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE] = r0;
84204770:	00 02 27 d5 	M[r5 + 512] = r0;
   r0 = r0 * (-8) (int); 
   r1 = M[I1, 0];                                   // r1 = the current word
   r1 = r1 LSHIFT r0;                               // shift current word
   r1 = r1 AND 0xFF;                                // extract only the desired bits
#endif
   rts;
84204774:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

84204778 <$_celt_encode_create>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_encode_create(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
84204778:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
8420477a:	11 09       	r7 = r0 + Null;
8420477c:	18 09       	r6 = r1 + Null;
8420477e:	27 00       	r5 = r2 + Null;
84204780:	2a 09       	r8 = r3 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204782:	ef fd de ff 	call (m) 0x4e6;
84204786:	25 eb 
84204788:	16 00       	r4 = r0 + Null;
#endif

    patch_fn_shared(celt_encode_wrapper);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
8420478a:	55 08       	r3 = r8 + Null;
8420478c:	3c 00       	r2 = r5 + Null;
8420478e:	43 08       	r1 = r6 + Null;
84204790:	4a 08       	r0 = r7 + Null;
84204792:	ef fd dd ff 	call (m) 0x35a;
84204796:	29 ee 
84204798:	10 04       	Null = r0 - Null;
8420479a:	03 62       	if NE jump (m) Lc_celt_encode_create_3;

8420479c <Lc_celt_encode_create_2>:
    {
        return FALSE;
8420479c:	02 00       	r0 = Null + Null;
8420479e:	82 6e       	jump (m) Lc_celt_encode_create_17;

842047a0 <Lc_celt_encode_create_3>:
    }

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
842047a0:	07 f0 05 f0 	r3 = Null + 7347948;
842047a4:	ec 7a 
842047a6:	34 39       	r2 = r4 + 52;
842047a8:	33 00       	r1 = r4 + Null;
842047aa:	4a 08       	r0 = r7 + Null;
842047ac:	ff fd 91 f1 	call (m) 0x36b80;
842047b0:	35 ee 
842047b2:	10 04       	Null = r0 - Null;
842047b4:	29 60       	if EQ jump (m) Lc_celt_encode_create_9;

842047b6 <Lc_celt_encode_create_4>:
        return TRUE;
    }
#endif

#ifdef CELT_ENCODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
842047b6:	4a 08       	r0 = r7 + Null;
842047b8:	ef fd f8 ff 	call (m) 0x385a;
842047bc:	23 e5 
842047be:	10 04       	Null = r0 - Null;
842047c0:	28 60       	if EQ jump (m) Lc_celt_encode_create_10;

842047c2 <Lc_celt_encode_create_5>:
842047c2:	ff fd 7b f0 	call (m) 0x13ec2;
842047c6:	21 e8 
842047c8:	03 00       	r1 = Null + Null;
842047ca:	10 04       	Null = r0 - Null;
842047cc:	21 f0 43 ce 	if NE r1 = Null + 1;
842047d0:	21 6e       	jump (m) Lc_celt_encode_create_11;

842047d2 <Lc_celt_encode_create_6>:
    }
    else
    {
        /* No offload: can't use shared allocation */
        if (!mem_table_zalloc((void *)(&(celt_data->codec_data)),
                        celt_enc_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH))
842047d2:	84 20       	r2 = Null + 2;
842047d4:	07 f0 03 f0 	r1 = Null + 7347936;
842047d8:	e0 7a 
842047da:	32 39       	r0 = r4 + 52;
842047dc:	ef fd ea ff 	call (m) 0x1bfe;
842047e0:	23 e1 
842047e2:	10 04       	Null = r0 - Null;
842047e4:	11 60       	if EQ jump (m) Lc_celt_encode_create_9;

842047e6 <Lc_celt_encode_create_7>:
    }
#endif

    /* now allocate the non-shareable memory */
    if (!mem_table_zalloc((uintptr_t *)(&(celt_data->codec_data)), celt_enc_malloc_table,
                                                CELT_ENC_MALLOC_TABLE_LENGTH))
842047e6:	04 21       	r2 = Null + 4;
842047e8:	07 f0 03 f0 	r1 = Null + 7347896;
842047ec:	b8 7a 
842047ee:	32 39       	r0 = r4 + 52;
842047f0:	ef fd ea ff 	call (m) 0x1bfe;
842047f4:	2f e0 
842047f6:	10 04       	Null = r0 - Null;
842047f8:	28 62       	if NE jump (m) Lc_celt_encode_create_15;

842047fa <Lc_celt_encode_create_8>:
    {
        encoder_base_class_deinit(&celt_enc_vt);
842047fa:	07 f0 02 f0 	r0 = Null + 7347948;
842047fe:	ec 7a 
84204800:	ff fd 91 f1 	call (m) 0x36bc0;
84204804:	21 ee 

84204806 <Lc_celt_encode_create_9>:
    }

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
    {
        free_data_and_fail(op_data, response_data);
84204806:	53 08       	r1 = r8 + Null;
84204808:	4a 08       	r0 = r7 + Null;
8420480a:	03 f0 27 e8 	call (m) Lc_free_data_and_fail_1;
8420480e:	49 6e       	jump (m) Lc_celt_encode_create_16;

84204810 <Lc_celt_encode_create_10>:
        return TRUE;
    }
#endif

#ifdef CELT_ENCODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
84204810:	03 00       	r1 = Null + Null;

84204812 <Lc_celt_encode_create_11>:
84204812:	63 f0 a8 8e 	M[r4 + 672] = r1;
    L2_DBG_MSG1("CELT encode, offload_enabled = %d",  celt_data->offload_enabled);
84204816:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420481a:	88 24       	Null = rMAC - 2;
8420481c:	07 68       	if LT jump (m) Lc_celt_encode_create_13;

8420481e <Lc_celt_encode_create_12>:
8420481e:	55 f1 02 f0 	r0 = Null + 357564416;
84204822:	00 40 
84204824:	ef fd e2 ff 	call (m) 0xcde;
84204828:	3b e5 

8420482a <Lc_celt_encode_create_13>:
    if (celt_data->offload_enabled)
8420482a:	60 f0 a8 88 	Null = M[r4 + 672];
8420482e:	d2 61       	if EQ jump (m) Lc_celt_encode_create_6;

84204830 <Lc_celt_encode_create_14>:
    {
        /* Offload enabled, so use a shared allocation */
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_enc_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
84204830:	c5 11       	r3 = FP + 28;
84204832:	84 20       	r2 = Null + 2;
84204834:	07 f0 03 f0 	r1 = Null + 7347920;
84204838:	d0 7a 
8420483a:	32 39       	r0 = r4 + 52;
8420483c:	ef fd ea ff 	call (m) 0x1c4e;
84204840:	33 e0 
84204842:	10 04       	Null = r0 - Null;
84204844:	d1 63       	if NE jump (m) Lc_celt_encode_create_7;

84204846 <Lc__ite_4>:
84204846:	e0 6f       	jump (m) Lc_celt_encode_create_9;

84204848 <Lc_celt_encode_create_15>:



    /* Init default encoding values */
 
    celt_data->codec_data.ptr_flaglist_table = celt_data->codec_common_data.celt_flaglist ;
84204848:	61 f0 9e 88 	rMAC = M[r4 + 632];
8420484c:	61 f0 91 8e 	M[r4 + 580] = rMAC;
    celt_data->codec_data.ptr_emeans_table =celt_data->codec_common_data.celt_emeans_table ;
84204850:	61 f0 9f 88 	rMAC = M[r4 + 636];
84204854:	61 f0 92 8e 	M[r4 + 584] = rMAC;
    celt_data->codec_data.ptr_max_n_table =celt_data->codec_common_data.celt_max_nfield ;
84204858:	61 f0 a0 88 	rMAC = M[r4 + 640];
8420485c:	61 f0 93 8e 	M[r4 + 588] = rMAC;
    celt_data->codec_data.ptr_max_k_table =celt_data->codec_common_data.celt_max_k_table ;
84204860:	61 f0 a1 88 	rMAC = M[r4 + 644];
84204864:	61 f0 94 8e 	M[r4 + 592] = rMAC;
    celt_data->codec_data.ptr_inv2_table =celt_data->codec_common_data.celt_inv2_table ;
84204868:	61 f0 a2 88 	rMAC = M[r4 + 648];
8420486c:	61 f0 95 8e 	M[r4 + 596] = rMAC;
    
    celt_data->codec_data.celt_codec_frame_size_field = 190;
84204870:	01 f0 be 40 	rMAC = Null + 190;
84204874:	b1 9f       	M[r4 + 56] = rMAC;
    celt_data->codec_data.celt_channels_field =  CELT_STEREO_MODE;
84204876:	41 20       	rMAC = Null + 1;
84204878:	f1 9f       	M[r4 + 60] = rMAC;
    celt_data->codec_data.celt_enc_mdct_function_field =  (void*)celt_mdct_radix2;
8420487a:	42 f0 01 f0 	rMAC = Null + 69207488;
8420487e:	c0 49 
84204880:	31 ae       	M[r4 + 64] = rMAC;
    celt_data->codec_data.celt_enc_mdct_short_function_field = (void*)celt_mdct_radix2;
84204882:	71 ae       	M[r4 + 68] = rMAC;
    celt_data->codec_data.celt_enc_mode_field = CELT_MODE;
84204884:	60 f0 9c 8e 	M[r4 + 624] = Null;

    /* Call the celt encoder init and init_tables functions. */

    celt_encode_lib_init(&(celt_data->encoder_data.codec));
84204888:	32 00       	r0 = r4 + Null;
8420488a:	db ff 36 ee 	call $_celt_encode_lib_init;
8420488e:	61 f0 a8 88 	rMAC = M[r4 + 672];
84204892:	f1 ff f0 ff 	if NE call $_celt_setup_thread_offload;
84204896:	2a ee 
    CELT_SETUP_OFFLOAD_IF_ENABLED();

#ifdef INSTALL_METADATA
    /* Get the sample rate and delay from the CELT internal data into the common decoder struct */
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
84204898:	31 b9       	rMAC = M[r4 + 112];
8420489a:	f1 8f       	M[r4 + 28] = rMAC;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
8420489c:	71 b9       	rMAC = M[r4 + 116];
8420489e:	31 9f       	M[r4 + 48] = rMAC;

842048a0 <Lc_celt_encode_create_16>:

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
    {
        free_data_and_fail(op_data, response_data);
        return TRUE;
842048a0:	42 20       	r0 = Null + 1;

842048a2 <Lc_celt_encode_create_17>:
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
#endif

    return TRUE;
}
842048a2:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842048a4:	d8 4c       	rts;

842048a6 <$_celt_enc_opmsg_set_encoding_params>:
    patch_fn_shared(celt_encode_wrapper);
    return encoder_buffer_details_core(op_data, message_data,response_id, response_data,CELT_ENCODE_OUTPUT_BUFFER_SIZE,CELT_ENCODE_OUTPUT_BUFFER_SIZE);
}

bool celt_enc_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842048a6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842048a8:	17 00       	r5 = r0 + Null;
842048aa:	1e 00       	r4 = r1 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842048ac:	ef fd de ff 	call (m) 0x4e6;
842048b0:	3b e1 
842048b2:	10 09       	r6 = r0 + Null;
bool celt_enc_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    CELT_ENC_OP_DATA *celt_data = get_instance_data(op_data);
    patch_fn_shared(celt_encode_wrapper);
   
    if (opmgr_op_is_running(op_data))
842048b4:	3a 00       	r0 = r5 + Null;
842048b6:	ff fd 07 f0 	call (m) 0x5700;
842048ba:	2b e2 
842048bc:	10 04       	Null = r0 - Null;
842048be:	03 60       	if EQ jump (m) Lc_celt_enc_opmsg_set_encoding_params_3;

842048c0 <Lc_celt_enc_opmsg_set_encoding_params_2>:
    {
     /* Can't change params while running */
       return (FALSE);
842048c0:	02 00       	r0 = Null + Null;
842048c2:	21 6e       	jump (m) Lc_celt_enc_opmsg_set_encoding_params_5;

842048c4 <Lc_celt_enc_opmsg_set_encoding_params_3>:
    }

    /* Check that the message recieved is the correct length. No checking for
     * stupid configurations though this might be nice to have. */
    if (OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data) != OPMSG_CELT_ENC_SET_ENCODING_PARAMS_WORD_SIZE)
842048c4:	71 88       	rMAC = M[r4 + 4];
842048c6:	08 25       	Null = rMAC - 4;
842048c8:	fc 63       	if NE jump (m) Lc_celt_enc_opmsg_set_encoding_params_2;

842048ca <Lc_celt_enc_opmsg_set_encoding_params_4>:
    {
        return FALSE;
    }

    /* Populate the CELT ENC  structure with the new fields */
    celt_data->codec_data.celt_enc_mode_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, MODE);
842048ca:	f1 88       	rMAC = M[r4 + 12];
842048cc:	89 c6       	rMAC = rMAC AND 0xffff;
842048ce:	81 f0 9c 8e 	M[r6 + 624] = rMAC;
    celt_data->codec_data.celt_codec_frame_size_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, FRAME_SIZE);
842048d2:	31 89       	rMAC = M[r4 + 16];
842048d4:	89 c6       	rMAC = rMAC AND 0xffff;
842048d6:	81 f0 0e 8e 	M[r6 + 56] = rMAC;
    celt_data->codec_data.celt_channels_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, CHANNELS);
842048da:	71 89       	rMAC = M[r4 + 20];
842048dc:	89 c6       	rMAC = rMAC AND 0xffff;
842048de:	81 f0 0f 8e 	M[r6 + 60] = rMAC;
    celt_encode_lib_init(&(celt_data->encoder_data.codec));
842048e2:	42 08       	r0 = r6 + Null;
842048e4:	db ff 3c eb 	call $_celt_encode_lib_init;
842048e8:	81 f0 a8 88 	rMAC = M[r6 + 672];
842048ec:	f1 ff f0 ff 	if NE call $_celt_setup_thread_offload;
842048f0:	30 eb 
    CELT_SETUP_OFFLOAD_IF_ENABLED();
#ifdef INSTALL_METADATA
    /* Get the sample rate and delay from the CELT internal data into the common decoder struct */
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
842048f2:	81 f0 1c 88 	rMAC = M[r6 + 112];
842048f6:	81 f0 07 8e 	M[r6 + 28] = rMAC;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
842048fa:	81 f0 1d 88 	rMAC = M[r6 + 116];
842048fe:	81 f0 0c 8e 	M[r6 + 48] = rMAC;
#endif
    return TRUE;
84204902:	42 20       	r0 = Null + 1;

84204904 <Lc_celt_enc_opmsg_set_encoding_params_5>:
}
84204904:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84204906:	d8 4c       	rts;

84204908 <$_celt_encode_free_data>:
 * celt_encode capability.
 *
 * \param op_data Pointer to the operator instance data.
 */
void celt_encode_free_data(OPERATOR_DATA *op_data)
{
84204908:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
8420490a:	ef fd dd ff 	call (m) 0x4e6;
8420490e:	3d ee 
84204910:	16 00       	r4 = r0 + Null;
    mem_table_free_shared((void *)(&(celt_data->codec_data)),
                    celt_enc_shared_malloc_table, CELT_ENC_SHARED_TABLE_LENGTH);
#endif

#ifdef CELT_ENCODE_OFFLOAD
    if (celt_data->offload_enabled)
84204912:	60 f0 a8 88 	Null = M[r4 + 672];
84204916:	0a 60       	if EQ jump (m) Lc_celt_encode_free_data_3;

84204918 <Lc_celt_encode_free_data_2>:
    {
        mem_table_free_shared((void *)(&(celt_data->codec_data)),
                                celt_enc_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
84204918:	84 20       	r2 = Null + 2;
8420491a:	07 f0 03 f0 	r1 = Null + 7347920;
8420491e:	d0 7a 
84204920:	32 39       	r0 = r4 + 52;
84204922:	ef fd e9 ff 	call (m) 0x1c5e;
84204926:	3d e9 
84204928:	09 6e       	jump (m) Lc_celt_encode_free_data_4;

8420492a <Lc_celt_encode_free_data_3>:
    }
    else
    {
        mem_table_free((void *)(&(celt_data->codec_data)),
                                celt_enc_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
8420492a:	84 20       	r2 = Null + 2;
8420492c:	07 f0 03 f0 	r1 = Null + 7347936;
84204930:	e0 7a 
84204932:	32 39       	r0 = r4 + 52;
84204934:	ef fd e9 ff 	call (m) 0x1c0c;
84204938:	39 e6 

8420493a <Lc_celt_encode_free_data_4>:
    }
#endif

    /* free non-shared memory */
    mem_table_free((void *)(&(celt_data->codec_data)), celt_enc_malloc_table,
                                                CELT_ENC_MALLOC_TABLE_LENGTH);
8420493a:	04 21       	r2 = Null + 4;
8420493c:	07 f0 03 f0 	r1 = Null + 7347896;
84204940:	b8 7a 
84204942:	32 39       	r0 = r4 + 52;
84204944:	ef fd e9 ff 	call (m) 0x1c0c;
84204948:	29 e6 
    
    celt_free_decoder_twiddle();
8420494a:	dc ff 32 e0 	call $_celt_free_decoder_twiddle;

8420494e <Lc_celt_encode_free_data_5>:


}
8420494e:	f1 48       	popm <FP, r4, rLink>;
84204950:	d8 4c       	rts;

84204952 <$_celt_encode_buffer_details>:
 * response
 */

bool celt_encode_buffer_details(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
84204952:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(celt_encode_wrapper);
    return encoder_buffer_details_core(op_data, message_data,response_id, response_data,CELT_ENCODE_OUTPUT_BUFFER_SIZE,CELT_ENCODE_OUTPUT_BUFFER_SIZE);
84204954:	04 f0 50 e0 	push Null + 1024;
84204958:	04 f0 50 e0 	push Null + 1024;
8420495c:	ff fd 92 f1 	call (m) 0x36da6;
84204960:	2b e2 
84204962:	7e 4c       	SP = SP + -8;

84204964 <Lc_celt_encode_buffer_details_2>:
}
84204964:	c8 48       	popm <FP, rLink>;
84204966:	d8 4c       	rts;

84204968 <$_celt_encode_frame_sizes>:
 * \param out_size_octets number of octets produced per frame
 * 
 * \return TRUE to say these are actual frames
 */
bool celt_encode_frame_sizes(OPERATOR_DATA *op_data, unsigned *in_size_samples, unsigned *out_size_octets)
{
84204968:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420496a:	1e 00       	r4 = r1 + Null;
8420496c:	27 00       	r5 = r2 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
8420496e:	ef fd dd ff 	call (m) 0x4e6;
84204972:	39 eb 
 * \return TRUE to say these are actual frames
 */
bool celt_encode_frame_sizes(OPERATOR_DATA *op_data, unsigned *in_size_samples, unsigned *out_size_octets)
{
    CELT_ENC_OP_DATA *celt_data = get_instance_data(op_data);
    *in_size_samples = celt_data->codec_data.celt_enc_mode_mdct_size_field;
84204974:	91 b9       	rMAC = M[r0 + 120];
84204976:	31 ee       	M[r4 + Null] = rMAC;
    *out_size_octets = celt_data->codec_data.celt_codec_frame_size_field;
84204978:	91 99       	rMAC = M[r0 + 56];
8420497a:	39 ee       	M[r5 + Null] = rMAC;

    return TRUE;
8420497c:	42 20       	r0 = Null + 1;

8420497e <Lc_celt_encode_frame_sizes_2>:
}
8420497e:	f2 48       	popm <FP, r4, r5, rLink>;
84204980:	d8 4c       	rts;

84204982 <$_celt_encode_connect>:
    return TRUE;
}

bool celt_encode_connect(OPERATOR_DATA *op_data, void *message_data,
                     unsigned *response_id, void **response_data)
{
84204982:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84204984:	16 00       	r4 = r0 + Null;
84204986:	19 09       	r7 = r1 + Null;
84204988:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
8420498a:	ef fd dd ff 	call (m) 0x558;
8420498e:	2f ee 
84204990:	10 09       	r6 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204992:	32 00       	r0 = r4 + Null;
84204994:	ef fd dd ff 	call (m) 0x4e6;
84204998:	33 ea 
8420499a:	17 00       	r5 = r0 + Null;
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420499c:	03 00       	r1 = Null + Null;
8420499e:	54 08       	r2 = r8 + Null;
842049a0:	32 00       	r0 = r4 + Null;
842049a2:	ef fd dd ff 	call (m) 0x4bc;
842049a6:	3b e8 
842049a8:	10 04       	Null = r0 - Null;
842049aa:	03 62       	if NE jump (m) Lc_celt_encode_connect_3;

842049ac <Lc_celt_encode_connect_2>:
    {
        return FALSE;
842049ac:	02 00       	r0 = Null + Null;
842049ae:	3c 6e       	jump (m) Lc_celt_encode_connect_17;

842049b0 <Lc_celt_encode_connect_3>:
    }
    
    /* We don't allow any connections or disconnections with the operator running */
    if (opmgr_op_is_running(op_data))
842049b0:	32 00       	r0 = r4 + Null;
842049b2:	ff fd 06 f0 	call (m) 0x5700;
842049b6:	2f ea 
842049b8:	10 04       	Null = r0 - Null;
842049ba:	08 60       	if EQ jump (m) Lc_celt_encode_connect_6;

842049bc <Lc_celt_encode_connect_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842049bc:	01 f0 00 60 	rMAC = Null + 4096;
842049c0:	a2 f0 00 e8 	r0 = M[r8 + Null];
842049c4:	51 8e       	M[r0 + 4] = rMAC;

842049c6 <Lc_celt_encode_connect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
842049c6:	42 20       	r0 = Null + 1;
842049c8:	2f 6e       	jump (m) Lc_celt_encode_connect_17;

842049ca <Lc_celt_encode_connect_6>:
    }

    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
842049ca:	91 f0 00 e8 	rMAC = M[r7 + Null];
842049ce:	15 60       	if EQ jump (m) Lc_celt_encode_connect_12;

842049d0 <Lc_celt_encode_connect_7>:
842049d0:	00 f2 10 f0 	Null = rMAC - 8388608;
842049d4:	00 24 
842049d6:	1c 60       	if EQ jump (m) Lc_celt_encode_connect_14;

842049d8 <Lc_celt_encode_connect_8>:
842049d8:	00 f2 10 f0 	Null = rMAC - 8388609;
842049dc:	01 24 
842049de:	f4 63       	if NE jump (m) Lc_celt_encode_connect_5;

842049e0 <Lc_celt_encode_connect_9>:
                }
            }
#endif /* INSTALL_METADATA */
            break;
        case RIGHT_IN_TERMINAL_ID:
            opx_data->clone_right_input =  (tCbuffer*)(((uintptr_t *)message_data)[1]);
842049e0:	91 f0 01 88 	rMAC = M[r7 + 4];
842049e4:	71 f0 a5 8e 	M[r5 + 660] = rMAC;
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == NULL)
842049e8:	82 f0 06 88 	r0 = M[r6 + 24];
842049ec:	ed 63       	if NE jump (m) Lc_celt_encode_connect_5;

842049ee <Lc_celt_encode_connect_10>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
842049ee:	8a 89       	r0 = M[rMAC + 24];
842049f0:	eb 61       	if EQ jump (m) Lc_celt_encode_connect_5;

842049f2 <Lc_celt_encode_connect_11>:
            {
                if (buff_has_metadata(opx_data->clone_right_input))
                {
                    encoder_data->metadata_ip_buffer = opx_data->clone_right_input;
842049f2:	81 f0 06 8e 	M[r6 + 24] = rMAC;
842049f6:	e8 6f       	jump (m) Lc_celt_encode_connect_5;

842049f8 <Lc_celt_encode_connect_12>:
    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
    {
        case OUTPUT_TERMINAL_ID:
            opx_data->clone_output = (tCbuffer*)(((uintptr_t *)message_data)[1]);
842049f8:	92 f0 01 88 	r0 = M[r7 + 4];
842049fc:	72 f0 a6 8e 	M[r5 + 664] = r0;
84204a00:	91 89       	rMAC = M[r0 + 24];
84204a02:	e2 61       	if EQ jump (m) Lc_celt_encode_connect_5;

84204a04 <Lc_celt_encode_connect_13>:
#ifdef INSTALL_METADATA
            if (buff_has_metadata(opx_data->clone_output))
            {
                cbuffer_set_usable_octets(opx_data->clone_output, ENCODED_DATA_OCTETS_IN_WORD);
84204a04:	03 21       	r1 = Null + 4;
84204a06:	ff fd 7c f0 	call (m) 0x1432e;
84204a0a:	29 e9 
84204a0c:	dd 6f       	jump (m) Lc_celt_encode_connect_5;

84204a0e <Lc_celt_encode_connect_14>:
            }
#endif
            break;
        case LEFT_IN_TERMINAL_ID:
            opx_data->clone_left_input =  (tCbuffer*)(((uintptr_t *)message_data)[1]);
84204a0e:	91 f0 01 88 	rMAC = M[r7 + 4];
84204a12:	71 f0 a4 8e 	M[r5 + 656] = rMAC;
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == NULL)
84204a16:	82 f0 06 88 	r0 = M[r6 + 24];
84204a1a:	d6 63       	if NE jump (m) Lc_celt_encode_connect_5;

84204a1c <Lc_celt_encode_connect_15>:
84204a1c:	8a 89       	r0 = M[rMAC + 24];
84204a1e:	d4 61       	if EQ jump (m) Lc_celt_encode_connect_5;

84204a20 <Lc_celt_encode_connect_16>:
            {
                if (buff_has_metadata(opx_data->clone_left_input))
                {
                    encoder_data->metadata_ip_buffer = opx_data->clone_left_input;
84204a20:	81 f0 06 8e 	M[r6 + 24] = rMAC;
84204a24:	d1 6f       	jump (m) Lc_celt_encode_connect_5;

84204a26 <Lc_celt_encode_connect_17>:
#endif /* INSTALL_METADATA */
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
84204a26:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84204a28:	d8 4c       	rts;

84204a2a <$_celt_encode_disconnect>:

bool celt_encode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                        unsigned *response_id, void **response_data)
{
84204a2a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84204a2c:	10 09       	r6 = r0 + Null;
84204a2e:	19 09       	r7 = r1 + Null;
84204a30:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84204a32:	ef fd dd ff 	call (m) 0x558;
84204a36:	27 e9 
84204a38:	17 00       	r5 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204a3a:	42 08       	r0 = r6 + Null;
84204a3c:	ef fd dd ff 	call (m) 0x4e6;
84204a40:	2b e5 
84204a42:	16 00       	r4 = r0 + Null;
bool celt_encode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                        unsigned *response_id, void **response_data)
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
84204a44:	99 f0 00 e8 	r7 = M[r7 + Null];

    /* Check that the operator is not running !*/
    if (opmgr_op_is_running(op_data))
84204a48:	42 08       	r0 = r6 + Null;
84204a4a:	ff fd 06 f0 	call (m) 0x5700;
84204a4e:	37 e5 
84204a50:	10 04       	Null = r0 - Null;
84204a52:	09 60       	if EQ jump (m) Lc_celt_encode_disconnect_3;

84204a54 <Lc_celt_encode_disconnect_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84204a54:	03 f0 00 60 	r1 = Null + 4096;
84204a58:	54 08       	r2 = r8 + Null;
84204a5a:	42 08       	r0 = r6 + Null;
84204a5c:	ef fd dd ff 	call (m) 0x4bc;
84204a60:	21 e3 
84204a62:	30 6e       	jump (m) Lc_celt_encode_disconnect_16;

84204a64 <Lc_celt_encode_disconnect_3>:
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204a64:	03 00       	r1 = Null + Null;
84204a66:	54 08       	r2 = r8 + Null;
84204a68:	42 08       	r0 = r6 + Null;
84204a6a:	ef fd dd ff 	call (m) 0x4bc;
84204a6e:	33 e2 
84204a70:	10 04       	Null = r0 - Null;
84204a72:	03 62       	if NE jump (m) Lc_celt_encode_disconnect_5;

84204a74 <Lc_celt_encode_disconnect_4>:
    {
        return FALSE;
84204a74:	02 00       	r0 = Null + Null;
84204a76:	26 6e       	jump (m) Lc_celt_encode_disconnect_16;

84204a78 <Lc_celt_encode_disconnect_5>:
    }

    switch (terminal_id)
84204a78:	0f f9 00 c2 	Null = r7 - Null;
84204a7c:	15 60       	if EQ jump (m) Lc_celt_encode_disconnect_12;

84204a7e <Lc_celt_encode_disconnect_6>:
84204a7e:	00 f2 90 f0 	Null = r7 - 8388608;
84204a82:	00 24 
84204a84:	14 60       	if EQ jump (m) Lc_celt_encode_disconnect_13;

84204a86 <Lc_celt_encode_disconnect_7>:
84204a86:	00 f2 90 f0 	Null = r7 - 8388609;
84204a8a:	01 24 
84204a8c:	0b 62       	if NE jump (m) Lc_celt_encode_disconnect_11;

84204a8e <Lc_celt_encode_disconnect_8>:
#endif /* INSTALL_METADATA */
            opx_data->clone_left_input = NULL;
            break;
        case RIGHT_IN_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == opx_data->clone_right_input)
84204a8e:	b9 89       	rMAC = M[r5 + 24];
84204a90:	62 f0 a5 88 	r0 = M[r4 + 660];
84204a94:	88 04       	Null = rMAC - r0;
84204a96:	04 62       	if NE jump (m) Lc_celt_encode_disconnect_10;

84204a98 <Lc_celt_encode_disconnect_9>:
            {
                /* If the left input is still connected, get metadata from there.
                 * If it's not, this will be NULL anyway.
                 */
                encoder_data->metadata_ip_buffer = opx_data->clone_left_input;
84204a98:	61 f0 a4 88 	rMAC = M[r4 + 656];
84204a9c:	b9 8f       	M[r5 + 24] = rMAC;

84204a9e <Lc_celt_encode_disconnect_10>:
            }
#endif /* INSTALL_METADATA */
            opx_data->clone_right_input = NULL;
84204a9e:	60 f0 a5 8e 	M[r4 + 660] = Null;

84204aa2 <Lc_celt_encode_disconnect_11>:
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
84204aa2:	42 20       	r0 = Null + 1;
84204aa4:	0f 6e       	jump (m) Lc_celt_encode_disconnect_16;

84204aa6 <Lc_celt_encode_disconnect_12>:
    }

    switch (terminal_id)
    {
        case OUTPUT_TERMINAL_ID:
            opx_data->clone_output = NULL;
84204aa6:	60 f0 a6 8e 	M[r4 + 664] = Null;
            break;
84204aaa:	fc 6f       	jump (m) Lc_celt_encode_disconnect_11;

84204aac <Lc_celt_encode_disconnect_13>:
        case LEFT_IN_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == opx_data->clone_left_input)
84204aac:	b9 89       	rMAC = M[r5 + 24];
84204aae:	62 f0 a4 88 	r0 = M[r4 + 656];
84204ab2:	88 04       	Null = rMAC - r0;
84204ab4:	04 62       	if NE jump (m) Lc_celt_encode_disconnect_15;

84204ab6 <Lc_celt_encode_disconnect_14>:
            {
                /* If the right input is still connected, get metadata from there.
                 * If it's not, this will be NULL anyway.
                 */
                encoder_data->metadata_ip_buffer = opx_data->clone_right_input;
84204ab6:	61 f0 a5 88 	rMAC = M[r4 + 660];
84204aba:	b9 8f       	M[r5 + 24] = rMAC;

84204abc <Lc_celt_encode_disconnect_15>:
            }
#endif /* INSTALL_METADATA */
            opx_data->clone_left_input = NULL;
84204abc:	60 f0 a4 8e 	M[r4 + 656] = Null;
            break;
84204ac0:	f1 6f       	jump (m) Lc_celt_encode_disconnect_11;

84204ac2 <Lc_celt_encode_disconnect_16>:
            opx_data->clone_right_input = NULL;
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
84204ac2:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84204ac4:	d8 4c       	rts;

84204ac6 <$_celt_encoder_start>:

#ifdef CELT_ENCODE_OFFLOAD

bool celt_encoder_start(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
84204ac6:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84204ac8:	16 00       	r4 = r0 + Null;
84204aca:	22 09       	r8 = r2 + Null;
84204acc:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84204ace:	ef fd dd ff 	call (m) 0x558;
84204ad2:	2b e4 
84204ad4:	10 09       	r6 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204ad6:	32 00       	r0 = r4 + Null;
84204ad8:	ef fd dd ff 	call (m) 0x4e6;
84204adc:	2f e0 
84204ade:	17 00       	r5 = r0 + Null;
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned buffer_flags;

    *response_id = OPCMD_START;
84204ae0:	81 20       	rMAC = Null + 2;
84204ae2:	a1 f0 00 ee 	M[r8 + Null] = rMAC;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204ae6:	03 00       	r1 = Null + Null;
84204ae8:	4c 08       	r2 = r7 + Null;
84204aea:	32 00       	r0 = r4 + Null;
84204aec:	ef fd dc ff 	call (m) 0x4bc;
84204af0:	31 ee 
84204af2:	10 04       	Null = r0 - Null;
84204af4:	03 62       	if NE jump (m) Lc_celt_encoder_start_3;

84204af6 <Lc_celt_encoder_start_2>:
    {
        return FALSE;
84204af6:	02 00       	r0 = Null + Null;
84204af8:	6f 6e       	jump (m) Lc_celt_encoder_start_10;

84204afa <Lc_celt_encoder_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84204afa:	32 00       	r0 = r4 + Null;
84204afc:	ff fd 06 f0 	call (m) 0x5700;
84204b00:	25 e0 
84204b02:	10 04       	Null = r0 - Null;
84204b04:	0c 62       	if NE jump (m) Lc_celt_encoder_start_7;

84204b06 <Lc_celt_encoder_start_4>:
        /* Operator already started nothing to do. */
        return TRUE;
    }

    /* 1st (left) source and output need to be connected. */
    if ((opx_data->clone_left_input == NULL)||(opx_data->clone_output == NULL))
84204b06:	71 f0 a4 88 	rMAC = M[r5 + 656];
84204b0a:	04 60       	if EQ jump (m) Lc_celt_encoder_start_6;

84204b0c <Lc_celt_encoder_start_5>:
84204b0c:	71 f0 a6 88 	rMAC = M[r5 + 664];
84204b10:	08 62       	if NE jump (m) Lc_celt_encoder_start_8;

84204b12 <Lc_celt_encoder_start_6>:
84204b12:	01 f0 00 60 	rMAC = Null + 4096;
84204b16:	92 f0 00 e8 	r0 = M[r7 + Null];
84204b1a:	51 8e       	M[r0 + 4] = rMAC;

84204b1c <Lc_celt_encoder_start_7>:
    }

    if (opmgr_op_is_running(op_data))
    {
        /* Operator already started nothing to do. */
        return TRUE;
84204b1c:	42 20       	r0 = Null + 1;
84204b1e:	5c 6e       	jump (m) Lc_celt_encoder_start_10;

84204b20 <Lc_celt_encoder_start_8>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

#ifdef INSTALL_METADATA
    encoder_data->last_tag_samples = LAST_TAG_SAMPLES_INVALID;
84204b20:	41 24       	rMAC = Null - 1;
84204b22:	81 f0 0a 8e 	M[r6 + 40] = rMAC;
    encoder_data->last_tag_err_offset_id = INFO_ID_INVALID;
84204b26:	80 f0 0b 8e 	M[r6 + 44] = Null;
#endif /* INSTALL_METADATA */

    /* Make copies of the connection buffers to give to the codec library
     * This runs asynchronously, so can't use the buffers visible externally 
     */
    buffer_flags = opx_data->clone_output->descriptor;
84204b2a:	72 f0 a6 88 	r0 = M[r5 + 664];
84204b2e:	56 89       	r4 = M[r0 + 20];
    encoder_data->codec.out_buffer = cbuffer_create( opx_data->clone_output->base_addr,
                    cbuffer_get_size_in_words(opx_data->clone_output), buffer_flags);
84204b30:	ff fd 7c f0 	call (m) 0x14450;
84204b34:	21 e9 
84204b36:	13 00       	r1 = r0 + Null;
84204b38:	71 f0 a6 88 	rMAC = M[r5 + 664];
84204b3c:	ca 88       	r0 = M[rMAC + 12];
84204b3e:	34 00       	r2 = r4 + Null;
84204b40:	ff fd 7b f0 	call (m) 0x1429c;
84204b44:	3d ea 
84204b46:	82 f0 00 ee 	M[r6 + Null] = r0;

    encoder_data->codec.out_buffer->read_ptr = opx_data->clone_output->read_ptr;
84204b4a:	71 f0 a6 88 	rMAC = M[r5 + 664];
84204b4e:	82 f0 00 e8 	r0 = M[r6 + Null];
84204b52:	49 88       	rMAC = M[rMAC + 4];
84204b54:	51 8e       	M[r0 + 4] = rMAC;
    encoder_data->codec.out_buffer->write_ptr = opx_data->clone_output->write_ptr;
84204b56:	71 f0 a6 88 	rMAC = M[r5 + 664];
84204b5a:	82 f0 00 e8 	r0 = M[r6 + Null];
84204b5e:	89 88       	rMAC = M[rMAC + 8];
84204b60:	91 8e       	M[r0 + 8] = rMAC;

    buffer_flags = opx_data->clone_left_input->descriptor;
84204b62:	72 f0 a4 88 	r0 = M[r5 + 656];
84204b66:	56 89       	r4 = M[r0 + 20];
    encoder_data->codec.in_left_buffer = cbuffer_create( opx_data->clone_left_input->base_addr,
                    cbuffer_get_size_in_words(opx_data->clone_left_input), buffer_flags);
84204b68:	ff fd 7c f0 	call (m) 0x14450;
84204b6c:	29 e7 
84204b6e:	13 00       	r1 = r0 + Null;
84204b70:	71 f0 a4 88 	rMAC = M[r5 + 656];
84204b74:	ca 88       	r0 = M[rMAC + 12];
84204b76:	34 00       	r2 = r4 + Null;
84204b78:	ff fd 7b f0 	call (m) 0x1429c;
84204b7c:	25 e9 
84204b7e:	82 f0 01 8e 	M[r6 + 4] = r0;

    encoder_data->codec.in_left_buffer->read_ptr = opx_data->clone_left_input->read_ptr;
84204b82:	71 f0 a4 88 	rMAC = M[r5 + 656];
84204b86:	82 f0 01 88 	r0 = M[r6 + 4];
84204b8a:	49 88       	rMAC = M[rMAC + 4];
84204b8c:	51 8e       	M[r0 + 4] = rMAC;
    encoder_data->codec.in_left_buffer->write_ptr = opx_data->clone_left_input->write_ptr;
84204b8e:	71 f0 a4 88 	rMAC = M[r5 + 656];
84204b92:	82 f0 01 88 	r0 = M[r6 + 4];
84204b96:	89 88       	rMAC = M[rMAC + 8];
84204b98:	91 8e       	M[r0 + 8] = rMAC;

    /* Right input does't need to be connected */
    if (opx_data->clone_right_input)
84204b9a:	72 f0 a5 88 	r0 = M[r5 + 660];
84204b9e:	bf 61       	if EQ jump (m) Lc_celt_encoder_start_7;

84204ba0 <Lc_celt_encoder_start_9>:
    {
        buffer_flags = opx_data->clone_right_input->descriptor;
84204ba0:	56 89       	r4 = M[r0 + 20];
        encoder_data->codec.in_right_buffer = cbuffer_create( opx_data->clone_right_input->base_addr,
                        cbuffer_get_size_in_words(opx_data->clone_right_input), buffer_flags);
84204ba2:	ff fd 7c f0 	call (m) 0x14450;
84204ba6:	2f e5 
84204ba8:	13 00       	r1 = r0 + Null;
84204baa:	71 f0 a5 88 	rMAC = M[r5 + 660];
84204bae:	ca 88       	r0 = M[rMAC + 12];
84204bb0:	34 00       	r2 = r4 + Null;
84204bb2:	ff fd 7b f0 	call (m) 0x1429c;
84204bb6:	2b e7 
84204bb8:	82 f0 02 8e 	M[r6 + 8] = r0;

        encoder_data->codec.in_right_buffer->read_ptr = opx_data->clone_right_input->read_ptr;
84204bbc:	71 f0 a5 88 	rMAC = M[r5 + 660];
84204bc0:	82 f0 02 88 	r0 = M[r6 + 8];
84204bc4:	49 88       	rMAC = M[rMAC + 4];
84204bc6:	51 8e       	M[r0 + 4] = rMAC;
        encoder_data->codec.in_right_buffer->write_ptr = opx_data->clone_right_input->write_ptr;
84204bc8:	71 f0 a5 88 	rMAC = M[r5 + 660];
84204bcc:	82 f0 02 88 	r0 = M[r6 + 8];
84204bd0:	89 88       	rMAC = M[rMAC + 8];
84204bd2:	91 8e       	M[r0 + 8] = rMAC;
84204bd4:	a4 6f       	jump (m) Lc_celt_encoder_start_7;

84204bd6 <Lc_celt_encoder_start_10>:
    }
    return TRUE;
}
84204bd6:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84204bd8:	d8 4c       	rts;

84204bda <$_celt_encoder_stop_reset>:

bool celt_encoder_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84204bda:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84204bdc:	17 00       	r5 = r0 + Null;
84204bde:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84204be0:	ef fd dc ff 	call (m) 0x558;
84204be4:	39 eb 
84204be6:	10 09       	r6 = r0 + Null;
}

bool celt_encoder_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
84204be8:	3a 00       	r0 = r5 + Null;
84204bea:	ef fd dc ff 	call (m) 0x4f0;
84204bee:	27 e8 
84204bf0:	16 00       	r4 = r0 + Null;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204bf2:	03 00       	r1 = Null + Null;
84204bf4:	4c 08       	r2 = r7 + Null;
84204bf6:	3a 00       	r0 = r5 + Null;
84204bf8:	ef fd dc ff 	call (m) 0x4bc;
84204bfc:	25 e6 
84204bfe:	10 04       	Null = r0 - Null;
84204c00:	03 62       	if NE jump (m) Lc_celt_encoder_stop_reset_3;

84204c02 <Lc_celt_encoder_stop_reset_2>:
    {
        return FALSE;
84204c02:	02 00       	r0 = Null + Null;
84204c04:	21 6e       	jump (m) Lc_celt_encoder_stop_reset_6;

84204c06 <Lc_celt_encoder_stop_reset_3>:
    }

    /* Mark the operator as stopped. */
    base_op_stop_operator(op_data);
84204c06:	3a 00       	r0 = r5 + Null;
84204c08:	ef fd dc ff 	call (m) 0x54a;
84204c0c:	23 ea 

84204c0e <Lc_celt_encoder_stop_reset_4>:

    /* Wait for any processing to finish */
    while (audio_thread_rpc_is_queued(opid));
84204c0e:	32 00       	r0 = r4 + Null;
84204c10:	ff fd 79 f0 	call (m) 0x13f5e;
84204c14:	2f ea 
84204c16:	10 04       	Null = r0 - Null;
84204c18:	fb 63       	if NE jump (m) Lc_celt_encoder_stop_reset_4;

84204c1a <Lc_celt_encoder_stop_reset_5>:

    /* Free the buffers that were allocated in the start handler */
    cbuffer_destroy_struct(encoder_data->codec.out_buffer);
84204c1a:	82 f0 00 e8 	r0 = M[r6 + Null];
84204c1e:	ff fd 7b f0 	call (m) 0x143cc;
84204c22:	2f ed 
    encoder_data->codec.out_buffer = NULL;
84204c24:	80 f0 00 ee 	M[r6 + Null] = Null;

    cbuffer_destroy_struct(encoder_data->codec.in_left_buffer);
84204c28:	82 f0 01 88 	r0 = M[r6 + 4];
84204c2c:	ff fd 7b f0 	call (m) 0x143cc;
84204c30:	21 ed 
    encoder_data->codec.in_left_buffer = NULL;
84204c32:	80 f0 01 8e 	M[r6 + 4] = Null;

    cbuffer_destroy_struct(encoder_data->codec.in_right_buffer);
84204c36:	82 f0 02 88 	r0 = M[r6 + 8];
84204c3a:	ff fd 7b f0 	call (m) 0x143cc;
84204c3e:	33 ec 
    encoder_data->codec.in_right_buffer = NULL;
84204c40:	80 f0 02 8e 	M[r6 + 8] = Null;

    return TRUE;
84204c44:	42 20       	r0 = Null + 1;

84204c46 <Lc_celt_encoder_stop_reset_6>:
}
84204c46:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84204c48:	d8 4c       	rts;

84204c4a <$_celt_encode_process_data>:
        opmgr_kick_operator(op_data);
    }
}

void celt_encode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84204c4a:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84204c4c:	57 4c       	SP = SP + 92;
84204c4e:	12 09       	r8 = r0 + Null;
84204c50:	43 de       	M[FP + 32] = r1;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84204c52:	ef fd dc ff 	call (m) 0x558;
84204c56:	27 e8 
84204c58:	11 09       	r7 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204c5a:	52 08       	r0 = r8 + Null;
84204c5c:	ef fd dc ff 	call (m) 0x4e6;
84204c60:	2b e4 
84204c62:	17 00       	r5 = r0 + Null;

void celt_encode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
    ENCODER_PARAMS *enc_base = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
84204c64:	52 08       	r0 = r8 + Null;
84204c66:	ef fd dc ff 	call (m) 0x4f0;
84204c6a:	2b e4 
    const ENCODER_CAP_VIRTUAL_TABLE *vt = enc_base->vt;
84204c6c:	9b f0 05 88 	r9 = M[r7 + 20];
84204c70:	c1 f1 1d 40 	rMAC = Null + 229405;
84204c74:	9a de       	M[FP + 76] = r0;
84204c76:	a1 de       	M[FP + 80] = rMAC;
84204c78:	e9 f0 15 8e 	M[FP + 84] = r7;
84204c7c:	b1 f0 00 e8 	rMAC = M[r9 + Null];
84204c80:	b1 de       	M[FP + 88] = rMAC;
84204c82:	b8 de       	M[FP + 92] = Null;
84204c84:	42 f0 21 f0 	rMAC = Null + 69226277;
84204c88:	25 5b 
84204c8a:	c0 de       	M[FP + 96] = Null;
84204c8c:	c9 de       	M[FP + 100] = rMAC;
84204c8e:	ea f0 1a 8e 	M[FP + 104] = r8;
    };

    patch_fn(encoder_process_data);


    if (audio_thread_rpc_is_queued(opid))
84204c92:	ff fd 79 f0 	call (m) 0x13f5e;
84204c96:	2d e6 
84204c98:	10 04       	Null = r0 - Null;
84204c9a:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_3;

84204c9c <Lc_celt_encode_process_data_2>:
    {
        /* RPC is busy, try again later */
        opx_data->kicks_pending = TRUE;
84204c9c:	41 20       	rMAC = Null + 1;
84204c9e:	71 f0 a7 8e 	M[r5 + 668] = rMAC;
        return;
84204ca2:	0f f0 e9 e4 	jump (m) Lc_celt_encode_process_data_44;

84204ca6 <Lc_celt_encode_process_data_3>:
    }

    ip_offset_pre_enc = cbuffer_get_read_offset(opx_data->clone_left_input);
84204ca6:	72 f0 a4 88 	r0 = M[r5 + 656];
84204caa:	ff fd 7b f0 	call (m) 0x143f0;
84204cae:	27 ea 
84204cb0:	10 09       	r6 = r0 + Null;

    opx_data->clone_left_input->read_ptr = enc_base->codec.in_left_buffer->read_ptr;
84204cb2:	91 f0 01 88 	rMAC = M[r7 + 4];
84204cb6:	72 f0 a4 88 	r0 = M[r5 + 656];
84204cba:	49 88       	rMAC = M[rMAC + 4];
84204cbc:	51 8e       	M[r0 + 4] = rMAC;
    opx_data->clone_right_input->read_ptr = enc_base->codec.in_right_buffer->read_ptr;
84204cbe:	91 f0 02 88 	rMAC = M[r7 + 8];
84204cc2:	72 f0 a5 88 	r0 = M[r5 + 660];
84204cc6:	49 88       	rMAC = M[rMAC + 4];
84204cc8:	51 8e       	M[r0 + 4] = rMAC;
    opx_data->clone_output->write_ptr = enc_base->codec.out_buffer->write_ptr;
84204cca:	91 f0 00 e8 	rMAC = M[r7 + Null];
84204cce:	72 f0 a6 88 	r0 = M[r5 + 664];
84204cd2:	89 88       	rMAC = M[rMAC + 8];
84204cd4:	91 8e       	M[r0 + 8] = rMAC;

    enc_base->codec.in_left_buffer->write_ptr = opx_data->clone_left_input->write_ptr;
84204cd6:	71 f0 a4 88 	rMAC = M[r5 + 656];
84204cda:	92 f0 01 88 	r0 = M[r7 + 4];
84204cde:	89 88       	rMAC = M[rMAC + 8];
84204ce0:	91 8e       	M[r0 + 8] = rMAC;
    enc_base->codec.in_right_buffer->write_ptr = opx_data->clone_right_input->write_ptr;
84204ce2:	71 f0 a5 88 	rMAC = M[r5 + 660];
84204ce6:	92 f0 02 88 	r0 = M[r7 + 8];
84204cea:	89 88       	rMAC = M[rMAC + 8];
84204cec:	91 8e       	M[r0 + 8] = rMAC;

    if ((BUF_DESC_IN_PLACE(opx_data->clone_output->descriptor) != 0) && (opx_data->clone_output->aux_ptr != NULL))
84204cee:	72 f0 a6 88 	r0 = M[r5 + 664];
84204cf2:	51 89       	rMAC = M[r0 + 20];
84204cf4:	c9 c6       	rMAC = rMAC AND 0x10000;
84204cf6:	08 60       	if EQ jump (m) Lc_celt_encode_process_data_6;

84204cf8 <Lc_celt_encode_process_data_4>:
84204cf8:	11 89       	rMAC = M[r0 + 16];
84204cfa:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_6;

84204cfc <Lc_celt_encode_process_data_5>:
    {
        tCbuffer *tail = (tCbuffer *)opx_data->clone_output->aux_ptr;
        enc_base->codec.out_buffer->read_ptr = tail->read_ptr;
84204cfc:	49 88       	rMAC = M[rMAC + 4];
84204cfe:	92 f0 00 e8 	r0 = M[r7 + Null];
84204d02:	51 8e       	M[r0 + 4] = rMAC;
84204d04:	05 6e       	jump (m) Lc_celt_encode_process_data_7;

84204d06 <Lc_celt_encode_process_data_6>:
    }
    else
    {
        enc_base->codec.out_buffer->read_ptr = opx_data->clone_output->read_ptr;
84204d06:	51 88       	rMAC = M[r0 + 4];
84204d08:	92 f0 00 e8 	r0 = M[r7 + Null];
84204d0c:	51 8e       	M[r0 + 4] = rMAC;

84204d0e <Lc_celt_encode_process_data_7>:
    }

    ip_offset_post_enc = cbuffer_get_read_offset(enc_base->codec.in_left_buffer);
84204d0e:	92 f0 01 88 	r0 = M[r7 + 4];
84204d12:	ff fd 7b f0 	call (m) 0x143f0;
84204d16:	3f e6 
84204d18:	16 00       	r4 = r0 + Null;

    if (opx_data->offload_enabled)
84204d1a:	70 f0 a8 88 	Null = M[r5 + 672];
84204d1e:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_9;

84204d20 <Lc_celt_encode_process_data_8>:
    {
        thread_offload_queue_rpc(&rpc_data);
84204d20:	c2 14       	r0 = FP + 76;
84204d22:	ff fd 79 f0 	call (m) 0x13fa6;
84204d26:	25 e4 
84204d28:	07 6e       	jump (m) Lc_celt_encode_process_data_10;

84204d2a <Lc_celt_encode_process_data_9>:
    }
    else
    {
        encoder_encode(&(enc_base->codec), vt->encode_fn);
84204d2a:	b3 f0 00 e8 	r1 = M[r9 + Null];
84204d2e:	4a 08       	r0 = r7 + Null;
84204d30:	ff fd 99 f1 	call (m) 0x3801c;
84204d34:	2d e7 

84204d36 <Lc_celt_encode_process_data_10>:
    }

    /* total data processed on the input */
    if (ip_offset_post_enc >= ip_offset_pre_enc)
84204d36:	8f f6 00 c2 	Null = r4 - r6;
84204d3a:	04 64       	if NC jump (m) Lc_celt_encode_process_data_12;

84204d3c <Lc_celt_encode_process_data_11>:
    {
        ip_proc_data = ip_offset_post_enc - ip_offset_pre_enc;
84204d3c:	00 f8 36 c2 	r4 = r4 - r6;
84204d40:	09 6e       	jump (m) Lc_celt_encode_process_data_13;

84204d42 <Lc_celt_encode_process_data_12>:
    }
    else
    {
        unsigned buffsize = cbuffer_get_size_in_words(enc_base->codec.in_left_buffer);
84204d42:	92 f0 01 88 	r0 = M[r7 + 4];
84204d46:	ff fd 7b f0 	call (m) 0x14450;
84204d4a:	2b e8 
        ip_proc_data = buffsize + ip_offset_post_enc - ip_offset_pre_enc;
84204d4c:	91 01       	rMAC = r0 + r4;
84204d4e:	8f f1 06 c2 	r4 = rMAC - r6;

84204d52 <Lc_celt_encode_process_data_13>:
    }

    if (ip_proc_data > 0)
84204d52:	30 04       	Null = r4 - Null;
84204d54:	db 60       	if EQ jump (m) Lc_celt_encode_process_data_44;

84204d56 <Lc_celt_encode_process_data_14>:
        unsigned b4idx, afteridx;
        metadata_tag *mtag_ip, *mtag_ip_list;
        metadata_tag *mtag;
        tCbuffer *src, *dst;
        unsigned frame, frame_count, frame_len_enc_octets, frame_len_samples;
        unsigned new_ttp, base_ttp = 0, sample_offset = 0;
84204d56:	48 de       	M[FP + 36] = Null;
84204d58:	50 de       	M[FP + 40] = Null;
        bool framed_data;
        ttp_status status;

        src = enc_base->metadata_ip_buffer;
84204d5a:	98 f0 06 88 	r6 = M[r7 + 24];
        dst = opx_data->clone_output;
84204d5e:	71 f0 a6 88 	rMAC = M[r5 + 664];
84204d62:	59 de       	M[FP + 44] = rMAC;
        ip_proc_data_octets = ip_proc_data * OCTETS_PER_SAMPLE;
84204d64:	77 54       	r5 = r4 LSHIFT 2;

        framed_data = vt->frame_size_fn(op_data, &frame_len_samples, &frame_len_enc_octets);
84204d66:	b1 f0 03 88 	rMAC = M[r9 + 12];
84204d6a:	c4 13       	r2 = FP + 60;
84204d6c:	03 14       	r1 = FP + 64;
84204d6e:	52 08       	r0 = r8 + Null;
84204d70:	d1 4c       	call rMAC;

        if (framed_data)
84204d72:	10 04       	Null = r0 - Null;
84204d74:	08 60       	if EQ jump (m) Lc_celt_encode_process_data_16;

84204d76 <Lc_celt_encode_process_data_15>:
        {
            /* Data is framed, so handle multiple output frames if necessary */
            frame_count = ip_proc_data / frame_len_samples;
84204d76:	83 d8       	r1 = M[FP + 64];
84204d78:	32 00       	r0 = r4 + Null;
84204d7a:	ff fd aa f0 	call (m) 0x1a290;
84204d7e:	37 e8 
84204d80:	13 09       	r9 = r0 + Null;
84204d82:	0b 6e       	jump (m) Lc_celt_encode_process_data_17;

84204d84 <Lc_celt_encode_process_data_16>:
        }
        else
        {
            /* Treat whatever was produced as a single "frame" */
            frame_count = 1;
84204d84:	0b 71       	r9 = Null + 1;
            frame_len_enc_octets = frame_len_enc_octets * (ip_proc_data / frame_len_samples);
84204d86:	83 d8       	r1 = M[FP + 64];
84204d88:	32 00       	r0 = r4 + Null;
84204d8a:	ff fd aa f0 	call (m) 0x1a290;
84204d8e:	27 e8 
84204d90:	79 d8       	rMAC = M[FP + 60];
84204d92:	89 1a       	rMAC = rMAC * r0 (int);
84204d94:	79 de       	M[FP + 60] = rMAC;
            frame_len_samples = ip_proc_data;
84204d96:	86 de       	M[FP + 64] = r4;

84204d98 <Lc_celt_encode_process_data_17>:
        }

        /* Extract metadata tag from input */
        mtag_ip_list = buff_metadata_remove(src, ip_proc_data_octets, &b4idx, &afteridx);
84204d98:	85 13       	r3 = FP + 56;
84204d9a:	44 13       	r2 = FP + 52;
84204d9c:	3b 00       	r1 = r5 + Null;
84204d9e:	42 08       	r0 = r6 + Null;
84204da0:	ff fd 7e f0 	call (m) 0x149ca;
84204da4:	2b e1 
84204da6:	62 de       	M[FP + 48] = r0;
84204da8:	17 00       	r5 = r0 + Null;

84204daa <Lc_celt_encode_process_data_18>:

        /* Find the first timestamped tag */
        mtag_ip = mtag_ip_list;
        while ((mtag_ip != NULL) && (!IS_TIMESTAMPED_TAG(mtag_ip)))
84204daa:	38 04       	Null = r5 - Null;
84204dac:	2b 60       	if EQ jump (m) Lc_celt_encode_process_data_26;

84204dae <Lc_celt_encode_process_data_19>:
84204dae:	79 88       	rMAC = M[r5 + 4];
84204db0:	12 f0 30 00 	r0 = rMAC AND 0x30;
84204db4:	03 60       	if EQ jump (m) Lc_celt_encode_process_data_21;

84204db6 <Lc_celt_encode_process_data_20>:
84204db6:	c9 c2       	rMAC = rMAC AND 0x40;
84204db8:	07 60       	if EQ jump (m) Lc_celt_encode_process_data_22;

84204dba <Lc_celt_encode_process_data_21>:
        {
            b4idx += mtag_ip->length;
84204dba:	f9 88       	rMAC = M[r5 + 12];
84204dbc:	6a d8       	r0 = M[FP + 52];
84204dbe:	51 00       	rMAC = r0 + rMAC;
84204dc0:	69 de       	M[FP + 52] = rMAC;
            mtag_ip = mtag_ip->next;
84204dc2:	3f e8       	r5 = M[r5 + Null];
84204dc4:	f3 6f       	jump (m) Lc_celt_encode_process_data_18;

84204dc6 <Lc_celt_encode_process_data_22>:
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84204dc6:	68 d8       	Null = M[FP + 52];
84204dc8:	1d 62       	if NE jump (m) Lc_celt_encode_process_data_26;

84204dca <Lc_celt_encode_process_data_23>:
        {
            /* If the old tag is already at the start of the encoded frame,
             * Just use its timestamp directly
             */
            base_ttp = mtag_ip->timestamp;
84204dca:	39 89       	rMAC = M[r5 + 16];
84204dcc:	49 de       	M[FP + 36] = rMAC;
            sample_offset = 0;
84204dce:	50 de       	M[FP + 40] = Null;

84204dd0 <Lc_celt_encode_process_data_24>:
        if (mtag_ip != NULL)
        {
            unsigned *err_offset_id;
            unsigned length;
            /* Save the timestamp info from the incoming metadata */
            enc_base->last_tag_timestamp = mtag_ip->timestamp;
84204dd0:	39 89       	rMAC = M[r5 + 16];
84204dd2:	91 f0 08 8e 	M[r7 + 32] = rMAC;
            enc_base->last_tag_spa = mtag_ip->sp_adjust;
84204dd6:	79 89       	rMAC = M[r5 + 20];
84204dd8:	91 f0 09 8e 	M[r7 + 36] = rMAC;
            enc_base->last_tag_samples = ip_proc_data - (b4idx / OCTETS_PER_SAMPLE);
84204ddc:	6a d8       	r0 = M[FP + 52];
84204dde:	52 50       	r0 = r0 LSHIFT -2;
84204de0:	b1 04       	rMAC = r4 - r0;
84204de2:	91 f0 0a 8e 	M[r7 + 40] = rMAC;
            if (buff_metadata_find_private_data(mtag_ip, META_PRIV_KEY_TTP_OFFSET, &length, (void **)&err_offset_id))
84204de6:	45 14       	r3 = FP + 68;
84204de8:	84 14       	r2 = FP + 72;
84204dea:	43 20       	r1 = Null + 1;
84204dec:	3a 00       	r0 = r5 + Null;
84204dee:	ff fd 7c f0 	call (m) 0x14762;
84204df2:	35 eb 
84204df4:	10 04       	Null = r0 - Null;
84204df6:	20 60       	if EQ jump (m) Lc_celt_encode_process_data_32;

84204df8 <Lc_celt_encode_process_data_25>:
            {
                enc_base->last_tag_err_offset_id = (*err_offset_id);
84204df8:	89 d8       	rMAC = M[FP + 68];
84204dfa:	09 e8       	rMAC = M[rMAC + Null];
84204dfc:	91 f0 0b 8e 	M[r7 + 44] = rMAC;
84204e00:	10 6e       	jump (m) Lc_celt_encode_process_data_31;

84204e02 <Lc_celt_encode_process_data_26>:
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp.
             * There had better be one ! */
            if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84204e02:	91 f0 0a 88 	rMAC = M[r7 + 40];
84204e06:	48 20       	Null = rMAC + 1;
84204e08:	05 60       	if EQ jump (m) Lc_celt_encode_process_data_28;

84204e0a <Lc_celt_encode_process_data_27>:
            {
                base_ttp = enc_base->last_tag_timestamp;
84204e0a:	92 f0 08 88 	r0 = M[r7 + 32];
84204e0e:	4a de       	M[FP + 36] = r0;
                sample_offset = enc_base->last_tag_samples;
84204e10:	51 de       	M[FP + 40] = rMAC;

84204e12 <Lc_celt_encode_process_data_28>:
            }
        }

        if (mtag_ip != NULL)
84204e12:	38 04       	Null = r5 - Null;
84204e14:	de 63       	if NE jump (m) Lc_celt_encode_process_data_24;

84204e16 <Lc_celt_encode_process_data_29>:
                enc_base->last_tag_err_offset_id = INFO_ID_INVALID;
            }
        }
        else
        {
            if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84204e16:	48 20       	Null = rMAC + 1;
84204e18:	04 60       	if EQ jump (m) Lc_celt_encode_process_data_31;

84204e1a <Lc_celt_encode_process_data_30>:
            {
                enc_base->last_tag_samples += ip_proc_data;
84204e1a:	71 00       	rMAC = r4 + rMAC;
84204e1c:	91 f0 0a 8e 	M[r7 + 40] = rMAC;

84204e20 <Lc_celt_encode_process_data_31>:
            }
        }

        status.sp_adjustment = enc_base->last_tag_spa;
84204e20:	91 f0 09 88 	rMAC = M[r7 + 36];
84204e24:	e1 de       	M[FP + 112] = rMAC;
        status.err_offset_id = enc_base->last_tag_err_offset_id;
84204e26:	91 f0 0b 88 	rMAC = M[r7 + 44];
84204e2a:	e9 de       	M[FP + 116] = rMAC;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);
84204e2c:	79 88       	rMAC = M[r5 + 4];
84204e2e:	09 c0       	rMAC = rMAC AND 0x1;
84204e30:	f1 de       	M[FP + 120] = rMAC;

        /* Create new tags for each output frame */
        for (frame = 0; frame < frame_count; frame++)
84204e32:	07 00       	r5 = Null + Null;
84204e34:	1b 6e       	jump (m) Lc_celt_encode_process_data_36;

84204e36 <Lc_celt_encode_process_data_32>:
            {
                enc_base->last_tag_err_offset_id = (*err_offset_id);
            }
            else
            {
                enc_base->last_tag_err_offset_id = INFO_ID_INVALID;
84204e36:	90 f0 0b 8e 	M[r7 + 44] = Null;
84204e3a:	f3 6f       	jump (m) Lc_celt_encode_process_data_31;

84204e3c <Lc_celt_encode_process_data_33>:
                    L2_DBG_MSG1("Encoder op 0x%04x last tag samples invalid", base_op_get_ext_op_id(op_data));
                }
            }
            else
            {
                L2_DBG_MSG1("Encoder op 0x%04x failed to allocate tag", base_op_get_ext_op_id(op_data));
84204e3c:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84204e40:	88 24       	Null = rMAC - 2;
84204e42:	0c 68       	if LT jump (m) Lc_celt_encode_process_data_35;

84204e44 <Lc_celt_encode_process_data_34>:
84204e44:	52 08       	r0 = r8 + Null;
84204e46:	ef fd db ff 	call (m) 0x4f4;
84204e4a:	2f e5 
84204e4c:	13 00       	r1 = r0 + Null;
84204e4e:	55 f1 02 f0 	r0 = Null + 357564493;
84204e52:	4d 40 
84204e54:	ef fd df ff 	call (m) 0xcde;
84204e58:	2b e4 

84204e5a <Lc_celt_encode_process_data_35>:
            }

            buff_metadata_append(dst, mtag, 0, frame_len_enc_octets);
84204e5a:	7d d8       	r3 = M[FP + 60];
84204e5c:	04 00       	r2 = Null + Null;
84204e5e:	33 00       	r1 = r4 + Null;
84204e60:	5a d8       	r0 = M[FP + 44];
84204e62:	ff fd 7c f0 	call (m) 0x147b8;
84204e66:	37 ea 
        status.sp_adjustment = enc_base->last_tag_spa;
        status.err_offset_id = enc_base->last_tag_err_offset_id;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);

        /* Create new tags for each output frame */
        for (frame = 0; frame < frame_count; frame++)
84204e68:	7f 20       	r5 = r5 + 1;

84204e6a <Lc_celt_encode_process_data_36>:
84204e6a:	bf f7 00 c2 	Null = r5 - r9;
84204e6e:	02 f0 81 e1 	if C jump (m) Lc_celt_encode_process_data_42;

84204e72 <Lc_celt_encode_process_data_37>:
        {
            mtag = buff_metadata_new_tag();
84204e72:	ff fd 7b f0 	call (m) 0x1454e;
84204e76:	3d e6 
84204e78:	16 00       	r4 = r0 + Null;

            if (mtag != NULL)
84204e7a:	e1 61       	if EQ jump (m) Lc_celt_encode_process_data_33;

84204e7c <Lc_celt_encode_process_data_38>:
            {
                mtag->length = frame_len_enc_octets;
84204e7c:	79 d8       	rMAC = M[FP + 60];
84204e7e:	f1 8e       	M[r4 + 12] = rMAC;
                METADATA_PACKET_START_SET(mtag);
84204e80:	71 88       	rMAC = M[r4 + 4];
84204e82:	c9 c8       	rMAC = rMAC OR 0x4;
                METADATA_PACKET_END_SET(mtag);
84204e84:	49 c9       	rMAC = rMAC OR 0x8;
84204e86:	71 8e       	M[r4 + 4] = rMAC;

                if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84204e88:	91 f0 0a 88 	rMAC = M[r7 + 40];
84204e8c:	48 20       	Null = rMAC + 1;
84204e8e:	20 60       	if EQ jump (m) Lc_celt_encode_process_data_40;

84204e90 <Lc_celt_encode_process_data_39>:
                {
                    /* Calculate new TTP from incoming data and sample offset */
                    new_ttp = ttp_get_next_timestamp(base_ttp, sample_offset + frame * frame_len_samples,
                        enc_base->sample_rate, enc_base->last_tag_spa);
84204e90:	95 f0 09 88 	r3 = M[r7 + 36];
84204e94:	94 f0 07 88 	r2 = M[r7 + 28];
84204e98:	81 d8       	rMAC = M[FP + 64];
84204e9a:	52 d8       	r0 = M[FP + 40];
84204e9c:	c9 1b       	rMAC = rMAC * r5 (int);
84204e9e:	8b 00       	r1 = rMAC + r0;
84204ea0:	4a d8       	r0 = M[FP + 36];
84204ea2:	ff fd a6 f0 	call (m) 0x19b02;
84204ea6:	21 e3 
84204ea8:	10 09       	r6 = r0 + Null;
                    new_ttp = time_sub(new_ttp, convert_samples_to_time(enc_base->delay_samples, enc_base->sample_rate));
84204eaa:	93 f0 07 88 	r1 = M[r7 + 28];
84204eae:	92 f0 0c 88 	r0 = M[r7 + 48];
84204eb2:	ff fd 9a f0 	call (m) 0x183fe;
84204eb6:	2d ea 
84204eb8:	00 f2 38 c2 	r6 = r6 - r0;
                    status.ttp = new_ttp;
84204ebc:	e8 f0 1b 8e 	M[FP + 108] = r6;
                    ttp_utils_populate_tag(mtag, &status);
84204ec0:	c3 16       	r1 = FP + 108;
84204ec2:	32 00       	r0 = r4 + Null;
84204ec4:	ef fd de ff 	call (m) 0xbe6;
84204ec8:	23 e9 
                    status.stream_restart = FALSE;
84204eca:	f0 de       	M[FP + 120] = Null;
84204ecc:	c7 6f       	jump (m) Lc_celt_encode_process_data_35;

84204ece <Lc_celt_encode_process_data_40>:
                }
                else
                {
                    L2_DBG_MSG1("Encoder op 0x%04x last tag samples invalid", base_op_get_ext_op_id(op_data));
84204ece:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84204ed2:	88 24       	Null = rMAC - 2;
84204ed4:	c3 69       	if LT jump (m) Lc_celt_encode_process_data_35;

84204ed6 <Lc_celt_encode_process_data_41>:
84204ed6:	52 08       	r0 = r8 + Null;
84204ed8:	ef fd db ff 	call (m) 0x4f4;
84204edc:	3d e0 
84204ede:	13 00       	r1 = r0 + Null;
84204ee0:	55 f1 02 f0 	r0 = Null + 357564450;
84204ee4:	22 40 
84204ee6:	ef fd de ff 	call (m) 0xcde;
84204eea:	39 ef 
84204eec:	b7 6f       	jump (m) Lc_celt_encode_process_data_35;

84204eee <Lc_celt_encode_process_data_42>:
            buff_metadata_add_private_data(mtag, META_PRIV_KEY_USER_DATA, sizeof(unsigned), &frame_len_samples);
#endif
        }

        /* Free all the incoming tags */
        buff_metadata_tag_list_delete(mtag_ip_list);
84204eee:	62 d8       	r0 = M[FP + 48];
84204ef0:	ff fd 7b f0 	call (m) 0x145ee;
84204ef4:	3f e7 
#else
        NOT_USED(ip_proc_data);
#endif      /* INSTALL_METADATA */

        /* It ran and produced output so kick forwards */
        touched->sources = TOUCHED_SOURCE_0;
84204ef6:	41 20       	rMAC = Null + 1;
84204ef8:	42 d8       	r0 = M[FP + 32];
84204efa:	11 ee       	M[r0 + Null] = rMAC;

        /* If input data was stopped us running again then kick back to get some more */
        if (enc_base->codec.mode == CODEC_NOT_ENOUGH_INPUT_DATA)
84204efc:	91 f0 03 88 	rMAC = M[r7 + 12];
84204f00:	48 24       	Null = rMAC - 1;
84204f02:	04 62       	if NE jump (m) Lc_celt_encode_process_data_44;

84204f04 <Lc_celt_encode_process_data_43>:
        {
            touched->sinks = TOUCHED_SOURCE_0 | TOUCHED_SOURCE_1;
84204f04:	c1 20       	rMAC = Null + 3;
84204f06:	42 d8       	r0 = M[FP + 32];
84204f08:	51 8e       	M[r0 + 4] = rMAC;

84204f0a <Lc_celt_encode_process_data_44>:
        }
    }
}
84204f0a:	69 4c       	SP = SP + -92;
84204f0c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84204f0e:	d8 4c       	rts;

84204f10 <Lc_free_data_and_fail_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param response Pointer to the response message to give a failed status
 */
static void free_data_and_fail(OPERATOR_DATA *op_data, void **response)
{
84204f10:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84204f12:	1e 00       	r4 = r1 + Null;
    patch_fn_shared(celt_encode_wrapper);
    /* Free the data and then override the response message status to fail */
    celt_encode_free_data(op_data);
84204f14:	fc ff 35 ef 	call (m) $_celt_encode_free_data;
84204f18:	01 f0 00 60 	rMAC = Null + 4096;
84204f1c:	32 e8       	r0 = M[r4 + Null];
84204f1e:	51 8e       	M[r0 + 4] = rMAC;

84204f20 <Lc_free_data_and_fail_2>:
    base_op_change_response_status(response, STATUS_CMD_FAILED);
}
84204f20:	f1 48       	popm <FP, r4, rLink>;
84204f22:	d8 4c       	rts;

84204f24 <Lc_celt_enc_offload_callback_1>:
 * to the data processing function. That then propagates metadata from the 
 * previous iteration and schedules a new one.
 */

static void celt_enc_offload_callback(void *context)
{
84204f24:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84204f26:	16 00       	r4 = r0 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84204f28:	ef fd da ff 	call (m) 0x4e6;
84204f2c:	3f ed 
84204f2e:	17 00       	r5 = r0 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84204f30:	32 00       	r0 = r4 + Null;
84204f32:	ef fd db ff 	call (m) 0x558;
84204f36:	27 e1 
{
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) context;
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    ENCODER_PARAMS *enc_base = get_class_data(op_data);

    if ((opx_data->kicks_pending) || (enc_base->codec.mode == CODEC_SUCCESS))
84204f38:	70 f0 a7 88 	Null = M[r5 + 668];
84204f3c:	03 62       	if NE jump (m) Lc_celt_enc_offload_callback_3;

84204f3e <Lc_celt_enc_offload_callback_2>:
84204f3e:	d0 88       	Null = M[r0 + 12];
84204f40:	07 62       	if NE jump (m) Lc_celt_enc_offload_callback_4;

84204f42 <Lc_celt_enc_offload_callback_3>:
    {
        opx_data->kicks_pending = FALSE;
84204f42:	70 f0 a7 8e 	M[r5 + 668] = Null;
        opmgr_kick_operator(op_data);
84204f46:	32 00       	r0 = r4 + Null;
84204f48:	ef fd f4 ff 	call (m) 0x374a;
84204f4c:	23 e0 

84204f4e <Lc_celt_enc_offload_callback_4>:
    }
}
84204f4e:	f2 48       	popm <FP, r4, r5, rLink>;
84204f50:	d8 4c       	rts;

84204f52 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_celt_encode_cap_data;
84204f52:	07 f0 02 f0 	r0 = Null + 7347792;
84204f56:	50 7a 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84204f58:	20 f0 f8 42 	Null = Null + 17144;

84204f5c <$_thread_offload_update_p1_dm_location>:
.CODESEGMENT PM;
.MINIM;

$_thread_offload_update_p1_dm_location:
#ifdef ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION
    rMAC = M[$_patched_fw_version];
84204f5c:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84204f60:	00 f0 10 f3 	Null = rMAC - 12417;
84204f64:	81 24 
    if EQ jump ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION;
84204f66:	fb ff b0 ff 	if EQ jump (m) 0x40027e2;
84204f6a:	fd e0 

84204f6c <$M.download_support_lib.thread_offload_update_p1_dm_location.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84204f6c:	02 00       	r0 = Null + Null;
    rts;
84204f6e:	d8 4c       	rts;
